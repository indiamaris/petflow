{"ast":null,"code":"import { drag } from 'd3-drag';\nimport { select, pointer } from 'd3-selection';\nimport { zoom, zoomIdentity, zoomTransform } from 'd3-zoom';\nimport { interpolateZoom, interpolate } from 'd3-interpolate';\nconst errorMessages = {\n  error001: () => '[React Flow]: Seems like you have not used zustand provider as an ancestor. Help: https://reactflow.dev/error#001',\n  error002: () => \"It looks like you've created a new nodeTypes or edgeTypes object. If this wasn't on purpose please define the nodeTypes/edgeTypes outside of the component or memoize them.\",\n  error003: nodeType => `Node type \"${nodeType}\" not found. Using fallback type \"default\".`,\n  error004: () => 'The React Flow parent container needs a width and a height to render the graph.',\n  error005: () => 'Only child nodes can use a parent extent.',\n  error006: () => \"Can't create edge. An edge needs a source and a target.\",\n  error007: id => `The old edge with id=${id} does not exist.`,\n  error009: type => `Marker type \"${type}\" doesn't exist.`,\n  error008: (handleType, {\n    id,\n    sourceHandle,\n    targetHandle\n  }) => `Couldn't create edge for ${handleType} handle id: \"${handleType === 'source' ? sourceHandle : targetHandle}\", edge id: ${id}.`,\n  error010: () => 'Handle: No node id found. Make sure to only use a Handle inside a custom Node.',\n  error011: edgeType => `Edge type \"${edgeType}\" not found. Using fallback type \"default\".`,\n  error012: id => `Node with id \"${id}\" does not exist, it may have been removed. This can happen when a node is deleted before the \"onNodeClick\" handler is called.`,\n  error013: (lib = 'react') => `It seems that you haven't loaded the styles. Please import '@xyflow/${lib}/dist/style.css' or base.css to make sure everything is working properly.`,\n  error014: () => 'useNodeConnections: No node ID found. Call useNodeConnections inside a custom Node or provide a node ID.',\n  error015: () => 'It seems that you are trying to drag a node that is not initialized. Please use onNodesChange as explained in the docs.'\n};\nconst infiniteExtent = [[Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY], [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY]];\nconst elementSelectionKeys = ['Enter', ' ', 'Escape'];\nconst defaultAriaLabelConfig = {\n  'node.a11yDescription.default': 'Press enter or space to select a node. Press delete to remove it and escape to cancel.',\n  'node.a11yDescription.keyboardDisabled': 'Press enter or space to select a node. You can then use the arrow keys to move the node around. Press delete to remove it and escape to cancel.',\n  'node.a11yDescription.ariaLiveMessage': ({\n    direction,\n    x,\n    y\n  }) => `Moved selected node ${direction}. New position, x: ${x}, y: ${y}`,\n  'edge.a11yDescription.default': 'Press enter or space to select an edge. You can then press delete to remove it or escape to cancel.',\n  // Control elements\n  'controls.ariaLabel': 'Control Panel',\n  'controls.zoomIn.ariaLabel': 'Zoom In',\n  'controls.zoomOut.ariaLabel': 'Zoom Out',\n  'controls.fitView.ariaLabel': 'Fit View',\n  'controls.interactive.ariaLabel': 'Toggle Interactivity',\n  // Mini map\n  'minimap.ariaLabel': 'Mini Map',\n  // Handle\n  'handle.ariaLabel': 'Handle'\n};\n\n/**\n * The `ConnectionMode` is used to set the mode of connection between nodes.\n * The `Strict` mode is the default one and only allows source to target edges.\n * `Loose` mode allows source to source and target to target edges as well.\n *\n * @public\n */\nvar ConnectionMode;\n(function (ConnectionMode) {\n  ConnectionMode[\"Strict\"] = \"strict\";\n  ConnectionMode[\"Loose\"] = \"loose\";\n})(ConnectionMode || (ConnectionMode = {}));\n/**\n * This enum is used to set the different modes of panning the viewport when the\n * user scrolls. The `Free` mode allows the user to pan in any direction by scrolling\n * with a device like a trackpad. The `Vertical` and `Horizontal` modes restrict\n * scroll panning to only the vertical or horizontal axis, respectively.\n *\n * @public\n */\nvar PanOnScrollMode;\n(function (PanOnScrollMode) {\n  PanOnScrollMode[\"Free\"] = \"free\";\n  PanOnScrollMode[\"Vertical\"] = \"vertical\";\n  PanOnScrollMode[\"Horizontal\"] = \"horizontal\";\n})(PanOnScrollMode || (PanOnScrollMode = {}));\nvar SelectionMode;\n(function (SelectionMode) {\n  SelectionMode[\"Partial\"] = \"partial\";\n  SelectionMode[\"Full\"] = \"full\";\n})(SelectionMode || (SelectionMode = {}));\nconst initialConnection = {\n  inProgress: false,\n  isValid: null,\n  from: null,\n  fromHandle: null,\n  fromPosition: null,\n  fromNode: null,\n  to: null,\n  toHandle: null,\n  toPosition: null,\n  toNode: null\n};\n\n/**\n * If you set the `connectionLineType` prop on your [`<ReactFlow />`](/api-reference/react-flow#connection-connectionLineType)\n *component, it will dictate the style of connection line rendered when creating\n *new edges.\n *\n * @public\n *\n * @remarks If you choose to render a custom connection line component, this value will be\n *passed to your component as part of its [`ConnectionLineComponentProps`](/api-reference/types/connection-line-component-props).\n */\nvar ConnectionLineType;\n(function (ConnectionLineType) {\n  ConnectionLineType[\"Bezier\"] = \"default\";\n  ConnectionLineType[\"Straight\"] = \"straight\";\n  ConnectionLineType[\"Step\"] = \"step\";\n  ConnectionLineType[\"SmoothStep\"] = \"smoothstep\";\n  ConnectionLineType[\"SimpleBezier\"] = \"simplebezier\";\n})(ConnectionLineType || (ConnectionLineType = {}));\n/**\n * Edges may optionally have a marker on either end. The MarkerType type enumerates\n * the options available to you when configuring a given marker.\n *\n * @public\n */\nvar MarkerType;\n(function (MarkerType) {\n  MarkerType[\"Arrow\"] = \"arrow\";\n  MarkerType[\"ArrowClosed\"] = \"arrowclosed\";\n})(MarkerType || (MarkerType = {}));\n\n/**\n * While [`PanelPosition`](/api-reference/types/panel-position) can be used to place a\n * component in the corners of a container, the `Position` enum is less precise and used\n * primarily in relation to edges and handles.\n *\n * @public\n */\nvar Position;\n(function (Position) {\n  Position[\"Left\"] = \"left\";\n  Position[\"Top\"] = \"top\";\n  Position[\"Right\"] = \"right\";\n  Position[\"Bottom\"] = \"bottom\";\n})(Position || (Position = {}));\nconst oppositePosition = {\n  [Position.Left]: Position.Right,\n  [Position.Right]: Position.Left,\n  [Position.Top]: Position.Bottom,\n  [Position.Bottom]: Position.Top\n};\n\n/**\n * @internal\n */\nfunction areConnectionMapsEqual(a, b) {\n  if (!a && !b) {\n    return true;\n  }\n  if (!a || !b || a.size !== b.size) {\n    return false;\n  }\n  if (!a.size && !b.size) {\n    return true;\n  }\n  for (const key of a.keys()) {\n    if (!b.has(key)) {\n      return false;\n    }\n  }\n  return true;\n}\n/**\n * We call the callback for all connections in a that are not in b\n *\n * @internal\n */\nfunction handleConnectionChange(a, b, cb) {\n  if (!cb) {\n    return;\n  }\n  const diff = [];\n  a.forEach((connection, key) => {\n    if (!b?.has(key)) {\n      diff.push(connection);\n    }\n  });\n  if (diff.length) {\n    cb(diff);\n  }\n}\nfunction getConnectionStatus(isValid) {\n  return isValid === null ? null : isValid ? 'valid' : 'invalid';\n}\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n/**\n * Test whether an object is usable as an Edge\n * @public\n * @remarks In TypeScript this is a type guard that will narrow the type of whatever you pass in to Edge if it returns true\n * @param element - The element to test\n * @returns A boolean indicating whether the element is an Edge\n */\nconst isEdgeBase = element => 'id' in element && 'source' in element && 'target' in element;\n/**\n * Test whether an object is usable as a Node\n * @public\n * @remarks In TypeScript this is a type guard that will narrow the type of whatever you pass in to Node if it returns true\n * @param element - The element to test\n * @returns A boolean indicating whether the element is an Node\n */\nconst isNodeBase = element => 'id' in element && 'position' in element && !('source' in element) && !('target' in element);\nconst isInternalNodeBase = element => 'id' in element && 'internals' in element && !('source' in element) && !('target' in element);\n/**\n * This util is used to tell you what nodes, if any, are connected to the given node\n * as the _target_ of an edge.\n * @public\n * @param node - The node to get the connected nodes from.\n * @param nodes - The array of all nodes.\n * @param edges - The array of all edges.\n * @returns An array of nodes that are connected over edges where the source is the given node.\n *\n * @example\n * ```ts\n *import { getOutgoers } from '@xyflow/react';\n *\n *const nodes = [];\n *const edges = [];\n *\n *const outgoers = getOutgoers(\n *  { id: '1', position: { x: 0, y: 0 }, data: { label: 'node' } },\n *  nodes,\n *  edges,\n *);\n *```\n */\nconst getOutgoers = (node, nodes, edges) => {\n  if (!node.id) {\n    return [];\n  }\n  const outgoerIds = new Set();\n  edges.forEach(edge => {\n    if (edge.source === node.id) {\n      outgoerIds.add(edge.target);\n    }\n  });\n  return nodes.filter(n => outgoerIds.has(n.id));\n};\n/**\n * This util is used to tell you what nodes, if any, are connected to the given node\n * as the _source_ of an edge.\n * @public\n * @param node - The node to get the connected nodes from.\n * @param nodes - The array of all nodes.\n * @param edges - The array of all edges.\n * @returns An array of nodes that are connected over edges where the target is the given node.\n *\n * @example\n * ```ts\n *import { getIncomers } from '@xyflow/react';\n *\n *const nodes = [];\n *const edges = [];\n *\n *const incomers = getIncomers(\n *  { id: '1', position: { x: 0, y: 0 }, data: { label: 'node' } },\n *  nodes,\n *  edges,\n *);\n *```\n */\nconst getIncomers = (node, nodes, edges) => {\n  if (!node.id) {\n    return [];\n  }\n  const incomersIds = new Set();\n  edges.forEach(edge => {\n    if (edge.target === node.id) {\n      incomersIds.add(edge.source);\n    }\n  });\n  return nodes.filter(n => incomersIds.has(n.id));\n};\nconst getNodePositionWithOrigin = (node, nodeOrigin = [0, 0]) => {\n  const {\n    width,\n    height\n  } = getNodeDimensions(node);\n  const origin = node.origin ?? nodeOrigin;\n  const offsetX = width * origin[0];\n  const offsetY = height * origin[1];\n  return {\n    x: node.position.x - offsetX,\n    y: node.position.y - offsetY\n  };\n};\n/**\n * Returns the bounding box that contains all the given nodes in an array. This can\n * be useful when combined with [`getViewportForBounds`](/api-reference/utils/get-viewport-for-bounds)\n * to calculate the correct transform to fit the given nodes in a viewport.\n * @public\n * @remarks Useful when combined with {@link getViewportForBounds} to calculate the correct transform to fit the given nodes in a viewport.\n * @param nodes - Nodes to calculate the bounds for.\n * @returns Bounding box enclosing all nodes.\n *\n * @remarks This function was previously called `getRectOfNodes`\n *\n * @example\n * ```js\n *import { getNodesBounds } from '@xyflow/react';\n *\n *const nodes = [\n *  {\n *    id: 'a',\n *    position: { x: 0, y: 0 },\n *    data: { label: 'a' },\n *    width: 50,\n *    height: 25,\n *  },\n *  {\n *    id: 'b',\n *    position: { x: 100, y: 100 },\n *    data: { label: 'b' },\n *    width: 50,\n *    height: 25,\n *  },\n *];\n *\n *const bounds = getNodesBounds(nodes);\n *```\n */\nconst getNodesBounds = (nodes, params = {\n  nodeOrigin: [0, 0]\n}) => {\n  if (process.env.NODE_ENV === 'development' && !params.nodeLookup) {\n    console.warn('Please use `getNodesBounds` from `useReactFlow`/`useSvelteFlow` hook to ensure correct values for sub flows. If not possible, you have to provide a nodeLookup to support sub flows.');\n  }\n  if (nodes.length === 0) {\n    return {\n      x: 0,\n      y: 0,\n      width: 0,\n      height: 0\n    };\n  }\n  const box = nodes.reduce((currBox, nodeOrId) => {\n    const isId = typeof nodeOrId === 'string';\n    let currentNode = !params.nodeLookup && !isId ? nodeOrId : undefined;\n    if (params.nodeLookup) {\n      currentNode = isId ? params.nodeLookup.get(nodeOrId) : !isInternalNodeBase(nodeOrId) ? params.nodeLookup.get(nodeOrId.id) : nodeOrId;\n    }\n    const nodeBox = currentNode ? nodeToBox(currentNode, params.nodeOrigin) : {\n      x: 0,\n      y: 0,\n      x2: 0,\n      y2: 0\n    };\n    return getBoundsOfBoxes(currBox, nodeBox);\n  }, {\n    x: Infinity,\n    y: Infinity,\n    x2: -Infinity,\n    y2: -Infinity\n  });\n  return boxToRect(box);\n};\n/**\n * Determines a bounding box that contains all given nodes in an array\n * @internal\n */\nconst getInternalNodesBounds = (nodeLookup, params = {}) => {\n  if (nodeLookup.size === 0) {\n    return {\n      x: 0,\n      y: 0,\n      width: 0,\n      height: 0\n    };\n  }\n  let box = {\n    x: Infinity,\n    y: Infinity,\n    x2: -Infinity,\n    y2: -Infinity\n  };\n  nodeLookup.forEach(node => {\n    if (params.filter === undefined || params.filter(node)) {\n      const nodeBox = nodeToBox(node);\n      box = getBoundsOfBoxes(box, nodeBox);\n    }\n  });\n  return boxToRect(box);\n};\nconst getNodesInside = (nodes, rect, [tx, ty, tScale] = [0, 0, 1], partially = false,\n// set excludeNonSelectableNodes if you want to pay attention to the nodes \"selectable\" attribute\nexcludeNonSelectableNodes = false) => {\n  const paneRect = {\n    ...pointToRendererPoint(rect, [tx, ty, tScale]),\n    width: rect.width / tScale,\n    height: rect.height / tScale\n  };\n  const visibleNodes = [];\n  for (const node of nodes.values()) {\n    const {\n      measured,\n      selectable = true,\n      hidden = false\n    } = node;\n    if (excludeNonSelectableNodes && !selectable || hidden) {\n      continue;\n    }\n    const width = measured.width ?? node.width ?? node.initialWidth ?? null;\n    const height = measured.height ?? node.height ?? node.initialHeight ?? null;\n    const overlappingArea = getOverlappingArea(paneRect, nodeToRect(node));\n    const area = (width ?? 0) * (height ?? 0);\n    const partiallyVisible = partially && overlappingArea > 0;\n    const forceInitialRender = !node.internals.handleBounds;\n    const isVisible = forceInitialRender || partiallyVisible || overlappingArea >= area;\n    if (isVisible || node.dragging) {\n      visibleNodes.push(node);\n    }\n  }\n  return visibleNodes;\n};\n/**\n * This utility filters an array of edges, keeping only those where either the source or target\n * node is present in the given array of nodes.\n * @public\n * @param nodes - Nodes you want to get the connected edges for.\n * @param edges - All edges.\n * @returns Array of edges that connect any of the given nodes with each other.\n *\n * @example\n * ```js\n *import { getConnectedEdges } from '@xyflow/react';\n *\n *const nodes = [\n *  { id: 'a', position: { x: 0, y: 0 } },\n *  { id: 'b', position: { x: 100, y: 0 } },\n *];\n *\n *const edges = [\n *  { id: 'a->c', source: 'a', target: 'c' },\n *  { id: 'c->d', source: 'c', target: 'd' },\n *];\n *\n *const connectedEdges = getConnectedEdges(nodes, edges);\n * // => [{ id: 'a->c', source: 'a', target: 'c' }]\n *```\n */\nconst getConnectedEdges = (nodes, edges) => {\n  const nodeIds = new Set();\n  nodes.forEach(node => {\n    nodeIds.add(node.id);\n  });\n  return edges.filter(edge => nodeIds.has(edge.source) || nodeIds.has(edge.target));\n};\nfunction getFitViewNodes(nodeLookup, options) {\n  const fitViewNodes = new Map();\n  const optionNodeIds = options?.nodes ? new Set(options.nodes.map(node => node.id)) : null;\n  nodeLookup.forEach(n => {\n    const isVisible = n.measured.width && n.measured.height && (options?.includeHiddenNodes || !n.hidden);\n    if (isVisible && (!optionNodeIds || optionNodeIds.has(n.id))) {\n      fitViewNodes.set(n.id, n);\n    }\n  });\n  return fitViewNodes;\n}\nasync function fitViewport({\n  nodes,\n  width,\n  height,\n  panZoom,\n  minZoom,\n  maxZoom\n}, options) {\n  if (nodes.size === 0) {\n    return Promise.resolve(true);\n  }\n  const nodesToFit = getFitViewNodes(nodes, options);\n  const bounds = getInternalNodesBounds(nodesToFit);\n  const viewport = getViewportForBounds(bounds, width, height, options?.minZoom ?? minZoom, options?.maxZoom ?? maxZoom, options?.padding ?? 0.1);\n  await panZoom.setViewport(viewport, {\n    duration: options?.duration,\n    ease: options?.ease,\n    interpolate: options?.interpolate\n  });\n  return Promise.resolve(true);\n}\n/**\n * This function calculates the next position of a node, taking into account the node's extent, parent node, and origin.\n *\n * @internal\n * @returns position, positionAbsolute\n */\nfunction calculateNodePosition({\n  nodeId,\n  nextPosition,\n  nodeLookup,\n  nodeOrigin = [0, 0],\n  nodeExtent,\n  onError\n}) {\n  const node = nodeLookup.get(nodeId);\n  const parentNode = node.parentId ? nodeLookup.get(node.parentId) : undefined;\n  const {\n    x: parentX,\n    y: parentY\n  } = parentNode ? parentNode.internals.positionAbsolute : {\n    x: 0,\n    y: 0\n  };\n  const origin = node.origin ?? nodeOrigin;\n  let extent = node.extent || nodeExtent;\n  if (node.extent === 'parent' && !node.expandParent) {\n    if (!parentNode) {\n      onError?.('005', errorMessages['error005']());\n    } else {\n      const parentWidth = parentNode.measured.width;\n      const parentHeight = parentNode.measured.height;\n      if (parentWidth && parentHeight) {\n        extent = [[parentX, parentY], [parentX + parentWidth, parentY + parentHeight]];\n      }\n    }\n  } else if (parentNode && isCoordinateExtent(node.extent)) {\n    extent = [[node.extent[0][0] + parentX, node.extent[0][1] + parentY], [node.extent[1][0] + parentX, node.extent[1][1] + parentY]];\n  }\n  const positionAbsolute = isCoordinateExtent(extent) ? clampPosition(nextPosition, extent, node.measured) : nextPosition;\n  if (node.measured.width === undefined || node.measured.height === undefined) {\n    onError?.('015', errorMessages['error015']());\n  }\n  return {\n    position: {\n      x: positionAbsolute.x - parentX + (node.measured.width ?? 0) * origin[0],\n      y: positionAbsolute.y - parentY + (node.measured.height ?? 0) * origin[1]\n    },\n    positionAbsolute\n  };\n}\n/**\n * Pass in nodes & edges to delete, get arrays of nodes and edges that actually can be deleted\n * @internal\n * @param param.nodesToRemove - The nodes to remove\n * @param param.edgesToRemove - The edges to remove\n * @param param.nodes - All nodes\n * @param param.edges - All edges\n * @param param.onBeforeDelete - Callback to check which nodes and edges can be deleted\n * @returns nodes: nodes that can be deleted, edges: edges that can be deleted\n */\nasync function getElementsToRemove({\n  nodesToRemove = [],\n  edgesToRemove = [],\n  nodes,\n  edges,\n  onBeforeDelete\n}) {\n  const nodeIds = new Set(nodesToRemove.map(node => node.id));\n  const matchingNodes = [];\n  for (const node of nodes) {\n    if (node.deletable === false) {\n      continue;\n    }\n    const isIncluded = nodeIds.has(node.id);\n    const parentHit = !isIncluded && node.parentId && matchingNodes.find(n => n.id === node.parentId);\n    if (isIncluded || parentHit) {\n      matchingNodes.push(node);\n    }\n  }\n  const edgeIds = new Set(edgesToRemove.map(edge => edge.id));\n  const deletableEdges = edges.filter(edge => edge.deletable !== false);\n  const connectedEdges = getConnectedEdges(matchingNodes, deletableEdges);\n  const matchingEdges = connectedEdges;\n  for (const edge of deletableEdges) {\n    const isIncluded = edgeIds.has(edge.id);\n    if (isIncluded && !matchingEdges.find(e => e.id === edge.id)) {\n      matchingEdges.push(edge);\n    }\n  }\n  if (!onBeforeDelete) {\n    return {\n      edges: matchingEdges,\n      nodes: matchingNodes\n    };\n  }\n  const onBeforeDeleteResult = await onBeforeDelete({\n    nodes: matchingNodes,\n    edges: matchingEdges\n  });\n  if (typeof onBeforeDeleteResult === 'boolean') {\n    return onBeforeDeleteResult ? {\n      edges: matchingEdges,\n      nodes: matchingNodes\n    } : {\n      edges: [],\n      nodes: []\n    };\n  }\n  return onBeforeDeleteResult;\n}\nconst clamp = (val, min = 0, max = 1) => Math.min(Math.max(val, min), max);\nconst clampPosition = (position = {\n  x: 0,\n  y: 0\n}, extent, dimensions) => ({\n  x: clamp(position.x, extent[0][0], extent[1][0] - (dimensions?.width ?? 0)),\n  y: clamp(position.y, extent[0][1], extent[1][1] - (dimensions?.height ?? 0))\n});\nfunction clampPositionToParent(childPosition, childDimensions, parent) {\n  const {\n    width: parentWidth,\n    height: parentHeight\n  } = getNodeDimensions(parent);\n  const {\n    x: parentX,\n    y: parentY\n  } = parent.internals.positionAbsolute;\n  return clampPosition(childPosition, [[parentX, parentY], [parentX + parentWidth, parentY + parentHeight]], childDimensions);\n}\n/**\n * Calculates the velocity of panning when the mouse is close to the edge of the canvas\n * @internal\n * @param value - One dimensional poition of the mouse (x or y)\n * @param min - Minimal position on canvas before panning starts\n * @param max - Maximal position on canvas before panning starts\n * @returns - A number between 0 and 1 that represents the velocity of panning\n */\nconst calcAutoPanVelocity = (value, min, max) => {\n  if (value < min) {\n    return clamp(Math.abs(value - min), 1, min) / min;\n  } else if (value > max) {\n    return -clamp(Math.abs(value - max), 1, min) / min;\n  }\n  return 0;\n};\nconst calcAutoPan = (pos, bounds, speed = 15, distance = 40) => {\n  const xMovement = calcAutoPanVelocity(pos.x, distance, bounds.width - distance) * speed;\n  const yMovement = calcAutoPanVelocity(pos.y, distance, bounds.height - distance) * speed;\n  return [xMovement, yMovement];\n};\nconst getBoundsOfBoxes = (box1, box2) => ({\n  x: Math.min(box1.x, box2.x),\n  y: Math.min(box1.y, box2.y),\n  x2: Math.max(box1.x2, box2.x2),\n  y2: Math.max(box1.y2, box2.y2)\n});\nconst rectToBox = ({\n  x,\n  y,\n  width,\n  height\n}) => ({\n  x,\n  y,\n  x2: x + width,\n  y2: y + height\n});\nconst boxToRect = ({\n  x,\n  y,\n  x2,\n  y2\n}) => ({\n  x,\n  y,\n  width: x2 - x,\n  height: y2 - y\n});\nconst nodeToRect = (node, nodeOrigin = [0, 0]) => {\n  const {\n    x,\n    y\n  } = isInternalNodeBase(node) ? node.internals.positionAbsolute : getNodePositionWithOrigin(node, nodeOrigin);\n  return {\n    x,\n    y,\n    width: node.measured?.width ?? node.width ?? node.initialWidth ?? 0,\n    height: node.measured?.height ?? node.height ?? node.initialHeight ?? 0\n  };\n};\nconst nodeToBox = (node, nodeOrigin = [0, 0]) => {\n  const {\n    x,\n    y\n  } = isInternalNodeBase(node) ? node.internals.positionAbsolute : getNodePositionWithOrigin(node, nodeOrigin);\n  return {\n    x,\n    y,\n    x2: x + (node.measured?.width ?? node.width ?? node.initialWidth ?? 0),\n    y2: y + (node.measured?.height ?? node.height ?? node.initialHeight ?? 0)\n  };\n};\nconst getBoundsOfRects = (rect1, rect2) => boxToRect(getBoundsOfBoxes(rectToBox(rect1), rectToBox(rect2)));\nconst getOverlappingArea = (rectA, rectB) => {\n  const xOverlap = Math.max(0, Math.min(rectA.x + rectA.width, rectB.x + rectB.width) - Math.max(rectA.x, rectB.x));\n  const yOverlap = Math.max(0, Math.min(rectA.y + rectA.height, rectB.y + rectB.height) - Math.max(rectA.y, rectB.y));\n  return Math.ceil(xOverlap * yOverlap);\n};\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst isRectObject = obj => isNumeric(obj.width) && isNumeric(obj.height) && isNumeric(obj.x) && isNumeric(obj.y);\n/* eslint-disable-next-line @typescript-eslint/no-explicit-any */\nconst isNumeric = n => !isNaN(n) && isFinite(n);\n// used for a11y key board controls for nodes and edges\nconst devWarn = (id, message) => {\n  if (process.env.NODE_ENV === 'development') {\n    console.warn(`[React Flow]: ${message} Help: https://reactflow.dev/error#${id}`);\n  }\n};\nconst snapPosition = (position, snapGrid = [1, 1]) => {\n  return {\n    x: snapGrid[0] * Math.round(position.x / snapGrid[0]),\n    y: snapGrid[1] * Math.round(position.y / snapGrid[1])\n  };\n};\nconst pointToRendererPoint = ({\n  x,\n  y\n}, [tx, ty, tScale], snapToGrid = false, snapGrid = [1, 1]) => {\n  const position = {\n    x: (x - tx) / tScale,\n    y: (y - ty) / tScale\n  };\n  return snapToGrid ? snapPosition(position, snapGrid) : position;\n};\nconst rendererPointToPoint = ({\n  x,\n  y\n}, [tx, ty, tScale]) => {\n  return {\n    x: x * tScale + tx,\n    y: y * tScale + ty\n  };\n};\n/**\n * Parses a single padding value to a number\n * @internal\n * @param padding - Padding to parse\n * @param viewport - Width or height of the viewport\n * @returns The padding in pixels\n */\nfunction parsePadding(padding, viewport) {\n  if (typeof padding === 'number') {\n    return Math.floor((viewport - viewport / (1 + padding)) * 0.5);\n  }\n  if (typeof padding === 'string' && padding.endsWith('px')) {\n    const paddingValue = parseFloat(padding);\n    if (!Number.isNaN(paddingValue)) {\n      return Math.floor(paddingValue);\n    }\n  }\n  if (typeof padding === 'string' && padding.endsWith('%')) {\n    const paddingValue = parseFloat(padding);\n    if (!Number.isNaN(paddingValue)) {\n      return Math.floor(viewport * paddingValue * 0.01);\n    }\n  }\n  console.error(`[React Flow] The padding value \"${padding}\" is invalid. Please provide a number or a string with a valid unit (px or %).`);\n  return 0;\n}\n/**\n * Parses the paddings to an object with top, right, bottom, left, x and y paddings\n * @internal\n * @param padding - Padding to parse\n * @param width - Width of the viewport\n * @param height - Height of the viewport\n * @returns An object with the paddings in pixels\n */\nfunction parsePaddings(padding, width, height) {\n  if (typeof padding === 'string' || typeof padding === 'number') {\n    const paddingY = parsePadding(padding, height);\n    const paddingX = parsePadding(padding, width);\n    return {\n      top: paddingY,\n      right: paddingX,\n      bottom: paddingY,\n      left: paddingX,\n      x: paddingX * 2,\n      y: paddingY * 2\n    };\n  }\n  if (typeof padding === 'object') {\n    const top = parsePadding(padding.top ?? padding.y ?? 0, height);\n    const bottom = parsePadding(padding.bottom ?? padding.y ?? 0, height);\n    const left = parsePadding(padding.left ?? padding.x ?? 0, width);\n    const right = parsePadding(padding.right ?? padding.x ?? 0, width);\n    return {\n      top,\n      right,\n      bottom,\n      left,\n      x: left + right,\n      y: top + bottom\n    };\n  }\n  return {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0,\n    x: 0,\n    y: 0\n  };\n}\n/**\n * Calculates the resulting paddings if the new viewport is applied\n * @internal\n * @param bounds - Bounds to fit inside viewport\n * @param x - X position of the viewport\n * @param y - Y position of the viewport\n * @param zoom - Zoom level of the viewport\n * @param width - Width of the viewport\n * @param height - Height of the viewport\n * @returns An object with the minimum padding required to fit the bounds inside the viewport\n */\nfunction calculateAppliedPaddings(bounds, x, y, zoom, width, height) {\n  const {\n    x: left,\n    y: top\n  } = rendererPointToPoint(bounds, [x, y, zoom]);\n  const {\n    x: boundRight,\n    y: boundBottom\n  } = rendererPointToPoint({\n    x: bounds.x + bounds.width,\n    y: bounds.y + bounds.height\n  }, [x, y, zoom]);\n  const right = width - boundRight;\n  const bottom = height - boundBottom;\n  return {\n    left: Math.floor(left),\n    top: Math.floor(top),\n    right: Math.floor(right),\n    bottom: Math.floor(bottom)\n  };\n}\n/**\n * Returns a viewport that encloses the given bounds with padding.\n * @public\n * @remarks You can determine bounds of nodes with {@link getNodesBounds} and {@link getBoundsOfRects}\n * @param bounds - Bounds to fit inside viewport.\n * @param width - Width of the viewport.\n * @param height  - Height of the viewport.\n * @param minZoom - Minimum zoom level of the resulting viewport.\n * @param maxZoom - Maximum zoom level of the resulting viewport.\n * @param padding - Padding around the bounds.\n * @returns A transformed {@link Viewport} that encloses the given bounds which you can pass to e.g. {@link setViewport}.\n * @example\n * const { x, y, zoom } = getViewportForBounds(\n * { x: 0, y: 0, width: 100, height: 100},\n * 1200, 800, 0.5, 2);\n */\nconst getViewportForBounds = (bounds, width, height, minZoom, maxZoom, padding) => {\n  // First we resolve all the paddings to actual pixel values\n  const p = parsePaddings(padding, width, height);\n  const xZoom = (width - p.x) / bounds.width;\n  const yZoom = (height - p.y) / bounds.height;\n  // We calculate the new x, y, zoom for a centered view\n  const zoom = Math.min(xZoom, yZoom);\n  const clampedZoom = clamp(zoom, minZoom, maxZoom);\n  const boundsCenterX = bounds.x + bounds.width / 2;\n  const boundsCenterY = bounds.y + bounds.height / 2;\n  const x = width / 2 - boundsCenterX * clampedZoom;\n  const y = height / 2 - boundsCenterY * clampedZoom;\n  // Then we calculate the minimum padding, to respect asymmetric paddings\n  const newPadding = calculateAppliedPaddings(bounds, x, y, clampedZoom, width, height);\n  // We only want to have an offset if the newPadding is smaller than the required padding\n  const offset = {\n    left: Math.min(newPadding.left - p.left, 0),\n    top: Math.min(newPadding.top - p.top, 0),\n    right: Math.min(newPadding.right - p.right, 0),\n    bottom: Math.min(newPadding.bottom - p.bottom, 0)\n  };\n  return {\n    x: x - offset.left + offset.right,\n    y: y - offset.top + offset.bottom,\n    zoom: clampedZoom\n  };\n};\nconst isMacOs = () => typeof navigator !== 'undefined' && navigator?.userAgent?.indexOf('Mac') >= 0;\nfunction isCoordinateExtent(extent) {\n  return extent !== undefined && extent !== null && extent !== 'parent';\n}\nfunction getNodeDimensions(node) {\n  return {\n    width: node.measured?.width ?? node.width ?? node.initialWidth ?? 0,\n    height: node.measured?.height ?? node.height ?? node.initialHeight ?? 0\n  };\n}\nfunction nodeHasDimensions(node) {\n  return (node.measured?.width ?? node.width ?? node.initialWidth) !== undefined && (node.measured?.height ?? node.height ?? node.initialHeight) !== undefined;\n}\n/**\n * Convert child position to aboslute position\n *\n * @internal\n * @param position\n * @param parentId\n * @param nodeLookup\n * @param nodeOrigin\n * @returns an internal node with an absolute position\n */\nfunction evaluateAbsolutePosition(position, dimensions = {\n  width: 0,\n  height: 0\n}, parentId, nodeLookup, nodeOrigin) {\n  const positionAbsolute = {\n    ...position\n  };\n  const parent = nodeLookup.get(parentId);\n  if (parent) {\n    const origin = parent.origin || nodeOrigin;\n    positionAbsolute.x += parent.internals.positionAbsolute.x - (dimensions.width ?? 0) * origin[0];\n    positionAbsolute.y += parent.internals.positionAbsolute.y - (dimensions.height ?? 0) * origin[1];\n  }\n  return positionAbsolute;\n}\nfunction areSetsEqual(a, b) {\n  if (a.size !== b.size) {\n    return false;\n  }\n  for (const item of a) {\n    if (!b.has(item)) {\n      return false;\n    }\n  }\n  return true;\n}\n/**\n * Polyfill for Promise.withResolvers until we can use it in all browsers\n * @internal\n */\nfunction withResolvers() {\n  let resolve;\n  let reject;\n  const promise = new Promise((res, rej) => {\n    resolve = res;\n    reject = rej;\n  });\n  return {\n    promise,\n    resolve,\n    reject\n  };\n}\nfunction mergeAriaLabelConfig(partial) {\n  return {\n    ...defaultAriaLabelConfig,\n    ...(partial || {})\n  };\n}\nfunction getPointerPosition(event, {\n  snapGrid = [0, 0],\n  snapToGrid = false,\n  transform,\n  containerBounds\n}) {\n  const {\n    x,\n    y\n  } = getEventPosition(event);\n  const pointerPos = pointToRendererPoint({\n    x: x - (containerBounds?.left ?? 0),\n    y: y - (containerBounds?.top ?? 0)\n  }, transform);\n  const {\n    x: xSnapped,\n    y: ySnapped\n  } = snapToGrid ? snapPosition(pointerPos, snapGrid) : pointerPos;\n  // we need the snapped position in order to be able to skip unnecessary drag events\n  return {\n    xSnapped,\n    ySnapped,\n    ...pointerPos\n  };\n}\nconst getDimensions = node => ({\n  width: node.offsetWidth,\n  height: node.offsetHeight\n});\nconst getHostForElement = element => element?.getRootNode?.() || window?.document;\nconst inputTags = ['INPUT', 'SELECT', 'TEXTAREA'];\nfunction isInputDOMNode(event) {\n  // using composed path for handling shadow dom\n  const target = event.composedPath?.()?.[0] || event.target;\n  if (target?.nodeType !== 1 /* Node.ELEMENT_NODE */) return false;\n  const isInput = inputTags.includes(target.nodeName) || target.hasAttribute('contenteditable');\n  // when an input field is focused we don't want to trigger deletion or movement of nodes\n  return isInput || !!target.closest('.nokey');\n}\nconst isMouseEvent = event => 'clientX' in event;\nconst getEventPosition = (event, bounds) => {\n  const isMouse = isMouseEvent(event);\n  const evtX = isMouse ? event.clientX : event.touches?.[0].clientX;\n  const evtY = isMouse ? event.clientY : event.touches?.[0].clientY;\n  return {\n    x: evtX - (bounds?.left ?? 0),\n    y: evtY - (bounds?.top ?? 0)\n  };\n};\n/*\n * The handle bounds are calculated relative to the node element.\n * We store them in the internals object of the node in order to avoid\n * unnecessary recalculations.\n */\nconst getHandleBounds = (type, nodeElement, nodeBounds, zoom, nodeId) => {\n  const handles = nodeElement.querySelectorAll(`.${type}`);\n  if (!handles || !handles.length) {\n    return null;\n  }\n  return Array.from(handles).map(handle => {\n    const handleBounds = handle.getBoundingClientRect();\n    return {\n      id: handle.getAttribute('data-handleid'),\n      type,\n      nodeId,\n      position: handle.getAttribute('data-handlepos'),\n      x: (handleBounds.left - nodeBounds.left) / zoom,\n      y: (handleBounds.top - nodeBounds.top) / zoom,\n      ...getDimensions(handle)\n    };\n  });\n};\nfunction getBezierEdgeCenter({\n  sourceX,\n  sourceY,\n  targetX,\n  targetY,\n  sourceControlX,\n  sourceControlY,\n  targetControlX,\n  targetControlY\n}) {\n  /*\n   * cubic bezier t=0.5 mid point, not the actual mid point, but easy to calculate\n   * https://stackoverflow.com/questions/67516101/how-to-find-distance-mid-point-of-bezier-curve\n   */\n  const centerX = sourceX * 0.125 + sourceControlX * 0.375 + targetControlX * 0.375 + targetX * 0.125;\n  const centerY = sourceY * 0.125 + sourceControlY * 0.375 + targetControlY * 0.375 + targetY * 0.125;\n  const offsetX = Math.abs(centerX - sourceX);\n  const offsetY = Math.abs(centerY - sourceY);\n  return [centerX, centerY, offsetX, offsetY];\n}\nfunction calculateControlOffset(distance, curvature) {\n  if (distance >= 0) {\n    return 0.5 * distance;\n  }\n  return curvature * 25 * Math.sqrt(-distance);\n}\nfunction getControlWithCurvature({\n  pos,\n  x1,\n  y1,\n  x2,\n  y2,\n  c\n}) {\n  switch (pos) {\n    case Position.Left:\n      return [x1 - calculateControlOffset(x1 - x2, c), y1];\n    case Position.Right:\n      return [x1 + calculateControlOffset(x2 - x1, c), y1];\n    case Position.Top:\n      return [x1, y1 - calculateControlOffset(y1 - y2, c)];\n    case Position.Bottom:\n      return [x1, y1 + calculateControlOffset(y2 - y1, c)];\n  }\n}\n/**\n * The `getBezierPath` util returns everything you need to render a bezier edge\n *between two nodes.\n * @public\n * @returns A path string you can use in an SVG, the `labelX` and `labelY` position (center of path)\n * and `offsetX`, `offsetY` between source handle and label.\n * - `path`: the path to use in an SVG `<path>` element.\n * - `labelX`: the `x` position you can use to render a label for this edge.\n * - `labelY`: the `y` position you can use to render a label for this edge.\n * - `offsetX`: the absolute difference between the source `x` position and the `x` position of the\n * middle of this path.\n * - `offsetY`: the absolute difference between the source `y` position and the `y` position of the\n * middle of this path.\n * @example\n * ```js\n *  const source = { x: 0, y: 20 };\n *  const target = { x: 150, y: 100 };\n *\n *  const [path, labelX, labelY, offsetX, offsetY] = getBezierPath({\n *    sourceX: source.x,\n *    sourceY: source.y,\n *    sourcePosition: Position.Right,\n *    targetX: target.x,\n *    targetY: target.y,\n *    targetPosition: Position.Left,\n *});\n *```\n *\n * @remarks This function returns a tuple (aka a fixed-size array) to make it easier to\n *work with multiple edge paths at once.\n */\nfunction getBezierPath({\n  sourceX,\n  sourceY,\n  sourcePosition = Position.Bottom,\n  targetX,\n  targetY,\n  targetPosition = Position.Top,\n  curvature = 0.25\n}) {\n  const [sourceControlX, sourceControlY] = getControlWithCurvature({\n    pos: sourcePosition,\n    x1: sourceX,\n    y1: sourceY,\n    x2: targetX,\n    y2: targetY,\n    c: curvature\n  });\n  const [targetControlX, targetControlY] = getControlWithCurvature({\n    pos: targetPosition,\n    x1: targetX,\n    y1: targetY,\n    x2: sourceX,\n    y2: sourceY,\n    c: curvature\n  });\n  const [labelX, labelY, offsetX, offsetY] = getBezierEdgeCenter({\n    sourceX,\n    sourceY,\n    targetX,\n    targetY,\n    sourceControlX,\n    sourceControlY,\n    targetControlX,\n    targetControlY\n  });\n  return [`M${sourceX},${sourceY} C${sourceControlX},${sourceControlY} ${targetControlX},${targetControlY} ${targetX},${targetY}`, labelX, labelY, offsetX, offsetY];\n}\n\n// this is used for straight edges and simple smoothstep edges (LTR, RTL, BTT, TTB)\nfunction getEdgeCenter({\n  sourceX,\n  sourceY,\n  targetX,\n  targetY\n}) {\n  const xOffset = Math.abs(targetX - sourceX) / 2;\n  const centerX = targetX < sourceX ? targetX + xOffset : targetX - xOffset;\n  const yOffset = Math.abs(targetY - sourceY) / 2;\n  const centerY = targetY < sourceY ? targetY + yOffset : targetY - yOffset;\n  return [centerX, centerY, xOffset, yOffset];\n}\n/**\n * Returns the z-index for an edge based on the node it connects and whether it is selected.\n * By default, edges are rendered below nodes. This behaviour is different for edges that are\n * connected to nodes with a parent, as they are rendered above the parent node.\n */\nfunction getElevatedEdgeZIndex({\n  sourceNode,\n  targetNode,\n  selected = false,\n  zIndex,\n  elevateOnSelect = false\n}) {\n  if (zIndex !== undefined) {\n    return zIndex;\n  }\n  const edgeZ = elevateOnSelect && selected ? 1000 : 0;\n  const nodeZ = Math.max(sourceNode.parentId ? sourceNode.internals.z : 0, targetNode.parentId ? targetNode.internals.z : 0);\n  return edgeZ + nodeZ;\n}\nfunction isEdgeVisible({\n  sourceNode,\n  targetNode,\n  width,\n  height,\n  transform\n}) {\n  const edgeBox = getBoundsOfBoxes(nodeToBox(sourceNode), nodeToBox(targetNode));\n  if (edgeBox.x === edgeBox.x2) {\n    edgeBox.x2 += 1;\n  }\n  if (edgeBox.y === edgeBox.y2) {\n    edgeBox.y2 += 1;\n  }\n  const viewRect = {\n    x: -transform[0] / transform[2],\n    y: -transform[1] / transform[2],\n    width: width / transform[2],\n    height: height / transform[2]\n  };\n  return getOverlappingArea(viewRect, boxToRect(edgeBox)) > 0;\n}\nconst getEdgeId = ({\n  source,\n  sourceHandle,\n  target,\n  targetHandle\n}) => `xy-edge__${source}${sourceHandle || ''}-${target}${targetHandle || ''}`;\nconst connectionExists = (edge, edges) => {\n  return edges.some(el => el.source === edge.source && el.target === edge.target && (el.sourceHandle === edge.sourceHandle || !el.sourceHandle && !edge.sourceHandle) && (el.targetHandle === edge.targetHandle || !el.targetHandle && !edge.targetHandle));\n};\n/**\n * This util is a convenience function to add a new Edge to an array of edges. It also performs some validation to make sure you don't add an invalid edge or duplicate an existing one.\n * @public\n * @param edgeParams - Either an `Edge` or a `Connection` you want to add.\n * @param edges - The array of all current edges.\n * @returns A new array of edges with the new edge added.\n *\n * @remarks If an edge with the same `target` and `source` already exists (and the same\n *`targetHandle` and `sourceHandle` if those are set), then this util won't add\n *a new edge even if the `id` property is different.\n *\n */\nconst addEdge = (edgeParams, edges) => {\n  if (!edgeParams.source || !edgeParams.target) {\n    devWarn('006', errorMessages['error006']());\n    return edges;\n  }\n  let edge;\n  if (isEdgeBase(edgeParams)) {\n    edge = {\n      ...edgeParams\n    };\n  } else {\n    edge = {\n      ...edgeParams,\n      id: getEdgeId(edgeParams)\n    };\n  }\n  if (connectionExists(edge, edges)) {\n    return edges;\n  }\n  if (edge.sourceHandle === null) {\n    delete edge.sourceHandle;\n  }\n  if (edge.targetHandle === null) {\n    delete edge.targetHandle;\n  }\n  return edges.concat(edge);\n};\n/**\n * A handy utility to update an existing [`Edge`](/api-reference/types/edge) with new properties.\n *This searches your edge array for an edge with a matching `id` and updates its\n *properties with the connection you provide.\n * @public\n * @param oldEdge - The edge you want to update.\n * @param newConnection - The new connection you want to update the edge with.\n * @param edges - The array of all current edges.\n * @returns The updated edges array.\n *\n * @example\n * ```js\n *const onReconnect = useCallback(\n *  (oldEdge: Edge, newConnection: Connection) => setEdges((els) => reconnectEdge(oldEdge, newConnection, els)),[]);\n *```\n */\nconst reconnectEdge = (oldEdge, newConnection, edges, options = {\n  shouldReplaceId: true\n}) => {\n  const {\n    id: oldEdgeId,\n    ...rest\n  } = oldEdge;\n  if (!newConnection.source || !newConnection.target) {\n    devWarn('006', errorMessages['error006']());\n    return edges;\n  }\n  const foundEdge = edges.find(e => e.id === oldEdge.id);\n  if (!foundEdge) {\n    devWarn('007', errorMessages['error007'](oldEdgeId));\n    return edges;\n  }\n  // Remove old edge and create the new edge with parameters of old edge.\n  const edge = {\n    ...rest,\n    id: options.shouldReplaceId ? getEdgeId(newConnection) : oldEdgeId,\n    source: newConnection.source,\n    target: newConnection.target,\n    sourceHandle: newConnection.sourceHandle,\n    targetHandle: newConnection.targetHandle\n  };\n  return edges.filter(e => e.id !== oldEdgeId).concat(edge);\n};\n\n/**\n * Calculates the straight line path between two points.\n * @public\n * @returns A path string you can use in an SVG, the `labelX` and `labelY` position (center of path)\n * and `offsetX`, `offsetY` between source handle and label.\n *\n * - `path`: the path to use in an SVG `<path>` element.\n * - `labelX`: the `x` position you can use to render a label for this edge.\n * - `labelY`: the `y` position you can use to render a label for this edge.\n * - `offsetX`: the absolute difference between the source `x` position and the `x` position of the\n * middle of this path.\n * - `offsetY`: the absolute difference between the source `y` position and the `y` position of the\n * middle of this path.\n * @example\n * ```js\n *  const source = { x: 0, y: 20 };\n *  const target = { x: 150, y: 100 };\n *\n *  const [path, labelX, labelY, offsetX, offsetY] = getStraightPath({\n *    sourceX: source.x,\n *    sourceY: source.y,\n *    sourcePosition: Position.Right,\n *    targetX: target.x,\n *    targetY: target.y,\n *    targetPosition: Position.Left,\n *  });\n * ```\n * @remarks This function returns a tuple (aka a fixed-size array) to make it easier to work with multiple edge paths at once.\n */\nfunction getStraightPath({\n  sourceX,\n  sourceY,\n  targetX,\n  targetY\n}) {\n  const [labelX, labelY, offsetX, offsetY] = getEdgeCenter({\n    sourceX,\n    sourceY,\n    targetX,\n    targetY\n  });\n  return [`M ${sourceX},${sourceY}L ${targetX},${targetY}`, labelX, labelY, offsetX, offsetY];\n}\nconst handleDirections = {\n  [Position.Left]: {\n    x: -1,\n    y: 0\n  },\n  [Position.Right]: {\n    x: 1,\n    y: 0\n  },\n  [Position.Top]: {\n    x: 0,\n    y: -1\n  },\n  [Position.Bottom]: {\n    x: 0,\n    y: 1\n  }\n};\nconst getDirection = ({\n  source,\n  sourcePosition = Position.Bottom,\n  target\n}) => {\n  if (sourcePosition === Position.Left || sourcePosition === Position.Right) {\n    return source.x < target.x ? {\n      x: 1,\n      y: 0\n    } : {\n      x: -1,\n      y: 0\n    };\n  }\n  return source.y < target.y ? {\n    x: 0,\n    y: 1\n  } : {\n    x: 0,\n    y: -1\n  };\n};\nconst distance = (a, b) => Math.sqrt(Math.pow(b.x - a.x, 2) + Math.pow(b.y - a.y, 2));\n/*\n * With this function we try to mimic an orthogonal edge routing behaviour\n * It's not as good as a real orthogonal edge routing, but it's faster and good enough as a default for step and smooth step edges\n */\nfunction getPoints({\n  source,\n  sourcePosition = Position.Bottom,\n  target,\n  targetPosition = Position.Top,\n  center,\n  offset,\n  stepPosition\n}) {\n  const sourceDir = handleDirections[sourcePosition];\n  const targetDir = handleDirections[targetPosition];\n  const sourceGapped = {\n    x: source.x + sourceDir.x * offset,\n    y: source.y + sourceDir.y * offset\n  };\n  const targetGapped = {\n    x: target.x + targetDir.x * offset,\n    y: target.y + targetDir.y * offset\n  };\n  const dir = getDirection({\n    source: sourceGapped,\n    sourcePosition,\n    target: targetGapped\n  });\n  const dirAccessor = dir.x !== 0 ? 'x' : 'y';\n  const currDir = dir[dirAccessor];\n  let points = [];\n  let centerX, centerY;\n  const sourceGapOffset = {\n    x: 0,\n    y: 0\n  };\n  const targetGapOffset = {\n    x: 0,\n    y: 0\n  };\n  const [,, defaultOffsetX, defaultOffsetY] = getEdgeCenter({\n    sourceX: source.x,\n    sourceY: source.y,\n    targetX: target.x,\n    targetY: target.y\n  });\n  // opposite handle positions, default case\n  if (sourceDir[dirAccessor] * targetDir[dirAccessor] === -1) {\n    if (dirAccessor === 'x') {\n      // Primary direction is horizontal, so stepPosition affects X coordinate\n      centerX = center.x ?? sourceGapped.x + (targetGapped.x - sourceGapped.x) * stepPosition;\n      centerY = center.y ?? (sourceGapped.y + targetGapped.y) / 2;\n    } else {\n      // Primary direction is vertical, so stepPosition affects Y coordinate  \n      centerX = center.x ?? (sourceGapped.x + targetGapped.x) / 2;\n      centerY = center.y ?? sourceGapped.y + (targetGapped.y - sourceGapped.y) * stepPosition;\n    }\n    /*\n     *    --->\n     *    |\n     * >---\n     */\n    const verticalSplit = [{\n      x: centerX,\n      y: sourceGapped.y\n    }, {\n      x: centerX,\n      y: targetGapped.y\n    }];\n    /*\n     *    |\n     *  ---\n     *  |\n     */\n    const horizontalSplit = [{\n      x: sourceGapped.x,\n      y: centerY\n    }, {\n      x: targetGapped.x,\n      y: centerY\n    }];\n    if (sourceDir[dirAccessor] === currDir) {\n      points = dirAccessor === 'x' ? verticalSplit : horizontalSplit;\n    } else {\n      points = dirAccessor === 'x' ? horizontalSplit : verticalSplit;\n    }\n  } else {\n    // sourceTarget means we take x from source and y from target, targetSource is the opposite\n    const sourceTarget = [{\n      x: sourceGapped.x,\n      y: targetGapped.y\n    }];\n    const targetSource = [{\n      x: targetGapped.x,\n      y: sourceGapped.y\n    }];\n    // this handles edges with same handle positions\n    if (dirAccessor === 'x') {\n      points = sourceDir.x === currDir ? targetSource : sourceTarget;\n    } else {\n      points = sourceDir.y === currDir ? sourceTarget : targetSource;\n    }\n    if (sourcePosition === targetPosition) {\n      const diff = Math.abs(source[dirAccessor] - target[dirAccessor]);\n      // if an edge goes from right to right for example (sourcePosition === targetPosition) and the distance between source.x and target.x is less than the offset, the added point and the gapped source/target will overlap. This leads to a weird edge path. To avoid this we add a gapOffset to the source/target\n      if (diff <= offset) {\n        const gapOffset = Math.min(offset - 1, offset - diff);\n        if (sourceDir[dirAccessor] === currDir) {\n          sourceGapOffset[dirAccessor] = (sourceGapped[dirAccessor] > source[dirAccessor] ? -1 : 1) * gapOffset;\n        } else {\n          targetGapOffset[dirAccessor] = (targetGapped[dirAccessor] > target[dirAccessor] ? -1 : 1) * gapOffset;\n        }\n      }\n    }\n    // these are conditions for handling mixed handle positions like Right -> Bottom for example\n    if (sourcePosition !== targetPosition) {\n      const dirAccessorOpposite = dirAccessor === 'x' ? 'y' : 'x';\n      const isSameDir = sourceDir[dirAccessor] === targetDir[dirAccessorOpposite];\n      const sourceGtTargetOppo = sourceGapped[dirAccessorOpposite] > targetGapped[dirAccessorOpposite];\n      const sourceLtTargetOppo = sourceGapped[dirAccessorOpposite] < targetGapped[dirAccessorOpposite];\n      const flipSourceTarget = sourceDir[dirAccessor] === 1 && (!isSameDir && sourceGtTargetOppo || isSameDir && sourceLtTargetOppo) || sourceDir[dirAccessor] !== 1 && (!isSameDir && sourceLtTargetOppo || isSameDir && sourceGtTargetOppo);\n      if (flipSourceTarget) {\n        points = dirAccessor === 'x' ? sourceTarget : targetSource;\n      }\n    }\n    const sourceGapPoint = {\n      x: sourceGapped.x + sourceGapOffset.x,\n      y: sourceGapped.y + sourceGapOffset.y\n    };\n    const targetGapPoint = {\n      x: targetGapped.x + targetGapOffset.x,\n      y: targetGapped.y + targetGapOffset.y\n    };\n    const maxXDistance = Math.max(Math.abs(sourceGapPoint.x - points[0].x), Math.abs(targetGapPoint.x - points[0].x));\n    const maxYDistance = Math.max(Math.abs(sourceGapPoint.y - points[0].y), Math.abs(targetGapPoint.y - points[0].y));\n    // we want to place the label on the longest segment of the edge\n    if (maxXDistance >= maxYDistance) {\n      centerX = (sourceGapPoint.x + targetGapPoint.x) / 2;\n      centerY = points[0].y;\n    } else {\n      centerX = points[0].x;\n      centerY = (sourceGapPoint.y + targetGapPoint.y) / 2;\n    }\n  }\n  const pathPoints = [source, {\n    x: sourceGapped.x + sourceGapOffset.x,\n    y: sourceGapped.y + sourceGapOffset.y\n  }, ...points, {\n    x: targetGapped.x + targetGapOffset.x,\n    y: targetGapped.y + targetGapOffset.y\n  }, target];\n  return [pathPoints, centerX, centerY, defaultOffsetX, defaultOffsetY];\n}\nfunction getBend(a, b, c, size) {\n  const bendSize = Math.min(distance(a, b) / 2, distance(b, c) / 2, size);\n  const {\n    x,\n    y\n  } = b;\n  // no bend\n  if (a.x === x && x === c.x || a.y === y && y === c.y) {\n    return `L${x} ${y}`;\n  }\n  // first segment is horizontal\n  if (a.y === y) {\n    const xDir = a.x < c.x ? -1 : 1;\n    const yDir = a.y < c.y ? 1 : -1;\n    return `L ${x + bendSize * xDir},${y}Q ${x},${y} ${x},${y + bendSize * yDir}`;\n  }\n  const xDir = a.x < c.x ? 1 : -1;\n  const yDir = a.y < c.y ? -1 : 1;\n  return `L ${x},${y + bendSize * yDir}Q ${x},${y} ${x + bendSize * xDir},${y}`;\n}\n/**\n * The `getSmoothStepPath` util returns everything you need to render a stepped path\n * between two nodes. The `borderRadius` property can be used to choose how rounded\n * the corners of those steps are.\n * @public\n * @returns A path string you can use in an SVG, the `labelX` and `labelY` position (center of path)\n * and `offsetX`, `offsetY` between source handle and label.\n *\n * - `path`: the path to use in an SVG `<path>` element.\n * - `labelX`: the `x` position you can use to render a label for this edge.\n * - `labelY`: the `y` position you can use to render a label for this edge.\n * - `offsetX`: the absolute difference between the source `x` position and the `x` position of the\n * middle of this path.\n * - `offsetY`: the absolute difference between the source `y` position and the `y` position of the\n * middle of this path.\n * @example\n * ```js\n *  const source = { x: 0, y: 20 };\n *  const target = { x: 150, y: 100 };\n *\n *  const [path, labelX, labelY, offsetX, offsetY] = getSmoothStepPath({\n *    sourceX: source.x,\n *    sourceY: source.y,\n *    sourcePosition: Position.Right,\n *    targetX: target.x,\n *    targetY: target.y,\n *    targetPosition: Position.Left,\n *  });\n * ```\n * @remarks This function returns a tuple (aka a fixed-size array) to make it easier to work with multiple edge paths at once.\n */\nfunction getSmoothStepPath({\n  sourceX,\n  sourceY,\n  sourcePosition = Position.Bottom,\n  targetX,\n  targetY,\n  targetPosition = Position.Top,\n  borderRadius = 5,\n  centerX,\n  centerY,\n  offset = 20,\n  stepPosition = 0.5\n}) {\n  const [points, labelX, labelY, offsetX, offsetY] = getPoints({\n    source: {\n      x: sourceX,\n      y: sourceY\n    },\n    sourcePosition,\n    target: {\n      x: targetX,\n      y: targetY\n    },\n    targetPosition,\n    center: {\n      x: centerX,\n      y: centerY\n    },\n    offset,\n    stepPosition\n  });\n  const path = points.reduce((res, p, i) => {\n    let segment = '';\n    if (i > 0 && i < points.length - 1) {\n      segment = getBend(points[i - 1], p, points[i + 1], borderRadius);\n    } else {\n      segment = `${i === 0 ? 'M' : 'L'}${p.x} ${p.y}`;\n    }\n    res += segment;\n    return res;\n  }, '');\n  return [path, labelX, labelY, offsetX, offsetY];\n}\nfunction isNodeInitialized(node) {\n  return node && !!(node.internals.handleBounds || node.handles?.length) && !!(node.measured.width || node.width || node.initialWidth);\n}\nfunction getEdgePosition(params) {\n  const {\n    sourceNode,\n    targetNode\n  } = params;\n  if (!isNodeInitialized(sourceNode) || !isNodeInitialized(targetNode)) {\n    return null;\n  }\n  const sourceHandleBounds = sourceNode.internals.handleBounds || toHandleBounds(sourceNode.handles);\n  const targetHandleBounds = targetNode.internals.handleBounds || toHandleBounds(targetNode.handles);\n  const sourceHandle = getHandle$1(sourceHandleBounds?.source ?? [], params.sourceHandle);\n  const targetHandle = getHandle$1(\n  // when connection type is loose we can define all handles as sources and connect source -> source\n  params.connectionMode === ConnectionMode.Strict ? targetHandleBounds?.target ?? [] : (targetHandleBounds?.target ?? []).concat(targetHandleBounds?.source ?? []), params.targetHandle);\n  if (!sourceHandle || !targetHandle) {\n    params.onError?.('008', errorMessages['error008'](!sourceHandle ? 'source' : 'target', {\n      id: params.id,\n      sourceHandle: params.sourceHandle,\n      targetHandle: params.targetHandle\n    }));\n    return null;\n  }\n  const sourcePosition = sourceHandle?.position || Position.Bottom;\n  const targetPosition = targetHandle?.position || Position.Top;\n  const source = getHandlePosition(sourceNode, sourceHandle, sourcePosition);\n  const target = getHandlePosition(targetNode, targetHandle, targetPosition);\n  return {\n    sourceX: source.x,\n    sourceY: source.y,\n    targetX: target.x,\n    targetY: target.y,\n    sourcePosition,\n    targetPosition\n  };\n}\nfunction toHandleBounds(handles) {\n  if (!handles) {\n    return null;\n  }\n  const source = [];\n  const target = [];\n  for (const handle of handles) {\n    handle.width = handle.width ?? 1;\n    handle.height = handle.height ?? 1;\n    if (handle.type === 'source') {\n      source.push(handle);\n    } else if (handle.type === 'target') {\n      target.push(handle);\n    }\n  }\n  return {\n    source,\n    target\n  };\n}\nfunction getHandlePosition(node, handle, fallbackPosition = Position.Left, center = false) {\n  const x = (handle?.x ?? 0) + node.internals.positionAbsolute.x;\n  const y = (handle?.y ?? 0) + node.internals.positionAbsolute.y;\n  const {\n    width,\n    height\n  } = handle ?? getNodeDimensions(node);\n  if (center) {\n    return {\n      x: x + width / 2,\n      y: y + height / 2\n    };\n  }\n  const position = handle?.position ?? fallbackPosition;\n  switch (position) {\n    case Position.Top:\n      return {\n        x: x + width / 2,\n        y\n      };\n    case Position.Right:\n      return {\n        x: x + width,\n        y: y + height / 2\n      };\n    case Position.Bottom:\n      return {\n        x: x + width / 2,\n        y: y + height\n      };\n    case Position.Left:\n      return {\n        x,\n        y: y + height / 2\n      };\n  }\n}\nfunction getHandle$1(bounds, handleId) {\n  if (!bounds) {\n    return null;\n  }\n  // if no handleId is given, we use the first handle, otherwise we check for the id\n  return (!handleId ? bounds[0] : bounds.find(d => d.id === handleId)) || null;\n}\nfunction getMarkerId(marker, id) {\n  if (!marker) {\n    return '';\n  }\n  if (typeof marker === 'string') {\n    return marker;\n  }\n  const idPrefix = id ? `${id}__` : '';\n  return `${idPrefix}${Object.keys(marker).sort().map(key => `${key}=${marker[key]}`).join('&')}`;\n}\nfunction createMarkerIds(edges, {\n  id,\n  defaultColor,\n  defaultMarkerStart,\n  defaultMarkerEnd\n}) {\n  const ids = new Set();\n  return edges.reduce((markers, edge) => {\n    [edge.markerStart || defaultMarkerStart, edge.markerEnd || defaultMarkerEnd].forEach(marker => {\n      if (marker && typeof marker === 'object') {\n        const markerId = getMarkerId(marker, id);\n        if (!ids.has(markerId)) {\n          markers.push({\n            id: markerId,\n            color: marker.color || defaultColor,\n            ...marker\n          });\n          ids.add(markerId);\n        }\n      }\n    });\n    return markers;\n  }, []).sort((a, b) => a.id.localeCompare(b.id));\n}\nfunction getNodeToolbarTransform(nodeRect, viewport, position, offset, align) {\n  let alignmentOffset = 0.5;\n  if (align === 'start') {\n    alignmentOffset = 0;\n  } else if (align === 'end') {\n    alignmentOffset = 1;\n  }\n  /*\n   * position === Position.Top\n   * we set the x any y position of the toolbar based on the nodes position\n   */\n  let pos = [(nodeRect.x + nodeRect.width * alignmentOffset) * viewport.zoom + viewport.x, nodeRect.y * viewport.zoom + viewport.y - offset];\n  // and than shift it based on the alignment. The shift values are in %.\n  let shift = [-100 * alignmentOffset, -100];\n  switch (position) {\n    case Position.Right:\n      pos = [(nodeRect.x + nodeRect.width) * viewport.zoom + viewport.x + offset, (nodeRect.y + nodeRect.height * alignmentOffset) * viewport.zoom + viewport.y];\n      shift = [0, -100 * alignmentOffset];\n      break;\n    case Position.Bottom:\n      pos[1] = (nodeRect.y + nodeRect.height) * viewport.zoom + viewport.y + offset;\n      shift[1] = 0;\n      break;\n    case Position.Left:\n      pos = [nodeRect.x * viewport.zoom + viewport.x - offset, (nodeRect.y + nodeRect.height * alignmentOffset) * viewport.zoom + viewport.y];\n      shift = [-100, -100 * alignmentOffset];\n      break;\n  }\n  return `translate(${pos[0]}px, ${pos[1]}px) translate(${shift[0]}%, ${shift[1]}%)`;\n}\nconst defaultOptions = {\n  nodeOrigin: [0, 0],\n  nodeExtent: infiniteExtent,\n  elevateNodesOnSelect: true,\n  defaults: {}\n};\nconst adoptUserNodesDefaultOptions = {\n  ...defaultOptions,\n  checkEquality: true\n};\nfunction mergeObjects(base, incoming) {\n  const result = {\n    ...base\n  };\n  for (const key in incoming) {\n    if (incoming[key] !== undefined) {\n      // typecast is safe here, because we check for undefined\n      result[key] = incoming[key];\n    }\n  }\n  return result;\n}\nfunction updateAbsolutePositions(nodeLookup, parentLookup, options) {\n  const _options = mergeObjects(defaultOptions, options);\n  for (const node of nodeLookup.values()) {\n    if (node.parentId) {\n      updateChildNode(node, nodeLookup, parentLookup, _options);\n    } else {\n      const positionWithOrigin = getNodePositionWithOrigin(node, _options.nodeOrigin);\n      const extent = isCoordinateExtent(node.extent) ? node.extent : _options.nodeExtent;\n      const clampedPosition = clampPosition(positionWithOrigin, extent, getNodeDimensions(node));\n      node.internals.positionAbsolute = clampedPosition;\n    }\n  }\n}\nfunction adoptUserNodes(nodes, nodeLookup, parentLookup, options) {\n  const _options = mergeObjects(adoptUserNodesDefaultOptions, options);\n  let nodesInitialized = nodes.length > 0;\n  const tmpLookup = new Map(nodeLookup);\n  const selectedNodeZ = _options?.elevateNodesOnSelect ? 1000 : 0;\n  nodeLookup.clear();\n  parentLookup.clear();\n  for (const userNode of nodes) {\n    let internalNode = tmpLookup.get(userNode.id);\n    if (_options.checkEquality && userNode === internalNode?.internals.userNode) {\n      nodeLookup.set(userNode.id, internalNode);\n    } else {\n      const positionWithOrigin = getNodePositionWithOrigin(userNode, _options.nodeOrigin);\n      const extent = isCoordinateExtent(userNode.extent) ? userNode.extent : _options.nodeExtent;\n      const clampedPosition = clampPosition(positionWithOrigin, extent, getNodeDimensions(userNode));\n      internalNode = {\n        ..._options.defaults,\n        ...userNode,\n        measured: {\n          width: userNode.measured?.width,\n          height: userNode.measured?.height\n        },\n        internals: {\n          positionAbsolute: clampedPosition,\n          // if user re-initializes the node or removes `measured` for whatever reason, we reset the handleBounds so that the node gets re-measured\n          handleBounds: !userNode.measured ? undefined : internalNode?.internals.handleBounds,\n          z: calculateZ(userNode, selectedNodeZ),\n          userNode\n        }\n      };\n      nodeLookup.set(userNode.id, internalNode);\n    }\n    if ((internalNode.measured === undefined || internalNode.measured.width === undefined || internalNode.measured.height === undefined) && !internalNode.hidden) {\n      nodesInitialized = false;\n    }\n    if (userNode.parentId) {\n      updateChildNode(internalNode, nodeLookup, parentLookup, options);\n    }\n  }\n  return nodesInitialized;\n}\nfunction updateParentLookup(node, parentLookup) {\n  if (!node.parentId) {\n    return;\n  }\n  const childNodes = parentLookup.get(node.parentId);\n  if (childNodes) {\n    childNodes.set(node.id, node);\n  } else {\n    parentLookup.set(node.parentId, new Map([[node.id, node]]));\n  }\n}\n/**\n * Updates positionAbsolute and zIndex of a child node and the parentLookup.\n */\nfunction updateChildNode(node, nodeLookup, parentLookup, options) {\n  const {\n    elevateNodesOnSelect,\n    nodeOrigin,\n    nodeExtent\n  } = mergeObjects(defaultOptions, options);\n  const parentId = node.parentId;\n  const parentNode = nodeLookup.get(parentId);\n  if (!parentNode) {\n    console.warn(`Parent node ${parentId} not found. Please make sure that parent nodes are in front of their child nodes in the nodes array.`);\n    return;\n  }\n  updateParentLookup(node, parentLookup);\n  const selectedNodeZ = elevateNodesOnSelect ? 1000 : 0;\n  const {\n    x,\n    y,\n    z\n  } = calculateChildXYZ(node, parentNode, nodeOrigin, nodeExtent, selectedNodeZ);\n  const {\n    positionAbsolute\n  } = node.internals;\n  const positionChanged = x !== positionAbsolute.x || y !== positionAbsolute.y;\n  if (positionChanged || z !== node.internals.z) {\n    // we create a new object to mark the node as updated\n    nodeLookup.set(node.id, {\n      ...node,\n      internals: {\n        ...node.internals,\n        positionAbsolute: positionChanged ? {\n          x,\n          y\n        } : positionAbsolute,\n        z\n      }\n    });\n  }\n}\nfunction calculateZ(node, selectedNodeZ) {\n  return (isNumeric(node.zIndex) ? node.zIndex : 0) + (node.selected ? selectedNodeZ : 0);\n}\nfunction calculateChildXYZ(childNode, parentNode, nodeOrigin, nodeExtent, selectedNodeZ) {\n  const {\n    x: parentX,\n    y: parentY\n  } = parentNode.internals.positionAbsolute;\n  const childDimensions = getNodeDimensions(childNode);\n  const positionWithOrigin = getNodePositionWithOrigin(childNode, nodeOrigin);\n  const clampedPosition = isCoordinateExtent(childNode.extent) ? clampPosition(positionWithOrigin, childNode.extent, childDimensions) : positionWithOrigin;\n  let absolutePosition = clampPosition({\n    x: parentX + clampedPosition.x,\n    y: parentY + clampedPosition.y\n  }, nodeExtent, childDimensions);\n  if (childNode.extent === 'parent') {\n    absolutePosition = clampPositionToParent(absolutePosition, childDimensions, parentNode);\n  }\n  const childZ = calculateZ(childNode, selectedNodeZ);\n  const parentZ = parentNode.internals.z ?? 0;\n  return {\n    x: absolutePosition.x,\n    y: absolutePosition.y,\n    z: parentZ >= childZ ? parentZ + 1 : childZ\n  };\n}\nfunction handleExpandParent(children, nodeLookup, parentLookup, nodeOrigin = [0, 0]) {\n  const changes = [];\n  const parentExpansions = new Map();\n  // determine the expanded rectangle the child nodes would take for each parent\n  for (const child of children) {\n    const parent = nodeLookup.get(child.parentId);\n    if (!parent) {\n      continue;\n    }\n    const parentRect = parentExpansions.get(child.parentId)?.expandedRect ?? nodeToRect(parent);\n    const expandedRect = getBoundsOfRects(parentRect, child.rect);\n    parentExpansions.set(child.parentId, {\n      expandedRect,\n      parent\n    });\n  }\n  if (parentExpansions.size > 0) {\n    parentExpansions.forEach(({\n      expandedRect,\n      parent\n    }, parentId) => {\n      // determine the position & dimensions of the parent\n      const positionAbsolute = parent.internals.positionAbsolute;\n      const dimensions = getNodeDimensions(parent);\n      const origin = parent.origin ?? nodeOrigin;\n      // determine how much the parent expands in width and position\n      const xChange = expandedRect.x < positionAbsolute.x ? Math.round(Math.abs(positionAbsolute.x - expandedRect.x)) : 0;\n      const yChange = expandedRect.y < positionAbsolute.y ? Math.round(Math.abs(positionAbsolute.y - expandedRect.y)) : 0;\n      const newWidth = Math.max(dimensions.width, Math.round(expandedRect.width));\n      const newHeight = Math.max(dimensions.height, Math.round(expandedRect.height));\n      const widthChange = (newWidth - dimensions.width) * origin[0];\n      const heightChange = (newHeight - dimensions.height) * origin[1];\n      // We need to correct the position of the parent node if the origin is not [0,0]\n      if (xChange > 0 || yChange > 0 || widthChange || heightChange) {\n        changes.push({\n          id: parentId,\n          type: 'position',\n          position: {\n            x: parent.position.x - xChange + widthChange,\n            y: parent.position.y - yChange + heightChange\n          }\n        });\n        /*\n         * We move all child nodes in the oppsite direction\n         * so the x,y changes of the parent do not move the children\n         */\n        parentLookup.get(parentId)?.forEach(childNode => {\n          if (!children.some(child => child.id === childNode.id)) {\n            changes.push({\n              id: childNode.id,\n              type: 'position',\n              position: {\n                x: childNode.position.x + xChange,\n                y: childNode.position.y + yChange\n              }\n            });\n          }\n        });\n      }\n      // We need to correct the dimensions of the parent node if the origin is not [0,0]\n      if (dimensions.width < expandedRect.width || dimensions.height < expandedRect.height || xChange || yChange) {\n        changes.push({\n          id: parentId,\n          type: 'dimensions',\n          setAttributes: true,\n          dimensions: {\n            width: newWidth + (xChange ? origin[0] * xChange - widthChange : 0),\n            height: newHeight + (yChange ? origin[1] * yChange - heightChange : 0)\n          }\n        });\n      }\n    });\n  }\n  return changes;\n}\nfunction updateNodeInternals(updates, nodeLookup, parentLookup, domNode, nodeOrigin, nodeExtent) {\n  const viewportNode = domNode?.querySelector('.xyflow__viewport');\n  let updatedInternals = false;\n  if (!viewportNode) {\n    return {\n      changes: [],\n      updatedInternals\n    };\n  }\n  const changes = [];\n  const style = window.getComputedStyle(viewportNode);\n  const {\n    m22: zoom\n  } = new window.DOMMatrixReadOnly(style.transform);\n  // in this array we collect nodes, that might trigger changes (like expanding parent)\n  const parentExpandChildren = [];\n  for (const update of updates.values()) {\n    const node = nodeLookup.get(update.id);\n    if (!node) {\n      continue;\n    }\n    if (node.hidden) {\n      nodeLookup.set(node.id, {\n        ...node,\n        internals: {\n          ...node.internals,\n          handleBounds: undefined\n        }\n      });\n      updatedInternals = true;\n      continue;\n    }\n    const dimensions = getDimensions(update.nodeElement);\n    const dimensionChanged = node.measured.width !== dimensions.width || node.measured.height !== dimensions.height;\n    const doUpdate = !!(dimensions.width && dimensions.height && (dimensionChanged || !node.internals.handleBounds || update.force));\n    if (doUpdate) {\n      const nodeBounds = update.nodeElement.getBoundingClientRect();\n      const extent = isCoordinateExtent(node.extent) ? node.extent : nodeExtent;\n      let {\n        positionAbsolute\n      } = node.internals;\n      if (node.parentId && node.extent === 'parent') {\n        positionAbsolute = clampPositionToParent(positionAbsolute, dimensions, nodeLookup.get(node.parentId));\n      } else if (extent) {\n        positionAbsolute = clampPosition(positionAbsolute, extent, dimensions);\n      }\n      const newNode = {\n        ...node,\n        measured: dimensions,\n        internals: {\n          ...node.internals,\n          positionAbsolute,\n          handleBounds: {\n            source: getHandleBounds('source', update.nodeElement, nodeBounds, zoom, node.id),\n            target: getHandleBounds('target', update.nodeElement, nodeBounds, zoom, node.id)\n          }\n        }\n      };\n      nodeLookup.set(node.id, newNode);\n      if (node.parentId) {\n        updateChildNode(newNode, nodeLookup, parentLookup, {\n          nodeOrigin\n        });\n      }\n      updatedInternals = true;\n      if (dimensionChanged) {\n        changes.push({\n          id: node.id,\n          type: 'dimensions',\n          dimensions\n        });\n        if (node.expandParent && node.parentId) {\n          parentExpandChildren.push({\n            id: node.id,\n            parentId: node.parentId,\n            rect: nodeToRect(newNode, nodeOrigin)\n          });\n        }\n      }\n    }\n  }\n  if (parentExpandChildren.length > 0) {\n    const parentExpandChanges = handleExpandParent(parentExpandChildren, nodeLookup, parentLookup, nodeOrigin);\n    changes.push(...parentExpandChanges);\n  }\n  return {\n    changes,\n    updatedInternals\n  };\n}\nasync function panBy({\n  delta,\n  panZoom,\n  transform,\n  translateExtent,\n  width,\n  height\n}) {\n  if (!panZoom || !delta.x && !delta.y) {\n    return Promise.resolve(false);\n  }\n  const nextViewport = await panZoom.setViewportConstrained({\n    x: transform[0] + delta.x,\n    y: transform[1] + delta.y,\n    zoom: transform[2]\n  }, [[0, 0], [width, height]], translateExtent);\n  const transformChanged = !!nextViewport && (nextViewport.x !== transform[0] || nextViewport.y !== transform[1] || nextViewport.k !== transform[2]);\n  return Promise.resolve(transformChanged);\n}\n/**\n * this function adds the connection to the connectionLookup\n * at the following keys: nodeId-type-handleId, nodeId-type and nodeId\n * @param type type of the connection\n * @param connection connection that should be added to the lookup\n * @param connectionKey at which key the connection should be added\n * @param connectionLookup reference to the connection lookup\n * @param nodeId nodeId of the connection\n * @param handleId handleId of the conneciton\n */\nfunction addConnectionToLookup(type, connection, connectionKey, connectionLookup, nodeId, handleId) {\n  /*\n   * We add the connection to the connectionLookup at the following keys\n   * 1. nodeId, 2. nodeId-type, 3. nodeId-type-handleId\n   * If the key already exists, we add the connection to the existing map\n   */\n  let key = nodeId;\n  const nodeMap = connectionLookup.get(key) || new Map();\n  connectionLookup.set(key, nodeMap.set(connectionKey, connection));\n  key = `${nodeId}-${type}`;\n  const typeMap = connectionLookup.get(key) || new Map();\n  connectionLookup.set(key, typeMap.set(connectionKey, connection));\n  if (handleId) {\n    key = `${nodeId}-${type}-${handleId}`;\n    const handleMap = connectionLookup.get(key) || new Map();\n    connectionLookup.set(key, handleMap.set(connectionKey, connection));\n  }\n}\nfunction updateConnectionLookup(connectionLookup, edgeLookup, edges) {\n  connectionLookup.clear();\n  edgeLookup.clear();\n  for (const edge of edges) {\n    const {\n      source: sourceNode,\n      target: targetNode,\n      sourceHandle = null,\n      targetHandle = null\n    } = edge;\n    const connection = {\n      edgeId: edge.id,\n      source: sourceNode,\n      target: targetNode,\n      sourceHandle,\n      targetHandle\n    };\n    const sourceKey = `${sourceNode}-${sourceHandle}--${targetNode}-${targetHandle}`;\n    const targetKey = `${targetNode}-${targetHandle}--${sourceNode}-${sourceHandle}`;\n    addConnectionToLookup('source', connection, targetKey, connectionLookup, sourceNode, sourceHandle);\n    addConnectionToLookup('target', connection, sourceKey, connectionLookup, targetNode, targetHandle);\n    edgeLookup.set(edge.id, edge);\n  }\n}\nfunction shallowNodeData(a, b) {\n  if (a === null || b === null) {\n    return false;\n  }\n  const _a = Array.isArray(a) ? a : [a];\n  const _b = Array.isArray(b) ? b : [b];\n  if (_a.length !== _b.length) {\n    return false;\n  }\n  for (let i = 0; i < _a.length; i++) {\n    if (_a[i].id !== _b[i].id || _a[i].type !== _b[i].type || !Object.is(_a[i].data, _b[i].data)) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction isParentSelected(node, nodeLookup) {\n  if (!node.parentId) {\n    return false;\n  }\n  const parentNode = nodeLookup.get(node.parentId);\n  if (!parentNode) {\n    return false;\n  }\n  if (parentNode.selected) {\n    return true;\n  }\n  return isParentSelected(parentNode, nodeLookup);\n}\nfunction hasSelector(target, selector, domNode) {\n  let current = target;\n  do {\n    if (current?.matches?.(selector)) return true;\n    if (current === domNode) return false;\n    current = current?.parentElement;\n  } while (current);\n  return false;\n}\n// looks for all selected nodes and created a NodeDragItem for each of them\nfunction getDragItems(nodeLookup, nodesDraggable, mousePos, nodeId) {\n  const dragItems = new Map();\n  for (const [id, node] of nodeLookup) {\n    if ((node.selected || node.id === nodeId) && (!node.parentId || !isParentSelected(node, nodeLookup)) && (node.draggable || nodesDraggable && typeof node.draggable === 'undefined')) {\n      const internalNode = nodeLookup.get(id);\n      if (internalNode) {\n        dragItems.set(id, {\n          id,\n          position: internalNode.position || {\n            x: 0,\n            y: 0\n          },\n          distance: {\n            x: mousePos.x - internalNode.internals.positionAbsolute.x,\n            y: mousePos.y - internalNode.internals.positionAbsolute.y\n          },\n          extent: internalNode.extent,\n          parentId: internalNode.parentId,\n          origin: internalNode.origin,\n          expandParent: internalNode.expandParent,\n          internals: {\n            positionAbsolute: internalNode.internals.positionAbsolute || {\n              x: 0,\n              y: 0\n            }\n          },\n          measured: {\n            width: internalNode.measured.width ?? 0,\n            height: internalNode.measured.height ?? 0\n          }\n        });\n      }\n    }\n  }\n  return dragItems;\n}\n/*\n * returns two params:\n * 1. the dragged node (or the first of the list, if we are dragging a node selection)\n * 2. array of selected nodes (for multi selections)\n */\nfunction getEventHandlerParams({\n  nodeId,\n  dragItems,\n  nodeLookup,\n  dragging = true\n}) {\n  const nodesFromDragItems = [];\n  for (const [id, dragItem] of dragItems) {\n    const node = nodeLookup.get(id)?.internals.userNode;\n    if (node) {\n      nodesFromDragItems.push({\n        ...node,\n        position: dragItem.position,\n        dragging\n      });\n    }\n  }\n  if (!nodeId) {\n    return [nodesFromDragItems[0], nodesFromDragItems];\n  }\n  const node = nodeLookup.get(nodeId)?.internals.userNode;\n  return [!node ? nodesFromDragItems[0] : {\n    ...node,\n    position: dragItems.get(nodeId)?.position || node.position,\n    dragging\n  }, nodesFromDragItems];\n}\n/**\n * If a selection is being dragged we want to apply the same snap offset to all nodes in the selection.\n * This function calculates the snap offset based on the first node in the selection.\n */\nfunction calculateSnapOffset({\n  dragItems,\n  snapGrid,\n  x,\n  y\n}) {\n  const refDragItem = dragItems.values().next().value;\n  if (!refDragItem) {\n    return null;\n  }\n  const refPos = {\n    x: x - refDragItem.distance.x,\n    y: y - refDragItem.distance.y\n  };\n  const refPosSnapped = snapPosition(refPos, snapGrid);\n  return {\n    x: refPosSnapped.x - refPos.x,\n    y: refPosSnapped.y - refPos.y\n  };\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction XYDrag({\n  onNodeMouseDown,\n  getStoreItems,\n  onDragStart,\n  onDrag,\n  onDragStop\n}) {\n  let lastPos = {\n    x: null,\n    y: null\n  };\n  let autoPanId = 0;\n  let dragItems = new Map();\n  let autoPanStarted = false;\n  let mousePosition = {\n    x: 0,\n    y: 0\n  };\n  let containerBounds = null;\n  let dragStarted = false;\n  let d3Selection = null;\n  let abortDrag = false; // prevents unintentional dragging on multitouch\n  let nodePositionsChanged = false;\n  // we store the last drag event to be able to use it in the update function\n  let dragEvent = null;\n  // public functions\n  function update({\n    noDragClassName,\n    handleSelector,\n    domNode,\n    isSelectable,\n    nodeId,\n    nodeClickDistance = 0\n  }) {\n    d3Selection = select(domNode);\n    function updateNodes({\n      x,\n      y\n    }) {\n      const {\n        nodeLookup,\n        nodeExtent,\n        snapGrid,\n        snapToGrid,\n        nodeOrigin,\n        onNodeDrag,\n        onSelectionDrag,\n        onError,\n        updateNodePositions\n      } = getStoreItems();\n      lastPos = {\n        x,\n        y\n      };\n      let hasChange = false;\n      const isMultiDrag = dragItems.size > 1;\n      const nodesBox = isMultiDrag && nodeExtent ? rectToBox(getInternalNodesBounds(dragItems)) : null;\n      const multiDragSnapOffset = isMultiDrag && snapToGrid ? calculateSnapOffset({\n        dragItems,\n        snapGrid,\n        x,\n        y\n      }) : null;\n      for (const [id, dragItem] of dragItems) {\n        /*\n         * if the node is not in the nodeLookup anymore, it was probably deleted while dragging\n         */\n        if (!nodeLookup.has(id)) {\n          continue;\n        }\n        let nextPosition = {\n          x: x - dragItem.distance.x,\n          y: y - dragItem.distance.y\n        };\n        if (snapToGrid) {\n          nextPosition = multiDragSnapOffset ? {\n            x: Math.round(nextPosition.x + multiDragSnapOffset.x),\n            y: Math.round(nextPosition.y + multiDragSnapOffset.y)\n          } : snapPosition(nextPosition, snapGrid);\n        }\n        let adjustedNodeExtent = null;\n        if (isMultiDrag && nodeExtent && !dragItem.extent && nodesBox) {\n          const {\n            positionAbsolute\n          } = dragItem.internals;\n          const x1 = positionAbsolute.x - nodesBox.x + nodeExtent[0][0];\n          const x2 = positionAbsolute.x + dragItem.measured.width - nodesBox.x2 + nodeExtent[1][0];\n          const y1 = positionAbsolute.y - nodesBox.y + nodeExtent[0][1];\n          const y2 = positionAbsolute.y + dragItem.measured.height - nodesBox.y2 + nodeExtent[1][1];\n          adjustedNodeExtent = [[x1, y1], [x2, y2]];\n        }\n        const {\n          position,\n          positionAbsolute\n        } = calculateNodePosition({\n          nodeId: id,\n          nextPosition,\n          nodeLookup,\n          nodeExtent: adjustedNodeExtent ? adjustedNodeExtent : nodeExtent,\n          nodeOrigin,\n          onError\n        });\n        // we want to make sure that we only fire a change event when there is a change\n        hasChange = hasChange || dragItem.position.x !== position.x || dragItem.position.y !== position.y;\n        dragItem.position = position;\n        dragItem.internals.positionAbsolute = positionAbsolute;\n      }\n      nodePositionsChanged = nodePositionsChanged || hasChange;\n      if (!hasChange) {\n        return;\n      }\n      updateNodePositions(dragItems, true);\n      if (dragEvent && (onDrag || onNodeDrag || !nodeId && onSelectionDrag)) {\n        const [currentNode, currentNodes] = getEventHandlerParams({\n          nodeId,\n          dragItems,\n          nodeLookup\n        });\n        onDrag?.(dragEvent, dragItems, currentNode, currentNodes);\n        onNodeDrag?.(dragEvent, currentNode, currentNodes);\n        if (!nodeId) {\n          onSelectionDrag?.(dragEvent, currentNodes);\n        }\n      }\n    }\n    async function autoPan() {\n      if (!containerBounds) {\n        return;\n      }\n      const {\n        transform,\n        panBy,\n        autoPanSpeed,\n        autoPanOnNodeDrag\n      } = getStoreItems();\n      if (!autoPanOnNodeDrag) {\n        autoPanStarted = false;\n        cancelAnimationFrame(autoPanId);\n        return;\n      }\n      const [xMovement, yMovement] = calcAutoPan(mousePosition, containerBounds, autoPanSpeed);\n      if (xMovement !== 0 || yMovement !== 0) {\n        lastPos.x = (lastPos.x ?? 0) - xMovement / transform[2];\n        lastPos.y = (lastPos.y ?? 0) - yMovement / transform[2];\n        if (await panBy({\n          x: xMovement,\n          y: yMovement\n        })) {\n          updateNodes(lastPos);\n        }\n      }\n      autoPanId = requestAnimationFrame(autoPan);\n    }\n    function startDrag(event) {\n      const {\n        nodeLookup,\n        multiSelectionActive,\n        nodesDraggable,\n        transform,\n        snapGrid,\n        snapToGrid,\n        selectNodesOnDrag,\n        onNodeDragStart,\n        onSelectionDragStart,\n        unselectNodesAndEdges\n      } = getStoreItems();\n      dragStarted = true;\n      if ((!selectNodesOnDrag || !isSelectable) && !multiSelectionActive && nodeId) {\n        if (!nodeLookup.get(nodeId)?.selected) {\n          // we need to reset selected nodes when selectNodesOnDrag=false\n          unselectNodesAndEdges();\n        }\n      }\n      if (isSelectable && selectNodesOnDrag && nodeId) {\n        onNodeMouseDown?.(nodeId);\n      }\n      const pointerPos = getPointerPosition(event.sourceEvent, {\n        transform,\n        snapGrid,\n        snapToGrid,\n        containerBounds\n      });\n      lastPos = pointerPos;\n      dragItems = getDragItems(nodeLookup, nodesDraggable, pointerPos, nodeId);\n      if (dragItems.size > 0 && (onDragStart || onNodeDragStart || !nodeId && onSelectionDragStart)) {\n        const [currentNode, currentNodes] = getEventHandlerParams({\n          nodeId,\n          dragItems,\n          nodeLookup\n        });\n        onDragStart?.(event.sourceEvent, dragItems, currentNode, currentNodes);\n        onNodeDragStart?.(event.sourceEvent, currentNode, currentNodes);\n        if (!nodeId) {\n          onSelectionDragStart?.(event.sourceEvent, currentNodes);\n        }\n      }\n    }\n    const d3DragInstance = drag().clickDistance(nodeClickDistance).on('start', event => {\n      const {\n        domNode,\n        nodeDragThreshold,\n        transform,\n        snapGrid,\n        snapToGrid\n      } = getStoreItems();\n      containerBounds = domNode?.getBoundingClientRect() || null;\n      abortDrag = false;\n      nodePositionsChanged = false;\n      dragEvent = event.sourceEvent;\n      if (nodeDragThreshold === 0) {\n        startDrag(event);\n      }\n      const pointerPos = getPointerPosition(event.sourceEvent, {\n        transform,\n        snapGrid,\n        snapToGrid,\n        containerBounds\n      });\n      lastPos = pointerPos;\n      mousePosition = getEventPosition(event.sourceEvent, containerBounds);\n    }).on('drag', event => {\n      const {\n        autoPanOnNodeDrag,\n        transform,\n        snapGrid,\n        snapToGrid,\n        nodeDragThreshold,\n        nodeLookup\n      } = getStoreItems();\n      const pointerPos = getPointerPosition(event.sourceEvent, {\n        transform,\n        snapGrid,\n        snapToGrid,\n        containerBounds\n      });\n      dragEvent = event.sourceEvent;\n      if (event.sourceEvent.type === 'touchmove' && event.sourceEvent.touches.length > 1 ||\n      // if user deletes a node while dragging, we need to abort the drag to prevent errors\n      nodeId && !nodeLookup.has(nodeId)) {\n        abortDrag = true;\n      }\n      if (abortDrag) {\n        return;\n      }\n      if (!autoPanStarted && autoPanOnNodeDrag && dragStarted) {\n        autoPanStarted = true;\n        autoPan();\n      }\n      if (!dragStarted) {\n        const x = pointerPos.xSnapped - (lastPos.x ?? 0);\n        const y = pointerPos.ySnapped - (lastPos.y ?? 0);\n        const distance = Math.sqrt(x * x + y * y);\n        if (distance > nodeDragThreshold) {\n          startDrag(event);\n        }\n      }\n      // skip events without movement\n      if ((lastPos.x !== pointerPos.xSnapped || lastPos.y !== pointerPos.ySnapped) && dragItems && dragStarted) {\n        mousePosition = getEventPosition(event.sourceEvent, containerBounds);\n        updateNodes(pointerPos);\n      }\n    }).on('end', event => {\n      if (!dragStarted || abortDrag) {\n        return;\n      }\n      autoPanStarted = false;\n      dragStarted = false;\n      cancelAnimationFrame(autoPanId);\n      if (dragItems.size > 0) {\n        const {\n          nodeLookup,\n          updateNodePositions,\n          onNodeDragStop,\n          onSelectionDragStop\n        } = getStoreItems();\n        if (nodePositionsChanged) {\n          updateNodePositions(dragItems, false);\n          nodePositionsChanged = false;\n        }\n        if (onDragStop || onNodeDragStop || !nodeId && onSelectionDragStop) {\n          const [currentNode, currentNodes] = getEventHandlerParams({\n            nodeId,\n            dragItems,\n            nodeLookup,\n            dragging: false\n          });\n          onDragStop?.(event.sourceEvent, dragItems, currentNode, currentNodes);\n          onNodeDragStop?.(event.sourceEvent, currentNode, currentNodes);\n          if (!nodeId) {\n            onSelectionDragStop?.(event.sourceEvent, currentNodes);\n          }\n        }\n      }\n    }).filter(event => {\n      const target = event.target;\n      const isDraggable = !event.button && (!noDragClassName || !hasSelector(target, `.${noDragClassName}`, domNode)) && (!handleSelector || hasSelector(target, handleSelector, domNode));\n      return isDraggable;\n    });\n    d3Selection.call(d3DragInstance);\n  }\n  function destroy() {\n    d3Selection?.on('.drag', null);\n  }\n  return {\n    update,\n    destroy\n  };\n}\nfunction getNodesWithinDistance(position, nodeLookup, distance) {\n  const nodes = [];\n  const rect = {\n    x: position.x - distance,\n    y: position.y - distance,\n    width: distance * 2,\n    height: distance * 2\n  };\n  for (const node of nodeLookup.values()) {\n    if (getOverlappingArea(rect, nodeToRect(node)) > 0) {\n      nodes.push(node);\n    }\n  }\n  return nodes;\n}\n/*\n * this distance is used for the area around the user pointer\n * while doing a connection for finding the closest nodes\n */\nconst ADDITIONAL_DISTANCE = 250;\nfunction getClosestHandle(position, connectionRadius, nodeLookup, fromHandle) {\n  let closestHandles = [];\n  let minDistance = Infinity;\n  const closeNodes = getNodesWithinDistance(position, nodeLookup, connectionRadius + ADDITIONAL_DISTANCE);\n  for (const node of closeNodes) {\n    const allHandles = [...(node.internals.handleBounds?.source ?? []), ...(node.internals.handleBounds?.target ?? [])];\n    for (const handle of allHandles) {\n      // if the handle is the same as the fromHandle we skip it\n      if (fromHandle.nodeId === handle.nodeId && fromHandle.type === handle.type && fromHandle.id === handle.id) {\n        continue;\n      }\n      // determine absolute position of the handle\n      const {\n        x,\n        y\n      } = getHandlePosition(node, handle, handle.position, true);\n      const distance = Math.sqrt(Math.pow(x - position.x, 2) + Math.pow(y - position.y, 2));\n      if (distance > connectionRadius) {\n        continue;\n      }\n      if (distance < minDistance) {\n        closestHandles = [{\n          ...handle,\n          x,\n          y\n        }];\n        minDistance = distance;\n      } else if (distance === minDistance) {\n        // when multiple handles are on the same distance we collect all of them\n        closestHandles.push({\n          ...handle,\n          x,\n          y\n        });\n      }\n    }\n  }\n  if (!closestHandles.length) {\n    return null;\n  }\n  // when multiple handles overlay each other we prefer the opposite handle\n  if (closestHandles.length > 1) {\n    const oppositeHandleType = fromHandle.type === 'source' ? 'target' : 'source';\n    return closestHandles.find(handle => handle.type === oppositeHandleType) ?? closestHandles[0];\n  }\n  return closestHandles[0];\n}\nfunction getHandle(nodeId, handleType, handleId, nodeLookup, connectionMode, withAbsolutePosition = false) {\n  const node = nodeLookup.get(nodeId);\n  if (!node) {\n    return null;\n  }\n  const handles = connectionMode === 'strict' ? node.internals.handleBounds?.[handleType] : [...(node.internals.handleBounds?.source ?? []), ...(node.internals.handleBounds?.target ?? [])];\n  const handle = (handleId ? handles?.find(h => h.id === handleId) : handles?.[0]) ?? null;\n  return handle && withAbsolutePosition ? {\n    ...handle,\n    ...getHandlePosition(node, handle, handle.position, true)\n  } : handle;\n}\nfunction getHandleType(edgeUpdaterType, handleDomNode) {\n  if (edgeUpdaterType) {\n    return edgeUpdaterType;\n  } else if (handleDomNode?.classList.contains('target')) {\n    return 'target';\n  } else if (handleDomNode?.classList.contains('source')) {\n    return 'source';\n  }\n  return null;\n}\nfunction isConnectionValid(isInsideConnectionRadius, isHandleValid) {\n  let isValid = null;\n  if (isHandleValid) {\n    isValid = true;\n  } else if (isInsideConnectionRadius && !isHandleValid) {\n    isValid = false;\n  }\n  return isValid;\n}\nconst alwaysValid = () => true;\nfunction onPointerDown(event, {\n  connectionMode,\n  connectionRadius,\n  handleId,\n  nodeId,\n  edgeUpdaterType,\n  isTarget,\n  domNode,\n  nodeLookup,\n  lib,\n  autoPanOnConnect,\n  flowId,\n  panBy,\n  cancelConnection,\n  onConnectStart,\n  onConnect,\n  onConnectEnd,\n  isValidConnection = alwaysValid,\n  onReconnectEnd,\n  updateConnection,\n  getTransform,\n  getFromHandle,\n  autoPanSpeed,\n  dragThreshold = 1,\n  handleDomNode\n}) {\n  // when xyflow is used inside a shadow root we can't use document\n  const doc = getHostForElement(event.target);\n  let autoPanId = 0;\n  let closestHandle;\n  const {\n    x,\n    y\n  } = getEventPosition(event);\n  const handleType = getHandleType(edgeUpdaterType, handleDomNode);\n  const containerBounds = domNode?.getBoundingClientRect();\n  let connectionStarted = false;\n  if (!containerBounds || !handleType) {\n    return;\n  }\n  const fromHandleInternal = getHandle(nodeId, handleType, handleId, nodeLookup, connectionMode);\n  if (!fromHandleInternal) {\n    return;\n  }\n  let position = getEventPosition(event, containerBounds);\n  let autoPanStarted = false;\n  let connection = null;\n  let isValid = false;\n  let resultHandleDomNode = null;\n  // when the user is moving the mouse close to the edge of the canvas while connecting we move the canvas\n  function autoPan() {\n    if (!autoPanOnConnect || !containerBounds) {\n      return;\n    }\n    const [x, y] = calcAutoPan(position, containerBounds, autoPanSpeed);\n    panBy({\n      x,\n      y\n    });\n    autoPanId = requestAnimationFrame(autoPan);\n  }\n  // Stays the same for all consecutive pointermove events\n  const fromHandle = {\n    ...fromHandleInternal,\n    nodeId,\n    type: handleType,\n    position: fromHandleInternal.position\n  };\n  const fromNodeInternal = nodeLookup.get(nodeId);\n  const from = getHandlePosition(fromNodeInternal, fromHandle, Position.Left, true);\n  let previousConnection = {\n    inProgress: true,\n    isValid: null,\n    from,\n    fromHandle,\n    fromPosition: fromHandle.position,\n    fromNode: fromNodeInternal,\n    to: position,\n    toHandle: null,\n    toPosition: oppositePosition[fromHandle.position],\n    toNode: null\n  };\n  function startConnection() {\n    connectionStarted = true;\n    updateConnection(previousConnection);\n    onConnectStart?.(event, {\n      nodeId,\n      handleId,\n      handleType\n    });\n  }\n  if (dragThreshold === 0) {\n    startConnection();\n  }\n  function onPointerMove(event) {\n    if (!connectionStarted) {\n      const {\n        x: evtX,\n        y: evtY\n      } = getEventPosition(event);\n      const dx = evtX - x;\n      const dy = evtY - y;\n      const nextConnectionStarted = dx * dx + dy * dy > dragThreshold * dragThreshold;\n      if (!nextConnectionStarted) {\n        return;\n      }\n      startConnection();\n    }\n    if (!getFromHandle() || !fromHandle) {\n      onPointerUp(event);\n      return;\n    }\n    const transform = getTransform();\n    position = getEventPosition(event, containerBounds);\n    closestHandle = getClosestHandle(pointToRendererPoint(position, transform, false, [1, 1]), connectionRadius, nodeLookup, fromHandle);\n    if (!autoPanStarted) {\n      autoPan();\n      autoPanStarted = true;\n    }\n    const result = isValidHandle(event, {\n      handle: closestHandle,\n      connectionMode,\n      fromNodeId: nodeId,\n      fromHandleId: handleId,\n      fromType: isTarget ? 'target' : 'source',\n      isValidConnection,\n      doc,\n      lib,\n      flowId,\n      nodeLookup\n    });\n    resultHandleDomNode = result.handleDomNode;\n    connection = result.connection;\n    isValid = isConnectionValid(!!closestHandle, result.isValid);\n    const newConnection = {\n      // from stays the same\n      ...previousConnection,\n      isValid,\n      to: result.toHandle && isValid ? rendererPointToPoint({\n        x: result.toHandle.x,\n        y: result.toHandle.y\n      }, transform) : position,\n      toHandle: result.toHandle,\n      toPosition: isValid && result.toHandle ? result.toHandle.position : oppositePosition[fromHandle.position],\n      toNode: result.toHandle ? nodeLookup.get(result.toHandle.nodeId) : null\n    };\n    /*\n     * we don't want to trigger an update when the connection\n     * is snapped to the same handle as before\n     */\n    if (isValid && closestHandle && previousConnection.toHandle && newConnection.toHandle && previousConnection.toHandle.type === newConnection.toHandle.type && previousConnection.toHandle.nodeId === newConnection.toHandle.nodeId && previousConnection.toHandle.id === newConnection.toHandle.id && previousConnection.to.x === newConnection.to.x && previousConnection.to.y === newConnection.to.y) {\n      return;\n    }\n    updateConnection(newConnection);\n    previousConnection = newConnection;\n  }\n  function onPointerUp(event) {\n    if (connectionStarted) {\n      if ((closestHandle || resultHandleDomNode) && connection && isValid) {\n        onConnect?.(connection);\n      }\n      /*\n       * it's important to get a fresh reference from the store here\n       * in order to get the latest state of onConnectEnd\n       */\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      const {\n        inProgress,\n        ...connectionState\n      } = previousConnection;\n      const finalConnectionState = {\n        ...connectionState,\n        toPosition: previousConnection.toHandle ? previousConnection.toPosition : null\n      };\n      onConnectEnd?.(event, finalConnectionState);\n      if (edgeUpdaterType) {\n        onReconnectEnd?.(event, finalConnectionState);\n      }\n    }\n    cancelConnection();\n    cancelAnimationFrame(autoPanId);\n    autoPanStarted = false;\n    isValid = false;\n    connection = null;\n    resultHandleDomNode = null;\n    doc.removeEventListener('mousemove', onPointerMove);\n    doc.removeEventListener('mouseup', onPointerUp);\n    doc.removeEventListener('touchmove', onPointerMove);\n    doc.removeEventListener('touchend', onPointerUp);\n  }\n  doc.addEventListener('mousemove', onPointerMove);\n  doc.addEventListener('mouseup', onPointerUp);\n  doc.addEventListener('touchmove', onPointerMove);\n  doc.addEventListener('touchend', onPointerUp);\n}\n// checks if  and returns connection in fom of an object { source: 123, target: 312 }\nfunction isValidHandle(event, {\n  handle,\n  connectionMode,\n  fromNodeId,\n  fromHandleId,\n  fromType,\n  doc,\n  lib,\n  flowId,\n  isValidConnection = alwaysValid,\n  nodeLookup\n}) {\n  const isTarget = fromType === 'target';\n  const handleDomNode = handle ? doc.querySelector(`.${lib}-flow__handle[data-id=\"${flowId}-${handle?.nodeId}-${handle?.id}-${handle?.type}\"]`) : null;\n  const {\n    x,\n    y\n  } = getEventPosition(event);\n  const handleBelow = doc.elementFromPoint(x, y);\n  /*\n   * we always want to prioritize the handle below the mouse cursor over the closest distance handle,\n   * because it could be that the center of another handle is closer to the mouse pointer than the handle below the cursor\n   */\n  const handleToCheck = handleBelow?.classList.contains(`${lib}-flow__handle`) ? handleBelow : handleDomNode;\n  const result = {\n    handleDomNode: handleToCheck,\n    isValid: false,\n    connection: null,\n    toHandle: null\n  };\n  if (handleToCheck) {\n    const handleType = getHandleType(undefined, handleToCheck);\n    const handleNodeId = handleToCheck.getAttribute('data-nodeid');\n    const handleId = handleToCheck.getAttribute('data-handleid');\n    const connectable = handleToCheck.classList.contains('connectable');\n    const connectableEnd = handleToCheck.classList.contains('connectableend');\n    if (!handleNodeId || !handleType) {\n      return result;\n    }\n    const connection = {\n      source: isTarget ? handleNodeId : fromNodeId,\n      sourceHandle: isTarget ? handleId : fromHandleId,\n      target: isTarget ? fromNodeId : handleNodeId,\n      targetHandle: isTarget ? fromHandleId : handleId\n    };\n    result.connection = connection;\n    const isConnectable = connectable && connectableEnd;\n    // in strict mode we don't allow target to target or source to source connections\n    const isValid = isConnectable && (connectionMode === ConnectionMode.Strict ? isTarget && handleType === 'source' || !isTarget && handleType === 'target' : handleNodeId !== fromNodeId || handleId !== fromHandleId);\n    result.isValid = isValid && isValidConnection(connection);\n    result.toHandle = getHandle(handleNodeId, handleType, handleId, nodeLookup, connectionMode, true);\n  }\n  return result;\n}\nconst XYHandle = {\n  onPointerDown,\n  isValid: isValidHandle\n};\nfunction XYMinimap({\n  domNode,\n  panZoom,\n  getTransform,\n  getViewScale\n}) {\n  const selection = select(domNode);\n  function update({\n    translateExtent,\n    width,\n    height,\n    zoomStep = 1,\n    pannable = true,\n    zoomable = true,\n    inversePan = false\n  }) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const zoomHandler = event => {\n      if (event.sourceEvent.type !== 'wheel' || !panZoom) {\n        return;\n      }\n      const transform = getTransform();\n      const factor = event.sourceEvent.ctrlKey && isMacOs() ? 10 : 1;\n      const pinchDelta = -event.sourceEvent.deltaY * (event.sourceEvent.deltaMode === 1 ? 0.05 : event.sourceEvent.deltaMode ? 1 : 0.002) * zoomStep;\n      const nextZoom = transform[2] * Math.pow(2, pinchDelta * factor);\n      panZoom.scaleTo(nextZoom);\n    };\n    let panStart = [0, 0];\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const panStartHandler = event => {\n      if (event.sourceEvent.type === 'mousedown' || event.sourceEvent.type === 'touchstart') {\n        panStart = [event.sourceEvent.clientX ?? event.sourceEvent.touches[0].clientX, event.sourceEvent.clientY ?? event.sourceEvent.touches[0].clientY];\n      }\n    };\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const panHandler = event => {\n      const transform = getTransform();\n      if (event.sourceEvent.type !== 'mousemove' && event.sourceEvent.type !== 'touchmove' || !panZoom) {\n        return;\n      }\n      const panCurrent = [event.sourceEvent.clientX ?? event.sourceEvent.touches[0].clientX, event.sourceEvent.clientY ?? event.sourceEvent.touches[0].clientY];\n      const panDelta = [panCurrent[0] - panStart[0], panCurrent[1] - panStart[1]];\n      panStart = panCurrent;\n      const moveScale = getViewScale() * Math.max(transform[2], Math.log(transform[2])) * (inversePan ? -1 : 1);\n      const position = {\n        x: transform[0] - panDelta[0] * moveScale,\n        y: transform[1] - panDelta[1] * moveScale\n      };\n      const extent = [[0, 0], [width, height]];\n      panZoom.setViewportConstrained({\n        x: position.x,\n        y: position.y,\n        zoom: transform[2]\n      }, extent, translateExtent);\n    };\n    const zoomAndPanHandler = zoom().on('start', panStartHandler)\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n    .on('zoom', pannable ? panHandler : null)\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n    .on('zoom.wheel', zoomable ? zoomHandler : null);\n    selection.call(zoomAndPanHandler, {});\n  }\n  function destroy() {\n    selection.on('zoom', null);\n  }\n  return {\n    update,\n    destroy,\n    pointer\n  };\n}\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\nconst viewChanged = (prevViewport, eventViewport) => prevViewport.x !== eventViewport.x || prevViewport.y !== eventViewport.y || prevViewport.zoom !== eventViewport.k;\nconst transformToViewport = transform => ({\n  x: transform.x,\n  y: transform.y,\n  zoom: transform.k\n});\nconst viewportToTransform = ({\n  x,\n  y,\n  zoom\n}) => zoomIdentity.translate(x, y).scale(zoom);\nconst isWrappedWithClass = (event, className) => event.target.closest(`.${className}`);\nconst isRightClickPan = (panOnDrag, usedButton) => usedButton === 2 && Array.isArray(panOnDrag) && panOnDrag.includes(2);\n// taken from d3-ease: https://github.com/d3/d3-ease/blob/main/src/cubic.js\nconst defaultEase = t => ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;\nconst getD3Transition = (selection, duration = 0, ease = defaultEase, onEnd = () => {}) => {\n  const hasDuration = typeof duration === 'number' && duration > 0;\n  if (!hasDuration) {\n    onEnd();\n  }\n  return hasDuration ? selection.transition().duration(duration).ease(ease).on('end', onEnd) : selection;\n};\nconst wheelDelta = event => {\n  const factor = event.ctrlKey && isMacOs() ? 10 : 1;\n  return -event.deltaY * (event.deltaMode === 1 ? 0.05 : event.deltaMode ? 1 : 0.002) * factor;\n};\nfunction createPanOnScrollHandler({\n  zoomPanValues,\n  noWheelClassName,\n  d3Selection,\n  d3Zoom,\n  panOnScrollMode,\n  panOnScrollSpeed,\n  zoomOnPinch,\n  onPanZoomStart,\n  onPanZoom,\n  onPanZoomEnd\n}) {\n  return event => {\n    if (isWrappedWithClass(event, noWheelClassName)) {\n      return false;\n    }\n    event.preventDefault();\n    event.stopImmediatePropagation();\n    const currentZoom = d3Selection.property('__zoom').k || 1;\n    // macos sets ctrlKey=true for pinch gesture on a trackpad\n    if (event.ctrlKey && zoomOnPinch) {\n      const point = pointer(event);\n      const pinchDelta = wheelDelta(event);\n      const zoom = currentZoom * Math.pow(2, pinchDelta);\n      // @ts-ignore\n      d3Zoom.scaleTo(d3Selection, zoom, point, event);\n      return;\n    }\n    /*\n     * increase scroll speed in firefox\n     * firefox: deltaMode === 1; chrome: deltaMode === 0\n     */\n    const deltaNormalize = event.deltaMode === 1 ? 20 : 1;\n    let deltaX = panOnScrollMode === PanOnScrollMode.Vertical ? 0 : event.deltaX * deltaNormalize;\n    let deltaY = panOnScrollMode === PanOnScrollMode.Horizontal ? 0 : event.deltaY * deltaNormalize;\n    // this enables vertical scrolling with shift + scroll on windows\n    if (!isMacOs() && event.shiftKey && panOnScrollMode !== PanOnScrollMode.Vertical) {\n      deltaX = event.deltaY * deltaNormalize;\n      deltaY = 0;\n    }\n    d3Zoom.translateBy(d3Selection, -(deltaX / currentZoom) * panOnScrollSpeed, -(deltaY / currentZoom) * panOnScrollSpeed,\n    // @ts-ignore\n    {\n      internal: true\n    });\n    const nextViewport = transformToViewport(d3Selection.property('__zoom'));\n    clearTimeout(zoomPanValues.panScrollTimeout);\n    /*\n     * for pan on scroll we need to handle the event calls on our own\n     * we can't use the start, zoom and end events from d3-zoom\n     * because start and move gets called on every scroll event and not once at the beginning\n     */\n    if (!zoomPanValues.isPanScrolling) {\n      zoomPanValues.isPanScrolling = true;\n      onPanZoomStart?.(event, nextViewport);\n    }\n    if (zoomPanValues.isPanScrolling) {\n      onPanZoom?.(event, nextViewport);\n      zoomPanValues.panScrollTimeout = setTimeout(() => {\n        onPanZoomEnd?.(event, nextViewport);\n        zoomPanValues.isPanScrolling = false;\n      }, 150);\n    }\n  };\n}\nfunction createZoomOnScrollHandler({\n  noWheelClassName,\n  preventScrolling,\n  d3ZoomHandler\n}) {\n  return function (event, d) {\n    const isWheel = event.type === 'wheel';\n    // we still want to enable pinch zooming even if preventScrolling is set to false\n    const preventZoom = !preventScrolling && isWheel && !event.ctrlKey;\n    const hasNoWheelClass = isWrappedWithClass(event, noWheelClassName);\n    // if user is pinch zooming above a nowheel element, we don't want the browser to zoom\n    if (event.ctrlKey && isWheel && hasNoWheelClass) {\n      event.preventDefault();\n    }\n    if (preventZoom || hasNoWheelClass) {\n      return null;\n    }\n    event.preventDefault();\n    d3ZoomHandler.call(this, event, d);\n  };\n}\nfunction createPanZoomStartHandler({\n  zoomPanValues,\n  onDraggingChange,\n  onPanZoomStart\n}) {\n  return event => {\n    if (event.sourceEvent?.internal) {\n      return;\n    }\n    const viewport = transformToViewport(event.transform);\n    // we need to remember it here, because it's always 0 in the \"zoom\" event\n    zoomPanValues.mouseButton = event.sourceEvent?.button || 0;\n    zoomPanValues.isZoomingOrPanning = true;\n    zoomPanValues.prevViewport = viewport;\n    if (event.sourceEvent?.type === 'mousedown') {\n      onDraggingChange(true);\n    }\n    if (onPanZoomStart) {\n      onPanZoomStart?.(event.sourceEvent, viewport);\n    }\n  };\n}\nfunction createPanZoomHandler({\n  zoomPanValues,\n  panOnDrag,\n  onPaneContextMenu,\n  onTransformChange,\n  onPanZoom\n}) {\n  return event => {\n    zoomPanValues.usedRightMouseButton = !!(onPaneContextMenu && isRightClickPan(panOnDrag, zoomPanValues.mouseButton ?? 0));\n    if (!event.sourceEvent?.sync) {\n      onTransformChange([event.transform.x, event.transform.y, event.transform.k]);\n    }\n    if (onPanZoom && !event.sourceEvent?.internal) {\n      onPanZoom?.(event.sourceEvent, transformToViewport(event.transform));\n    }\n  };\n}\nfunction createPanZoomEndHandler({\n  zoomPanValues,\n  panOnDrag,\n  panOnScroll,\n  onDraggingChange,\n  onPanZoomEnd,\n  onPaneContextMenu\n}) {\n  return event => {\n    if (event.sourceEvent?.internal) {\n      return;\n    }\n    zoomPanValues.isZoomingOrPanning = false;\n    if (onPaneContextMenu && isRightClickPan(panOnDrag, zoomPanValues.mouseButton ?? 0) && !zoomPanValues.usedRightMouseButton && event.sourceEvent) {\n      onPaneContextMenu(event.sourceEvent);\n    }\n    zoomPanValues.usedRightMouseButton = false;\n    onDraggingChange(false);\n    if (onPanZoomEnd && viewChanged(zoomPanValues.prevViewport, event.transform)) {\n      const viewport = transformToViewport(event.transform);\n      zoomPanValues.prevViewport = viewport;\n      clearTimeout(zoomPanValues.timerId);\n      zoomPanValues.timerId = setTimeout(() => {\n        onPanZoomEnd?.(event.sourceEvent, viewport);\n      },\n      // we need a setTimeout for panOnScroll to supress multiple end events fired during scroll\n      panOnScroll ? 150 : 0);\n    }\n  };\n}\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\nfunction createFilter({\n  zoomActivationKeyPressed,\n  zoomOnScroll,\n  zoomOnPinch,\n  panOnDrag,\n  panOnScroll,\n  zoomOnDoubleClick,\n  userSelectionActive,\n  noWheelClassName,\n  noPanClassName,\n  lib\n}) {\n  return event => {\n    const zoomScroll = zoomActivationKeyPressed || zoomOnScroll;\n    const pinchZoom = zoomOnPinch && event.ctrlKey;\n    if (event.button === 1 && event.type === 'mousedown' && (isWrappedWithClass(event, `${lib}-flow__node`) || isWrappedWithClass(event, `${lib}-flow__edge`))) {\n      return true;\n    }\n    // if all interactions are disabled, we prevent all zoom events\n    if (!panOnDrag && !zoomScroll && !panOnScroll && !zoomOnDoubleClick && !zoomOnPinch) {\n      return false;\n    }\n    // during a selection we prevent all other interactions\n    if (userSelectionActive) {\n      return false;\n    }\n    // if the target element is inside an element with the nowheel class, we prevent zooming\n    if (isWrappedWithClass(event, noWheelClassName) && event.type === 'wheel') {\n      return false;\n    }\n    // if the target element is inside an element with the nopan class, we prevent panning\n    if (isWrappedWithClass(event, noPanClassName) && (event.type !== 'wheel' || panOnScroll && event.type === 'wheel' && !zoomActivationKeyPressed)) {\n      return false;\n    }\n    if (!zoomOnPinch && event.ctrlKey && event.type === 'wheel') {\n      return false;\n    }\n    if (!zoomOnPinch && event.type === 'touchstart' && event.touches?.length > 1) {\n      event.preventDefault(); // if you manage to start with 2 touches, we prevent native zoom\n      return false;\n    }\n    // when there is no scroll handling enabled, we prevent all wheel events\n    if (!zoomScroll && !panOnScroll && !pinchZoom && event.type === 'wheel') {\n      return false;\n    }\n    // if the pane is not movable, we prevent dragging it with mousestart or touchstart\n    if (!panOnDrag && (event.type === 'mousedown' || event.type === 'touchstart')) {\n      return false;\n    }\n    // if the pane is only movable using allowed clicks\n    if (Array.isArray(panOnDrag) && !panOnDrag.includes(event.button) && event.type === 'mousedown') {\n      return false;\n    }\n    // We only allow right clicks if pan on drag is set to right click\n    const buttonAllowed = Array.isArray(panOnDrag) && panOnDrag.includes(event.button) || !event.button || event.button <= 1;\n    // default filter for d3-zoom\n    return (!event.ctrlKey || event.type === 'wheel') && buttonAllowed;\n  };\n}\nfunction XYPanZoom({\n  domNode,\n  minZoom,\n  maxZoom,\n  paneClickDistance,\n  translateExtent,\n  viewport,\n  onPanZoom,\n  onPanZoomStart,\n  onPanZoomEnd,\n  onDraggingChange\n}) {\n  const zoomPanValues = {\n    isZoomingOrPanning: false,\n    usedRightMouseButton: false,\n    prevViewport: {\n      x: 0,\n      y: 0,\n      zoom: 0\n    },\n    mouseButton: 0,\n    timerId: undefined,\n    panScrollTimeout: undefined,\n    isPanScrolling: false\n  };\n  const bbox = domNode.getBoundingClientRect();\n  const d3ZoomInstance = zoom().clickDistance(!isNumeric(paneClickDistance) || paneClickDistance < 0 ? 0 : paneClickDistance).scaleExtent([minZoom, maxZoom]).translateExtent(translateExtent);\n  const d3Selection = select(domNode).call(d3ZoomInstance);\n  setViewportConstrained({\n    x: viewport.x,\n    y: viewport.y,\n    zoom: clamp(viewport.zoom, minZoom, maxZoom)\n  }, [[0, 0], [bbox.width, bbox.height]], translateExtent);\n  const d3ZoomHandler = d3Selection.on('wheel.zoom');\n  const d3DblClickZoomHandler = d3Selection.on('dblclick.zoom');\n  d3ZoomInstance.wheelDelta(wheelDelta);\n  function setTransform(transform, options) {\n    if (d3Selection) {\n      return new Promise(resolve => {\n        d3ZoomInstance?.interpolate(options?.interpolate === 'linear' ? interpolate : interpolateZoom).transform(getD3Transition(d3Selection, options?.duration, options?.ease, () => resolve(true)), transform);\n      });\n    }\n    return Promise.resolve(false);\n  }\n  // public functions\n  function update({\n    noWheelClassName,\n    noPanClassName,\n    onPaneContextMenu,\n    userSelectionActive,\n    panOnScroll,\n    panOnDrag,\n    panOnScrollMode,\n    panOnScrollSpeed,\n    preventScrolling,\n    zoomOnPinch,\n    zoomOnScroll,\n    zoomOnDoubleClick,\n    zoomActivationKeyPressed,\n    lib,\n    onTransformChange\n  }) {\n    if (userSelectionActive && !zoomPanValues.isZoomingOrPanning) {\n      destroy();\n    }\n    const isPanOnScroll = panOnScroll && !zoomActivationKeyPressed && !userSelectionActive;\n    const wheelHandler = isPanOnScroll ? createPanOnScrollHandler({\n      zoomPanValues,\n      noWheelClassName,\n      d3Selection,\n      d3Zoom: d3ZoomInstance,\n      panOnScrollMode,\n      panOnScrollSpeed,\n      zoomOnPinch,\n      onPanZoomStart,\n      onPanZoom,\n      onPanZoomEnd\n    }) : createZoomOnScrollHandler({\n      noWheelClassName,\n      preventScrolling,\n      d3ZoomHandler\n    });\n    d3Selection.on('wheel.zoom', wheelHandler, {\n      passive: false\n    });\n    if (!userSelectionActive) {\n      // pan zoom start\n      const startHandler = createPanZoomStartHandler({\n        zoomPanValues,\n        onDraggingChange,\n        onPanZoomStart\n      });\n      d3ZoomInstance.on('start', startHandler);\n      // pan zoom\n      const panZoomHandler = createPanZoomHandler({\n        zoomPanValues,\n        panOnDrag,\n        onPaneContextMenu: !!onPaneContextMenu,\n        onPanZoom,\n        onTransformChange\n      });\n      d3ZoomInstance.on('zoom', panZoomHandler);\n      // pan zoom end\n      const panZoomEndHandler = createPanZoomEndHandler({\n        zoomPanValues,\n        panOnDrag,\n        panOnScroll,\n        onPaneContextMenu,\n        onPanZoomEnd,\n        onDraggingChange\n      });\n      d3ZoomInstance.on('end', panZoomEndHandler);\n    }\n    const filter = createFilter({\n      zoomActivationKeyPressed,\n      panOnDrag,\n      zoomOnScroll,\n      panOnScroll,\n      zoomOnDoubleClick,\n      zoomOnPinch,\n      userSelectionActive,\n      noPanClassName,\n      noWheelClassName,\n      lib\n    });\n    d3ZoomInstance.filter(filter);\n    /*\n     * We cannot add zoomOnDoubleClick to the filter above because\n     * double tapping on touch screens circumvents the filter and\n     * dblclick.zoom is fired on the selection directly\n     */\n    if (zoomOnDoubleClick) {\n      d3Selection.on('dblclick.zoom', d3DblClickZoomHandler);\n    } else {\n      d3Selection.on('dblclick.zoom', null);\n    }\n  }\n  function destroy() {\n    d3ZoomInstance.on('zoom', null);\n  }\n  async function setViewportConstrained(viewport, extent, translateExtent) {\n    const nextTransform = viewportToTransform(viewport);\n    const contrainedTransform = d3ZoomInstance?.constrain()(nextTransform, extent, translateExtent);\n    if (contrainedTransform) {\n      await setTransform(contrainedTransform);\n    }\n    return new Promise(resolve => resolve(contrainedTransform));\n  }\n  async function setViewport(viewport, options) {\n    const nextTransform = viewportToTransform(viewport);\n    await setTransform(nextTransform, options);\n    return new Promise(resolve => resolve(nextTransform));\n  }\n  function syncViewport(viewport) {\n    if (d3Selection) {\n      const nextTransform = viewportToTransform(viewport);\n      const currentTransform = d3Selection.property('__zoom');\n      if (currentTransform.k !== viewport.zoom || currentTransform.x !== viewport.x || currentTransform.y !== viewport.y) {\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n        d3ZoomInstance?.transform(d3Selection, nextTransform, null, {\n          sync: true\n        });\n      }\n    }\n  }\n  function getViewport() {\n    const transform = d3Selection ? zoomTransform(d3Selection.node()) : {\n      x: 0,\n      y: 0,\n      k: 1\n    };\n    return {\n      x: transform.x,\n      y: transform.y,\n      zoom: transform.k\n    };\n  }\n  function scaleTo(zoom, options) {\n    if (d3Selection) {\n      return new Promise(resolve => {\n        d3ZoomInstance?.interpolate(options?.interpolate === 'linear' ? interpolate : interpolateZoom).scaleTo(getD3Transition(d3Selection, options?.duration, options?.ease, () => resolve(true)), zoom);\n      });\n    }\n    return Promise.resolve(false);\n  }\n  function scaleBy(factor, options) {\n    if (d3Selection) {\n      return new Promise(resolve => {\n        d3ZoomInstance?.interpolate(options?.interpolate === 'linear' ? interpolate : interpolateZoom).scaleBy(getD3Transition(d3Selection, options?.duration, options?.ease, () => resolve(true)), factor);\n      });\n    }\n    return Promise.resolve(false);\n  }\n  function setScaleExtent(scaleExtent) {\n    d3ZoomInstance?.scaleExtent(scaleExtent);\n  }\n  function setTranslateExtent(translateExtent) {\n    d3ZoomInstance?.translateExtent(translateExtent);\n  }\n  function setClickDistance(distance) {\n    const validDistance = !isNumeric(distance) || distance < 0 ? 0 : distance;\n    d3ZoomInstance?.clickDistance(validDistance);\n  }\n  return {\n    update,\n    destroy,\n    setViewport,\n    setViewportConstrained,\n    getViewport,\n    scaleTo,\n    scaleBy,\n    setScaleExtent,\n    setTranslateExtent,\n    syncViewport,\n    setClickDistance\n  };\n}\n\n/**\n * Used to determine the variant of the resize control\n *\n * @public\n */\nvar ResizeControlVariant;\n(function (ResizeControlVariant) {\n  ResizeControlVariant[\"Line\"] = \"line\";\n  ResizeControlVariant[\"Handle\"] = \"handle\";\n})(ResizeControlVariant || (ResizeControlVariant = {}));\nconst XY_RESIZER_HANDLE_POSITIONS = ['top-left', 'top-right', 'bottom-left', 'bottom-right'];\nconst XY_RESIZER_LINE_POSITIONS = ['top', 'right', 'bottom', 'left'];\n\n/**\n * Get all connecting edges for a given set of nodes\n * @param width - new width of the node\n * @param prevWidth - previous width of the node\n * @param height - new height of the node\n * @param prevHeight - previous height of the node\n * @param affectsX - whether to invert the resize direction for the x axis\n * @param affectsY - whether to invert the resize direction for the y axis\n * @returns array of two numbers representing the direction of the resize for each axis, 0 = no change, 1 = increase, -1 = decrease\n */\nfunction getResizeDirection({\n  width,\n  prevWidth,\n  height,\n  prevHeight,\n  affectsX,\n  affectsY\n}) {\n  const deltaWidth = width - prevWidth;\n  const deltaHeight = height - prevHeight;\n  const direction = [deltaWidth > 0 ? 1 : deltaWidth < 0 ? -1 : 0, deltaHeight > 0 ? 1 : deltaHeight < 0 ? -1 : 0];\n  if (deltaWidth && affectsX) {\n    direction[0] = direction[0] * -1;\n  }\n  if (deltaHeight && affectsY) {\n    direction[1] = direction[1] * -1;\n  }\n  return direction;\n}\n/**\n * Parses the control position that is being dragged to dimensions that are being resized\n * @param controlPosition - position of the control that is being dragged\n * @returns isHorizontal, isVertical, affectsX, affectsY,\n */\nfunction getControlDirection(controlPosition) {\n  const isHorizontal = controlPosition.includes('right') || controlPosition.includes('left');\n  const isVertical = controlPosition.includes('bottom') || controlPosition.includes('top');\n  const affectsX = controlPosition.includes('left');\n  const affectsY = controlPosition.includes('top');\n  return {\n    isHorizontal,\n    isVertical,\n    affectsX,\n    affectsY\n  };\n}\nfunction getLowerExtentClamp(lowerExtent, lowerBound) {\n  return Math.max(0, lowerBound - lowerExtent);\n}\nfunction getUpperExtentClamp(upperExtent, upperBound) {\n  return Math.max(0, upperExtent - upperBound);\n}\nfunction getSizeClamp(size, minSize, maxSize) {\n  return Math.max(0, minSize - size, size - maxSize);\n}\nfunction xor(a, b) {\n  return a ? !b : b;\n}\n/**\n * Calculates new width & height and x & y of node after resize based on pointer position\n * @description - Buckle up, this is a chunky one... If you want to determine the new dimensions of a node after a resize,\n * you have to account for all possible restrictions: min/max width/height of the node, the maximum extent the node is allowed\n * to move in (in this case: resize into) determined by the parent node, the minimal extent determined by child nodes\n * with expandParent or extent: 'parent' set and oh yeah, these things also have to work with keepAspectRatio!\n * The way this is done is by determining how much each of these restricting actually restricts the resize and then applying the\n * strongest restriction. Because the resize affects x, y and width, height and width, height of a opposing side with keepAspectRatio,\n * the resize amount is always kept in distX & distY amount (the distance in mouse movement)\n * Instead of clamping each value, we first calculate the biggest 'clamp' (for the lack of a better name) and then apply it to all values.\n * To complicate things nodeOrigin has to be taken into account as well. This is done by offsetting the nodes as if their origin is [0, 0],\n * then calculating the restrictions as usual\n * @param startValues - starting values of resize\n * @param controlDirection - dimensions affected by the resize\n * @param pointerPosition - the current pointer position corrected for snapping\n * @param boundaries - minimum and maximum dimensions of the node\n * @param keepAspectRatio - prevent changes of asprect ratio\n * @returns x, y, width and height of the node after resize\n */\nfunction getDimensionsAfterResize(startValues, controlDirection, pointerPosition, boundaries, keepAspectRatio, nodeOrigin, extent, childExtent) {\n  let {\n    affectsX,\n    affectsY\n  } = controlDirection;\n  const {\n    isHorizontal,\n    isVertical\n  } = controlDirection;\n  const isDiagonal = isHorizontal && isVertical;\n  const {\n    xSnapped,\n    ySnapped\n  } = pointerPosition;\n  const {\n    minWidth,\n    maxWidth,\n    minHeight,\n    maxHeight\n  } = boundaries;\n  const {\n    x: startX,\n    y: startY,\n    width: startWidth,\n    height: startHeight,\n    aspectRatio\n  } = startValues;\n  let distX = Math.floor(isHorizontal ? xSnapped - startValues.pointerX : 0);\n  let distY = Math.floor(isVertical ? ySnapped - startValues.pointerY : 0);\n  const newWidth = startWidth + (affectsX ? -distX : distX);\n  const newHeight = startHeight + (affectsY ? -distY : distY);\n  const originOffsetX = -nodeOrigin[0] * startWidth;\n  const originOffsetY = -nodeOrigin[1] * startHeight;\n  // Check if maxWidth, minWWidth, maxHeight, minHeight are restricting the resize\n  let clampX = getSizeClamp(newWidth, minWidth, maxWidth);\n  let clampY = getSizeClamp(newHeight, minHeight, maxHeight);\n  // Check if extent is restricting the resize\n  if (extent) {\n    let xExtentClamp = 0;\n    let yExtentClamp = 0;\n    if (affectsX && distX < 0) {\n      xExtentClamp = getLowerExtentClamp(startX + distX + originOffsetX, extent[0][0]);\n    } else if (!affectsX && distX > 0) {\n      xExtentClamp = getUpperExtentClamp(startX + newWidth + originOffsetX, extent[1][0]);\n    }\n    if (affectsY && distY < 0) {\n      yExtentClamp = getLowerExtentClamp(startY + distY + originOffsetY, extent[0][1]);\n    } else if (!affectsY && distY > 0) {\n      yExtentClamp = getUpperExtentClamp(startY + newHeight + originOffsetY, extent[1][1]);\n    }\n    clampX = Math.max(clampX, xExtentClamp);\n    clampY = Math.max(clampY, yExtentClamp);\n  }\n  // Check if the child extent is restricting the resize\n  if (childExtent) {\n    let xExtentClamp = 0;\n    let yExtentClamp = 0;\n    if (affectsX && distX > 0) {\n      xExtentClamp = getUpperExtentClamp(startX + distX, childExtent[0][0]);\n    } else if (!affectsX && distX < 0) {\n      xExtentClamp = getLowerExtentClamp(startX + newWidth, childExtent[1][0]);\n    }\n    if (affectsY && distY > 0) {\n      yExtentClamp = getUpperExtentClamp(startY + distY, childExtent[0][1]);\n    } else if (!affectsY && distY < 0) {\n      yExtentClamp = getLowerExtentClamp(startY + newHeight, childExtent[1][1]);\n    }\n    clampX = Math.max(clampX, xExtentClamp);\n    clampY = Math.max(clampY, yExtentClamp);\n  }\n  // Check if the aspect ratio resizing of the other side is restricting the resize\n  if (keepAspectRatio) {\n    if (isHorizontal) {\n      // Check if the max dimensions might be restricting the resize\n      const aspectHeightClamp = getSizeClamp(newWidth / aspectRatio, minHeight, maxHeight) * aspectRatio;\n      clampX = Math.max(clampX, aspectHeightClamp);\n      // Check if the extent is restricting the resize\n      if (extent) {\n        let aspectExtentClamp = 0;\n        if (!affectsX && !affectsY || affectsX && !affectsY && isDiagonal) {\n          aspectExtentClamp = getUpperExtentClamp(startY + originOffsetY + newWidth / aspectRatio, extent[1][1]) * aspectRatio;\n        } else {\n          aspectExtentClamp = getLowerExtentClamp(startY + originOffsetY + (affectsX ? distX : -distX) / aspectRatio, extent[0][1]) * aspectRatio;\n        }\n        clampX = Math.max(clampX, aspectExtentClamp);\n      }\n      // Check if the child extent is restricting the resize\n      if (childExtent) {\n        let aspectExtentClamp = 0;\n        if (!affectsX && !affectsY || affectsX && !affectsY && isDiagonal) {\n          aspectExtentClamp = getLowerExtentClamp(startY + newWidth / aspectRatio, childExtent[1][1]) * aspectRatio;\n        } else {\n          aspectExtentClamp = getUpperExtentClamp(startY + (affectsX ? distX : -distX) / aspectRatio, childExtent[0][1]) * aspectRatio;\n        }\n        clampX = Math.max(clampX, aspectExtentClamp);\n      }\n    }\n    // Do the same thing for vertical resizing\n    if (isVertical) {\n      const aspectWidthClamp = getSizeClamp(newHeight * aspectRatio, minWidth, maxWidth) / aspectRatio;\n      clampY = Math.max(clampY, aspectWidthClamp);\n      if (extent) {\n        let aspectExtentClamp = 0;\n        if (!affectsX && !affectsY || affectsY && !affectsX && isDiagonal) {\n          aspectExtentClamp = getUpperExtentClamp(startX + newHeight * aspectRatio + originOffsetX, extent[1][0]) / aspectRatio;\n        } else {\n          aspectExtentClamp = getLowerExtentClamp(startX + (affectsY ? distY : -distY) * aspectRatio + originOffsetX, extent[0][0]) / aspectRatio;\n        }\n        clampY = Math.max(clampY, aspectExtentClamp);\n      }\n      if (childExtent) {\n        let aspectExtentClamp = 0;\n        if (!affectsX && !affectsY || affectsY && !affectsX && isDiagonal) {\n          aspectExtentClamp = getLowerExtentClamp(startX + newHeight * aspectRatio, childExtent[1][0]) / aspectRatio;\n        } else {\n          aspectExtentClamp = getUpperExtentClamp(startX + (affectsY ? distY : -distY) * aspectRatio, childExtent[0][0]) / aspectRatio;\n        }\n        clampY = Math.max(clampY, aspectExtentClamp);\n      }\n    }\n  }\n  distY = distY + (distY < 0 ? clampY : -clampY);\n  distX = distX + (distX < 0 ? clampX : -clampX);\n  if (keepAspectRatio) {\n    if (isDiagonal) {\n      if (newWidth > newHeight * aspectRatio) {\n        distY = (xor(affectsX, affectsY) ? -distX : distX) / aspectRatio;\n      } else {\n        distX = (xor(affectsX, affectsY) ? -distY : distY) * aspectRatio;\n      }\n    } else {\n      if (isHorizontal) {\n        distY = distX / aspectRatio;\n        affectsY = affectsX;\n      } else {\n        distX = distY * aspectRatio;\n        affectsX = affectsY;\n      }\n    }\n  }\n  const x = affectsX ? startX + distX : startX;\n  const y = affectsY ? startY + distY : startY;\n  return {\n    width: startWidth + (affectsX ? -distX : distX),\n    height: startHeight + (affectsY ? -distY : distY),\n    x: nodeOrigin[0] * distX * (!affectsX ? 1 : -1) + x,\n    y: nodeOrigin[1] * distY * (!affectsY ? 1 : -1) + y\n  };\n}\nconst initPrevValues = {\n  width: 0,\n  height: 0,\n  x: 0,\n  y: 0\n};\nconst initStartValues = {\n  ...initPrevValues,\n  pointerX: 0,\n  pointerY: 0,\n  aspectRatio: 1\n};\nfunction nodeToParentExtent(node) {\n  return [[0, 0], [node.measured.width, node.measured.height]];\n}\nfunction nodeToChildExtent(child, parent, nodeOrigin) {\n  const x = parent.position.x + child.position.x;\n  const y = parent.position.y + child.position.y;\n  const width = child.measured.width ?? 0;\n  const height = child.measured.height ?? 0;\n  const originOffsetX = nodeOrigin[0] * width;\n  const originOffsetY = nodeOrigin[1] * height;\n  return [[x - originOffsetX, y - originOffsetY], [x + width - originOffsetX, y + height - originOffsetY]];\n}\nfunction XYResizer({\n  domNode,\n  nodeId,\n  getStoreItems,\n  onChange,\n  onEnd\n}) {\n  const selection = select(domNode);\n  function update({\n    controlPosition,\n    boundaries,\n    keepAspectRatio,\n    resizeDirection,\n    onResizeStart,\n    onResize,\n    onResizeEnd,\n    shouldResize\n  }) {\n    let prevValues = {\n      ...initPrevValues\n    };\n    let startValues = {\n      ...initStartValues\n    };\n    const controlDirection = getControlDirection(controlPosition);\n    let node = undefined;\n    let containerBounds = null;\n    let childNodes = [];\n    let parentNode = undefined; // Needed to fix expandParent\n    let parentExtent = undefined;\n    let childExtent = undefined;\n    const dragHandler = drag().on('start', event => {\n      const {\n        nodeLookup,\n        transform,\n        snapGrid,\n        snapToGrid,\n        nodeOrigin,\n        paneDomNode\n      } = getStoreItems();\n      node = nodeLookup.get(nodeId);\n      if (!node) {\n        return;\n      }\n      containerBounds = paneDomNode?.getBoundingClientRect() ?? null;\n      const {\n        xSnapped,\n        ySnapped\n      } = getPointerPosition(event.sourceEvent, {\n        transform,\n        snapGrid,\n        snapToGrid,\n        containerBounds\n      });\n      prevValues = {\n        width: node.measured.width ?? 0,\n        height: node.measured.height ?? 0,\n        x: node.position.x ?? 0,\n        y: node.position.y ?? 0\n      };\n      startValues = {\n        ...prevValues,\n        pointerX: xSnapped,\n        pointerY: ySnapped,\n        aspectRatio: prevValues.width / prevValues.height\n      };\n      parentNode = undefined;\n      if (node.parentId && (node.extent === 'parent' || node.expandParent)) {\n        parentNode = nodeLookup.get(node.parentId);\n        parentExtent = parentNode && node.extent === 'parent' ? nodeToParentExtent(parentNode) : undefined;\n      }\n      /*\n       * Collect all child nodes to correct their relative positions when top/left changes\n       * Determine largest minimal extent the parent node is allowed to resize to\n       */\n      childNodes = [];\n      childExtent = undefined;\n      for (const [childId, child] of nodeLookup) {\n        if (child.parentId === nodeId) {\n          childNodes.push({\n            id: childId,\n            position: {\n              ...child.position\n            },\n            extent: child.extent\n          });\n          if (child.extent === 'parent' || child.expandParent) {\n            const extent = nodeToChildExtent(child, node, child.origin ?? nodeOrigin);\n            if (childExtent) {\n              childExtent = [[Math.min(extent[0][0], childExtent[0][0]), Math.min(extent[0][1], childExtent[0][1])], [Math.max(extent[1][0], childExtent[1][0]), Math.max(extent[1][1], childExtent[1][1])]];\n            } else {\n              childExtent = extent;\n            }\n          }\n        }\n      }\n      onResizeStart?.(event, {\n        ...prevValues\n      });\n    }).on('drag', event => {\n      const {\n        transform,\n        snapGrid,\n        snapToGrid,\n        nodeOrigin: storeNodeOrigin\n      } = getStoreItems();\n      const pointerPosition = getPointerPosition(event.sourceEvent, {\n        transform,\n        snapGrid,\n        snapToGrid,\n        containerBounds\n      });\n      const childChanges = [];\n      if (!node) {\n        return;\n      }\n      const {\n        x: prevX,\n        y: prevY,\n        width: prevWidth,\n        height: prevHeight\n      } = prevValues;\n      const change = {};\n      const nodeOrigin = node.origin ?? storeNodeOrigin;\n      const {\n        width,\n        height,\n        x,\n        y\n      } = getDimensionsAfterResize(startValues, controlDirection, pointerPosition, boundaries, keepAspectRatio, nodeOrigin, parentExtent, childExtent);\n      const isWidthChange = width !== prevWidth;\n      const isHeightChange = height !== prevHeight;\n      const isXPosChange = x !== prevX && isWidthChange;\n      const isYPosChange = y !== prevY && isHeightChange;\n      if (!isXPosChange && !isYPosChange && !isWidthChange && !isHeightChange) {\n        return;\n      }\n      if (isXPosChange || isYPosChange || nodeOrigin[0] === 1 || nodeOrigin[1] === 1) {\n        change.x = isXPosChange ? x : prevValues.x;\n        change.y = isYPosChange ? y : prevValues.y;\n        prevValues.x = change.x;\n        prevValues.y = change.y;\n        /*\n         * when top/left changes, correct the relative positions of child nodes\n         * so that they stay in the same position\n         */\n        if (childNodes.length > 0) {\n          const xChange = x - prevX;\n          const yChange = y - prevY;\n          for (const childNode of childNodes) {\n            childNode.position = {\n              x: childNode.position.x - xChange + nodeOrigin[0] * (width - prevWidth),\n              y: childNode.position.y - yChange + nodeOrigin[1] * (height - prevHeight)\n            };\n            childChanges.push(childNode);\n          }\n        }\n      }\n      if (isWidthChange || isHeightChange) {\n        change.width = isWidthChange && (!resizeDirection || resizeDirection === 'horizontal') ? width : prevValues.width;\n        change.height = isHeightChange && (!resizeDirection || resizeDirection === 'vertical') ? height : prevValues.height;\n        prevValues.width = change.width;\n        prevValues.height = change.height;\n      }\n      // Fix expandParent when resizing from top/left\n      if (parentNode && node.expandParent) {\n        const xLimit = nodeOrigin[0] * (change.width ?? 0);\n        if (change.x && change.x < xLimit) {\n          prevValues.x = xLimit;\n          startValues.x = startValues.x - (change.x - xLimit);\n        }\n        const yLimit = nodeOrigin[1] * (change.height ?? 0);\n        if (change.y && change.y < yLimit) {\n          prevValues.y = yLimit;\n          startValues.y = startValues.y - (change.y - yLimit);\n        }\n      }\n      const direction = getResizeDirection({\n        width: prevValues.width,\n        prevWidth,\n        height: prevValues.height,\n        prevHeight,\n        affectsX: controlDirection.affectsX,\n        affectsY: controlDirection.affectsY\n      });\n      const nextValues = {\n        ...prevValues,\n        direction\n      };\n      const callResize = shouldResize?.(event, nextValues);\n      if (callResize === false) {\n        return;\n      }\n      onResize?.(event, nextValues);\n      onChange(change, childChanges);\n    }).on('end', event => {\n      onResizeEnd?.(event, {\n        ...prevValues\n      });\n      onEnd?.({\n        ...prevValues\n      });\n    });\n    selection.call(dragHandler);\n  }\n  function destroy() {\n    selection.on('.drag', null);\n  }\n  return {\n    update,\n    destroy\n  };\n}\nexport { ConnectionLineType, ConnectionMode, MarkerType, PanOnScrollMode, Position, ResizeControlVariant, SelectionMode, XYDrag, XYHandle, XYMinimap, XYPanZoom, XYResizer, XY_RESIZER_HANDLE_POSITIONS, XY_RESIZER_LINE_POSITIONS, addEdge, adoptUserNodes, areConnectionMapsEqual, areSetsEqual, boxToRect, calcAutoPan, calculateNodePosition, clamp, clampPosition, clampPositionToParent, createMarkerIds, defaultAriaLabelConfig, devWarn, elementSelectionKeys, errorMessages, evaluateAbsolutePosition, fitViewport, getBezierEdgeCenter, getBezierPath, getBoundsOfBoxes, getBoundsOfRects, getConnectedEdges, getConnectionStatus, getDimensions, getEdgeCenter, getEdgePosition, getElementsToRemove, getElevatedEdgeZIndex, getEventPosition, getHandleBounds, getHandlePosition, getHostForElement, getIncomers, getInternalNodesBounds, getMarkerId, getNodeDimensions, getNodePositionWithOrigin, getNodeToolbarTransform, getNodesBounds, getNodesInside, getOutgoers, getOverlappingArea, getPointerPosition, getSmoothStepPath, getStraightPath, getViewportForBounds, handleConnectionChange, handleExpandParent, infiniteExtent, initialConnection, isCoordinateExtent, isEdgeBase, isEdgeVisible, isInputDOMNode, isInternalNodeBase, isMacOs, isMouseEvent, isNodeBase, isNumeric, isRectObject, mergeAriaLabelConfig, nodeHasDimensions, nodeToBox, nodeToRect, oppositePosition, panBy, pointToRendererPoint, reconnectEdge, rectToBox, rendererPointToPoint, shallowNodeData, snapPosition, updateAbsolutePositions, updateConnectionLookup, updateNodeInternals, withResolvers };","map":{"version":3,"names":["drag","select","pointer","zoom","zoomIdentity","zoomTransform","interpolateZoom","interpolate","errorMessages","error001","error002","error003","nodeType","error004","error005","error006","error007","id","error009","type","error008","handleType","sourceHandle","targetHandle","error010","error011","edgeType","error012","error013","lib","error014","error015","infiniteExtent","Number","NEGATIVE_INFINITY","POSITIVE_INFINITY","elementSelectionKeys","defaultAriaLabelConfig","node.a11yDescription.ariaLiveMessage","direction","x","y","ConnectionMode","PanOnScrollMode","SelectionMode","initialConnection","inProgress","isValid","from","fromHandle","fromPosition","fromNode","to","toHandle","toPosition","toNode","ConnectionLineType","MarkerType","Position","oppositePosition","Left","Right","Top","Bottom","areConnectionMapsEqual","a","b","size","key","keys","has","handleConnectionChange","cb","diff","forEach","connection","push","length","getConnectionStatus","isEdgeBase","element","isNodeBase","isInternalNodeBase","getOutgoers","node","nodes","edges","outgoerIds","Set","edge","source","add","target","filter","n","getIncomers","incomersIds","getNodePositionWithOrigin","nodeOrigin","width","height","getNodeDimensions","origin","offsetX","offsetY","position","getNodesBounds","params","process","env","NODE_ENV","nodeLookup","console","warn","box","reduce","currBox","nodeOrId","isId","currentNode","undefined","get","nodeBox","nodeToBox","x2","y2","getBoundsOfBoxes","Infinity","boxToRect","getInternalNodesBounds","getNodesInside","rect","tx","ty","tScale","partially","excludeNonSelectableNodes","paneRect","pointToRendererPoint","visibleNodes","values","measured","selectable","hidden","initialWidth","initialHeight","overlappingArea","getOverlappingArea","nodeToRect","area","partiallyVisible","forceInitialRender","internals","handleBounds","isVisible","dragging","getConnectedEdges","nodeIds","getFitViewNodes","options","fitViewNodes","Map","optionNodeIds","map","includeHiddenNodes","set","fitViewport","panZoom","minZoom","maxZoom","Promise","resolve","nodesToFit","bounds","viewport","getViewportForBounds","padding","setViewport","duration","ease","calculateNodePosition","nodeId","nextPosition","nodeExtent","onError","parentNode","parentId","parentX","parentY","positionAbsolute","extent","expandParent","parentWidth","parentHeight","isCoordinateExtent","clampPosition","getElementsToRemove","nodesToRemove","edgesToRemove","onBeforeDelete","matchingNodes","deletable","isIncluded","parentHit","find","edgeIds","deletableEdges","connectedEdges","matchingEdges","e","onBeforeDeleteResult","clamp","val","min","max","Math","dimensions","clampPositionToParent","childPosition","childDimensions","parent","calcAutoPanVelocity","value","abs","calcAutoPan","pos","speed","distance","xMovement","yMovement","box1","box2","rectToBox","getBoundsOfRects","rect1","rect2","rectA","rectB","xOverlap","yOverlap","ceil","isRectObject","obj","isNumeric","isNaN","isFinite","devWarn","message","snapPosition","snapGrid","round","snapToGrid","rendererPointToPoint","parsePadding","floor","endsWith","paddingValue","parseFloat","error","parsePaddings","paddingY","paddingX","top","right","bottom","left","calculateAppliedPaddings","boundRight","boundBottom","p","xZoom","yZoom","clampedZoom","boundsCenterX","boundsCenterY","newPadding","offset","isMacOs","navigator","userAgent","indexOf","nodeHasDimensions","evaluateAbsolutePosition","areSetsEqual","item","withResolvers","reject","promise","res","rej","mergeAriaLabelConfig","partial","getPointerPosition","event","transform","containerBounds","getEventPosition","pointerPos","xSnapped","ySnapped","getDimensions","offsetWidth","offsetHeight","getHostForElement","getRootNode","window","document","inputTags","isInputDOMNode","composedPath","isInput","includes","nodeName","hasAttribute","closest","isMouseEvent","isMouse","evtX","clientX","touches","evtY","clientY","getHandleBounds","nodeElement","nodeBounds","handles","querySelectorAll","Array","handle","getBoundingClientRect","getAttribute","getBezierEdgeCenter","sourceX","sourceY","targetX","targetY","sourceControlX","sourceControlY","targetControlX","targetControlY","centerX","centerY","calculateControlOffset","curvature","sqrt","getControlWithCurvature","x1","y1","c","getBezierPath","sourcePosition","targetPosition","labelX","labelY","getEdgeCenter","xOffset","yOffset","getElevatedEdgeZIndex","sourceNode","targetNode","selected","zIndex","elevateOnSelect","edgeZ","nodeZ","z","isEdgeVisible","edgeBox","viewRect","getEdgeId","connectionExists","some","el","addEdge","edgeParams","concat","reconnectEdge","oldEdge","newConnection","shouldReplaceId","oldEdgeId","rest","foundEdge","getStraightPath","handleDirections","getDirection","pow","getPoints","center","stepPosition","sourceDir","targetDir","sourceGapped","targetGapped","dir","dirAccessor","currDir","points","sourceGapOffset","targetGapOffset","defaultOffsetX","defaultOffsetY","verticalSplit","horizontalSplit","sourceTarget","targetSource","gapOffset","dirAccessorOpposite","isSameDir","sourceGtTargetOppo","sourceLtTargetOppo","flipSourceTarget","sourceGapPoint","targetGapPoint","maxXDistance","maxYDistance","pathPoints","getBend","bendSize","xDir","yDir","getSmoothStepPath","borderRadius","path","i","segment","isNodeInitialized","getEdgePosition","sourceHandleBounds","toHandleBounds","targetHandleBounds","getHandle$1","connectionMode","Strict","getHandlePosition","fallbackPosition","handleId","d","getMarkerId","marker","idPrefix","Object","sort","join","createMarkerIds","defaultColor","defaultMarkerStart","defaultMarkerEnd","ids","markers","markerStart","markerEnd","markerId","color","localeCompare","getNodeToolbarTransform","nodeRect","align","alignmentOffset","shift","defaultOptions","elevateNodesOnSelect","defaults","adoptUserNodesDefaultOptions","checkEquality","mergeObjects","base","incoming","result","updateAbsolutePositions","parentLookup","_options","updateChildNode","positionWithOrigin","clampedPosition","adoptUserNodes","nodesInitialized","tmpLookup","selectedNodeZ","clear","userNode","internalNode","calculateZ","updateParentLookup","childNodes","calculateChildXYZ","positionChanged","childNode","absolutePosition","childZ","parentZ","handleExpandParent","children","changes","parentExpansions","child","parentRect","expandedRect","xChange","yChange","newWidth","newHeight","widthChange","heightChange","setAttributes","updateNodeInternals","updates","domNode","viewportNode","querySelector","updatedInternals","style","getComputedStyle","m22","DOMMatrixReadOnly","parentExpandChildren","update","dimensionChanged","doUpdate","force","newNode","parentExpandChanges","panBy","delta","translateExtent","nextViewport","setViewportConstrained","transformChanged","k","addConnectionToLookup","connectionKey","connectionLookup","nodeMap","typeMap","handleMap","updateConnectionLookup","edgeLookup","edgeId","sourceKey","targetKey","shallowNodeData","_a","isArray","_b","is","data","isParentSelected","hasSelector","selector","current","matches","parentElement","getDragItems","nodesDraggable","mousePos","dragItems","draggable","getEventHandlerParams","nodesFromDragItems","dragItem","calculateSnapOffset","refDragItem","next","refPos","refPosSnapped","XYDrag","onNodeMouseDown","getStoreItems","onDragStart","onDrag","onDragStop","lastPos","autoPanId","autoPanStarted","mousePosition","dragStarted","d3Selection","abortDrag","nodePositionsChanged","dragEvent","noDragClassName","handleSelector","isSelectable","nodeClickDistance","updateNodes","onNodeDrag","onSelectionDrag","updateNodePositions","hasChange","isMultiDrag","nodesBox","multiDragSnapOffset","adjustedNodeExtent","currentNodes","autoPan","autoPanSpeed","autoPanOnNodeDrag","cancelAnimationFrame","requestAnimationFrame","startDrag","multiSelectionActive","selectNodesOnDrag","onNodeDragStart","onSelectionDragStart","unselectNodesAndEdges","sourceEvent","d3DragInstance","clickDistance","on","nodeDragThreshold","onNodeDragStop","onSelectionDragStop","isDraggable","button","call","destroy","getNodesWithinDistance","ADDITIONAL_DISTANCE","getClosestHandle","connectionRadius","closestHandles","minDistance","closeNodes","allHandles","oppositeHandleType","getHandle","withAbsolutePosition","h","getHandleType","edgeUpdaterType","handleDomNode","classList","contains","isConnectionValid","isInsideConnectionRadius","isHandleValid","alwaysValid","onPointerDown","isTarget","autoPanOnConnect","flowId","cancelConnection","onConnectStart","onConnect","onConnectEnd","isValidConnection","onReconnectEnd","updateConnection","getTransform","getFromHandle","dragThreshold","doc","closestHandle","connectionStarted","fromHandleInternal","resultHandleDomNode","fromNodeInternal","previousConnection","startConnection","onPointerMove","dx","dy","nextConnectionStarted","onPointerUp","isValidHandle","fromNodeId","fromHandleId","fromType","connectionState","finalConnectionState","removeEventListener","addEventListener","handleBelow","elementFromPoint","handleToCheck","handleNodeId","connectable","connectableEnd","isConnectable","XYHandle","XYMinimap","getViewScale","selection","zoomStep","pannable","zoomable","inversePan","zoomHandler","factor","ctrlKey","pinchDelta","deltaY","deltaMode","nextZoom","scaleTo","panStart","panStartHandler","panHandler","panCurrent","panDelta","moveScale","log","zoomAndPanHandler","viewChanged","prevViewport","eventViewport","transformToViewport","viewportToTransform","translate","scale","isWrappedWithClass","className","isRightClickPan","panOnDrag","usedButton","defaultEase","t","getD3Transition","onEnd","hasDuration","transition","wheelDelta","createPanOnScrollHandler","zoomPanValues","noWheelClassName","d3Zoom","panOnScrollMode","panOnScrollSpeed","zoomOnPinch","onPanZoomStart","onPanZoom","onPanZoomEnd","preventDefault","stopImmediatePropagation","currentZoom","property","point","deltaNormalize","deltaX","Vertical","Horizontal","shiftKey","translateBy","internal","clearTimeout","panScrollTimeout","isPanScrolling","setTimeout","createZoomOnScrollHandler","preventScrolling","d3ZoomHandler","isWheel","preventZoom","hasNoWheelClass","createPanZoomStartHandler","onDraggingChange","mouseButton","isZoomingOrPanning","createPanZoomHandler","onPaneContextMenu","onTransformChange","usedRightMouseButton","sync","createPanZoomEndHandler","panOnScroll","timerId","createFilter","zoomActivationKeyPressed","zoomOnScroll","zoomOnDoubleClick","userSelectionActive","noPanClassName","zoomScroll","pinchZoom","buttonAllowed","XYPanZoom","paneClickDistance","bbox","d3ZoomInstance","scaleExtent","d3DblClickZoomHandler","setTransform","isPanOnScroll","wheelHandler","passive","startHandler","panZoomHandler","panZoomEndHandler","nextTransform","contrainedTransform","constrain","syncViewport","currentTransform","getViewport","scaleBy","setScaleExtent","setTranslateExtent","setClickDistance","validDistance","ResizeControlVariant","XY_RESIZER_HANDLE_POSITIONS","XY_RESIZER_LINE_POSITIONS","getResizeDirection","prevWidth","prevHeight","affectsX","affectsY","deltaWidth","deltaHeight","getControlDirection","controlPosition","isHorizontal","isVertical","getLowerExtentClamp","lowerExtent","lowerBound","getUpperExtentClamp","upperExtent","upperBound","getSizeClamp","minSize","maxSize","xor","getDimensionsAfterResize","startValues","controlDirection","pointerPosition","boundaries","keepAspectRatio","childExtent","isDiagonal","minWidth","maxWidth","minHeight","maxHeight","startX","startY","startWidth","startHeight","aspectRatio","distX","pointerX","distY","pointerY","originOffsetX","originOffsetY","clampX","clampY","xExtentClamp","yExtentClamp","aspectHeightClamp","aspectExtentClamp","aspectWidthClamp","initPrevValues","initStartValues","nodeToParentExtent","nodeToChildExtent","XYResizer","onChange","resizeDirection","onResizeStart","onResize","onResizeEnd","shouldResize","prevValues","parentExtent","dragHandler","paneDomNode","childId","storeNodeOrigin","childChanges","prevX","prevY","change","isWidthChange","isHeightChange","isXPosChange","isYPosChange","xLimit","yLimit","nextValues","callResize"],"sources":["/Users/indiamaris/CODE/petflow/node_modules/@xyflow/system/dist/esm/index.js"],"sourcesContent":["import { drag } from 'd3-drag';\nimport { select, pointer } from 'd3-selection';\nimport { zoom, zoomIdentity, zoomTransform } from 'd3-zoom';\nimport { interpolateZoom, interpolate } from 'd3-interpolate';\n\nconst errorMessages = {\n    error001: () => '[React Flow]: Seems like you have not used zustand provider as an ancestor. Help: https://reactflow.dev/error#001',\n    error002: () => \"It looks like you've created a new nodeTypes or edgeTypes object. If this wasn't on purpose please define the nodeTypes/edgeTypes outside of the component or memoize them.\",\n    error003: (nodeType) => `Node type \"${nodeType}\" not found. Using fallback type \"default\".`,\n    error004: () => 'The React Flow parent container needs a width and a height to render the graph.',\n    error005: () => 'Only child nodes can use a parent extent.',\n    error006: () => \"Can't create edge. An edge needs a source and a target.\",\n    error007: (id) => `The old edge with id=${id} does not exist.`,\n    error009: (type) => `Marker type \"${type}\" doesn't exist.`,\n    error008: (handleType, { id, sourceHandle, targetHandle }) => `Couldn't create edge for ${handleType} handle id: \"${handleType === 'source' ? sourceHandle : targetHandle}\", edge id: ${id}.`,\n    error010: () => 'Handle: No node id found. Make sure to only use a Handle inside a custom Node.',\n    error011: (edgeType) => `Edge type \"${edgeType}\" not found. Using fallback type \"default\".`,\n    error012: (id) => `Node with id \"${id}\" does not exist, it may have been removed. This can happen when a node is deleted before the \"onNodeClick\" handler is called.`,\n    error013: (lib = 'react') => `It seems that you haven't loaded the styles. Please import '@xyflow/${lib}/dist/style.css' or base.css to make sure everything is working properly.`,\n    error014: () => 'useNodeConnections: No node ID found. Call useNodeConnections inside a custom Node or provide a node ID.',\n    error015: () => 'It seems that you are trying to drag a node that is not initialized. Please use onNodesChange as explained in the docs.',\n};\nconst infiniteExtent = [\n    [Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY],\n    [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY],\n];\nconst elementSelectionKeys = ['Enter', ' ', 'Escape'];\nconst defaultAriaLabelConfig = {\n    'node.a11yDescription.default': 'Press enter or space to select a node. Press delete to remove it and escape to cancel.',\n    'node.a11yDescription.keyboardDisabled': 'Press enter or space to select a node. You can then use the arrow keys to move the node around. Press delete to remove it and escape to cancel.',\n    'node.a11yDescription.ariaLiveMessage': ({ direction, x, y }) => `Moved selected node ${direction}. New position, x: ${x}, y: ${y}`,\n    'edge.a11yDescription.default': 'Press enter or space to select an edge. You can then press delete to remove it or escape to cancel.',\n    // Control elements\n    'controls.ariaLabel': 'Control Panel',\n    'controls.zoomIn.ariaLabel': 'Zoom In',\n    'controls.zoomOut.ariaLabel': 'Zoom Out',\n    'controls.fitView.ariaLabel': 'Fit View',\n    'controls.interactive.ariaLabel': 'Toggle Interactivity',\n    // Mini map\n    'minimap.ariaLabel': 'Mini Map',\n    // Handle\n    'handle.ariaLabel': 'Handle',\n};\n\n/**\n * The `ConnectionMode` is used to set the mode of connection between nodes.\n * The `Strict` mode is the default one and only allows source to target edges.\n * `Loose` mode allows source to source and target to target edges as well.\n *\n * @public\n */\nvar ConnectionMode;\n(function (ConnectionMode) {\n    ConnectionMode[\"Strict\"] = \"strict\";\n    ConnectionMode[\"Loose\"] = \"loose\";\n})(ConnectionMode || (ConnectionMode = {}));\n/**\n * This enum is used to set the different modes of panning the viewport when the\n * user scrolls. The `Free` mode allows the user to pan in any direction by scrolling\n * with a device like a trackpad. The `Vertical` and `Horizontal` modes restrict\n * scroll panning to only the vertical or horizontal axis, respectively.\n *\n * @public\n */\nvar PanOnScrollMode;\n(function (PanOnScrollMode) {\n    PanOnScrollMode[\"Free\"] = \"free\";\n    PanOnScrollMode[\"Vertical\"] = \"vertical\";\n    PanOnScrollMode[\"Horizontal\"] = \"horizontal\";\n})(PanOnScrollMode || (PanOnScrollMode = {}));\nvar SelectionMode;\n(function (SelectionMode) {\n    SelectionMode[\"Partial\"] = \"partial\";\n    SelectionMode[\"Full\"] = \"full\";\n})(SelectionMode || (SelectionMode = {}));\nconst initialConnection = {\n    inProgress: false,\n    isValid: null,\n    from: null,\n    fromHandle: null,\n    fromPosition: null,\n    fromNode: null,\n    to: null,\n    toHandle: null,\n    toPosition: null,\n    toNode: null,\n};\n\n/**\n * If you set the `connectionLineType` prop on your [`<ReactFlow />`](/api-reference/react-flow#connection-connectionLineType)\n *component, it will dictate the style of connection line rendered when creating\n *new edges.\n *\n * @public\n *\n * @remarks If you choose to render a custom connection line component, this value will be\n *passed to your component as part of its [`ConnectionLineComponentProps`](/api-reference/types/connection-line-component-props).\n */\nvar ConnectionLineType;\n(function (ConnectionLineType) {\n    ConnectionLineType[\"Bezier\"] = \"default\";\n    ConnectionLineType[\"Straight\"] = \"straight\";\n    ConnectionLineType[\"Step\"] = \"step\";\n    ConnectionLineType[\"SmoothStep\"] = \"smoothstep\";\n    ConnectionLineType[\"SimpleBezier\"] = \"simplebezier\";\n})(ConnectionLineType || (ConnectionLineType = {}));\n/**\n * Edges may optionally have a marker on either end. The MarkerType type enumerates\n * the options available to you when configuring a given marker.\n *\n * @public\n */\nvar MarkerType;\n(function (MarkerType) {\n    MarkerType[\"Arrow\"] = \"arrow\";\n    MarkerType[\"ArrowClosed\"] = \"arrowclosed\";\n})(MarkerType || (MarkerType = {}));\n\n/**\n * While [`PanelPosition`](/api-reference/types/panel-position) can be used to place a\n * component in the corners of a container, the `Position` enum is less precise and used\n * primarily in relation to edges and handles.\n *\n * @public\n */\nvar Position;\n(function (Position) {\n    Position[\"Left\"] = \"left\";\n    Position[\"Top\"] = \"top\";\n    Position[\"Right\"] = \"right\";\n    Position[\"Bottom\"] = \"bottom\";\n})(Position || (Position = {}));\nconst oppositePosition = {\n    [Position.Left]: Position.Right,\n    [Position.Right]: Position.Left,\n    [Position.Top]: Position.Bottom,\n    [Position.Bottom]: Position.Top,\n};\n\n/**\n * @internal\n */\nfunction areConnectionMapsEqual(a, b) {\n    if (!a && !b) {\n        return true;\n    }\n    if (!a || !b || a.size !== b.size) {\n        return false;\n    }\n    if (!a.size && !b.size) {\n        return true;\n    }\n    for (const key of a.keys()) {\n        if (!b.has(key)) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * We call the callback for all connections in a that are not in b\n *\n * @internal\n */\nfunction handleConnectionChange(a, b, cb) {\n    if (!cb) {\n        return;\n    }\n    const diff = [];\n    a.forEach((connection, key) => {\n        if (!b?.has(key)) {\n            diff.push(connection);\n        }\n    });\n    if (diff.length) {\n        cb(diff);\n    }\n}\nfunction getConnectionStatus(isValid) {\n    return isValid === null ? null : isValid ? 'valid' : 'invalid';\n}\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n/**\n * Test whether an object is usable as an Edge\n * @public\n * @remarks In TypeScript this is a type guard that will narrow the type of whatever you pass in to Edge if it returns true\n * @param element - The element to test\n * @returns A boolean indicating whether the element is an Edge\n */\nconst isEdgeBase = (element) => 'id' in element && 'source' in element && 'target' in element;\n/**\n * Test whether an object is usable as a Node\n * @public\n * @remarks In TypeScript this is a type guard that will narrow the type of whatever you pass in to Node if it returns true\n * @param element - The element to test\n * @returns A boolean indicating whether the element is an Node\n */\nconst isNodeBase = (element) => 'id' in element && 'position' in element && !('source' in element) && !('target' in element);\nconst isInternalNodeBase = (element) => 'id' in element && 'internals' in element && !('source' in element) && !('target' in element);\n/**\n * This util is used to tell you what nodes, if any, are connected to the given node\n * as the _target_ of an edge.\n * @public\n * @param node - The node to get the connected nodes from.\n * @param nodes - The array of all nodes.\n * @param edges - The array of all edges.\n * @returns An array of nodes that are connected over edges where the source is the given node.\n *\n * @example\n * ```ts\n *import { getOutgoers } from '@xyflow/react';\n *\n *const nodes = [];\n *const edges = [];\n *\n *const outgoers = getOutgoers(\n *  { id: '1', position: { x: 0, y: 0 }, data: { label: 'node' } },\n *  nodes,\n *  edges,\n *);\n *```\n */\nconst getOutgoers = (node, nodes, edges) => {\n    if (!node.id) {\n        return [];\n    }\n    const outgoerIds = new Set();\n    edges.forEach((edge) => {\n        if (edge.source === node.id) {\n            outgoerIds.add(edge.target);\n        }\n    });\n    return nodes.filter((n) => outgoerIds.has(n.id));\n};\n/**\n * This util is used to tell you what nodes, if any, are connected to the given node\n * as the _source_ of an edge.\n * @public\n * @param node - The node to get the connected nodes from.\n * @param nodes - The array of all nodes.\n * @param edges - The array of all edges.\n * @returns An array of nodes that are connected over edges where the target is the given node.\n *\n * @example\n * ```ts\n *import { getIncomers } from '@xyflow/react';\n *\n *const nodes = [];\n *const edges = [];\n *\n *const incomers = getIncomers(\n *  { id: '1', position: { x: 0, y: 0 }, data: { label: 'node' } },\n *  nodes,\n *  edges,\n *);\n *```\n */\nconst getIncomers = (node, nodes, edges) => {\n    if (!node.id) {\n        return [];\n    }\n    const incomersIds = new Set();\n    edges.forEach((edge) => {\n        if (edge.target === node.id) {\n            incomersIds.add(edge.source);\n        }\n    });\n    return nodes.filter((n) => incomersIds.has(n.id));\n};\nconst getNodePositionWithOrigin = (node, nodeOrigin = [0, 0]) => {\n    const { width, height } = getNodeDimensions(node);\n    const origin = node.origin ?? nodeOrigin;\n    const offsetX = width * origin[0];\n    const offsetY = height * origin[1];\n    return {\n        x: node.position.x - offsetX,\n        y: node.position.y - offsetY,\n    };\n};\n/**\n * Returns the bounding box that contains all the given nodes in an array. This can\n * be useful when combined with [`getViewportForBounds`](/api-reference/utils/get-viewport-for-bounds)\n * to calculate the correct transform to fit the given nodes in a viewport.\n * @public\n * @remarks Useful when combined with {@link getViewportForBounds} to calculate the correct transform to fit the given nodes in a viewport.\n * @param nodes - Nodes to calculate the bounds for.\n * @returns Bounding box enclosing all nodes.\n *\n * @remarks This function was previously called `getRectOfNodes`\n *\n * @example\n * ```js\n *import { getNodesBounds } from '@xyflow/react';\n *\n *const nodes = [\n *  {\n *    id: 'a',\n *    position: { x: 0, y: 0 },\n *    data: { label: 'a' },\n *    width: 50,\n *    height: 25,\n *  },\n *  {\n *    id: 'b',\n *    position: { x: 100, y: 100 },\n *    data: { label: 'b' },\n *    width: 50,\n *    height: 25,\n *  },\n *];\n *\n *const bounds = getNodesBounds(nodes);\n *```\n */\nconst getNodesBounds = (nodes, params = { nodeOrigin: [0, 0] }) => {\n    if (process.env.NODE_ENV === 'development' && !params.nodeLookup) {\n        console.warn('Please use `getNodesBounds` from `useReactFlow`/`useSvelteFlow` hook to ensure correct values for sub flows. If not possible, you have to provide a nodeLookup to support sub flows.');\n    }\n    if (nodes.length === 0) {\n        return { x: 0, y: 0, width: 0, height: 0 };\n    }\n    const box = nodes.reduce((currBox, nodeOrId) => {\n        const isId = typeof nodeOrId === 'string';\n        let currentNode = !params.nodeLookup && !isId ? nodeOrId : undefined;\n        if (params.nodeLookup) {\n            currentNode = isId\n                ? params.nodeLookup.get(nodeOrId)\n                : !isInternalNodeBase(nodeOrId)\n                    ? params.nodeLookup.get(nodeOrId.id)\n                    : nodeOrId;\n        }\n        const nodeBox = currentNode ? nodeToBox(currentNode, params.nodeOrigin) : { x: 0, y: 0, x2: 0, y2: 0 };\n        return getBoundsOfBoxes(currBox, nodeBox);\n    }, { x: Infinity, y: Infinity, x2: -Infinity, y2: -Infinity });\n    return boxToRect(box);\n};\n/**\n * Determines a bounding box that contains all given nodes in an array\n * @internal\n */\nconst getInternalNodesBounds = (nodeLookup, params = {}) => {\n    if (nodeLookup.size === 0) {\n        return { x: 0, y: 0, width: 0, height: 0 };\n    }\n    let box = { x: Infinity, y: Infinity, x2: -Infinity, y2: -Infinity };\n    nodeLookup.forEach((node) => {\n        if (params.filter === undefined || params.filter(node)) {\n            const nodeBox = nodeToBox(node);\n            box = getBoundsOfBoxes(box, nodeBox);\n        }\n    });\n    return boxToRect(box);\n};\nconst getNodesInside = (nodes, rect, [tx, ty, tScale] = [0, 0, 1], partially = false, \n// set excludeNonSelectableNodes if you want to pay attention to the nodes \"selectable\" attribute\nexcludeNonSelectableNodes = false) => {\n    const paneRect = {\n        ...pointToRendererPoint(rect, [tx, ty, tScale]),\n        width: rect.width / tScale,\n        height: rect.height / tScale,\n    };\n    const visibleNodes = [];\n    for (const node of nodes.values()) {\n        const { measured, selectable = true, hidden = false } = node;\n        if ((excludeNonSelectableNodes && !selectable) || hidden) {\n            continue;\n        }\n        const width = measured.width ?? node.width ?? node.initialWidth ?? null;\n        const height = measured.height ?? node.height ?? node.initialHeight ?? null;\n        const overlappingArea = getOverlappingArea(paneRect, nodeToRect(node));\n        const area = (width ?? 0) * (height ?? 0);\n        const partiallyVisible = partially && overlappingArea > 0;\n        const forceInitialRender = !node.internals.handleBounds;\n        const isVisible = forceInitialRender || partiallyVisible || overlappingArea >= area;\n        if (isVisible || node.dragging) {\n            visibleNodes.push(node);\n        }\n    }\n    return visibleNodes;\n};\n/**\n * This utility filters an array of edges, keeping only those where either the source or target\n * node is present in the given array of nodes.\n * @public\n * @param nodes - Nodes you want to get the connected edges for.\n * @param edges - All edges.\n * @returns Array of edges that connect any of the given nodes with each other.\n *\n * @example\n * ```js\n *import { getConnectedEdges } from '@xyflow/react';\n *\n *const nodes = [\n *  { id: 'a', position: { x: 0, y: 0 } },\n *  { id: 'b', position: { x: 100, y: 0 } },\n *];\n *\n *const edges = [\n *  { id: 'a->c', source: 'a', target: 'c' },\n *  { id: 'c->d', source: 'c', target: 'd' },\n *];\n *\n *const connectedEdges = getConnectedEdges(nodes, edges);\n * // => [{ id: 'a->c', source: 'a', target: 'c' }]\n *```\n */\nconst getConnectedEdges = (nodes, edges) => {\n    const nodeIds = new Set();\n    nodes.forEach((node) => {\n        nodeIds.add(node.id);\n    });\n    return edges.filter((edge) => nodeIds.has(edge.source) || nodeIds.has(edge.target));\n};\nfunction getFitViewNodes(nodeLookup, options) {\n    const fitViewNodes = new Map();\n    const optionNodeIds = options?.nodes ? new Set(options.nodes.map((node) => node.id)) : null;\n    nodeLookup.forEach((n) => {\n        const isVisible = n.measured.width && n.measured.height && (options?.includeHiddenNodes || !n.hidden);\n        if (isVisible && (!optionNodeIds || optionNodeIds.has(n.id))) {\n            fitViewNodes.set(n.id, n);\n        }\n    });\n    return fitViewNodes;\n}\nasync function fitViewport({ nodes, width, height, panZoom, minZoom, maxZoom }, options) {\n    if (nodes.size === 0) {\n        return Promise.resolve(true);\n    }\n    const nodesToFit = getFitViewNodes(nodes, options);\n    const bounds = getInternalNodesBounds(nodesToFit);\n    const viewport = getViewportForBounds(bounds, width, height, options?.minZoom ?? minZoom, options?.maxZoom ?? maxZoom, options?.padding ?? 0.1);\n    await panZoom.setViewport(viewport, {\n        duration: options?.duration,\n        ease: options?.ease,\n        interpolate: options?.interpolate,\n    });\n    return Promise.resolve(true);\n}\n/**\n * This function calculates the next position of a node, taking into account the node's extent, parent node, and origin.\n *\n * @internal\n * @returns position, positionAbsolute\n */\nfunction calculateNodePosition({ nodeId, nextPosition, nodeLookup, nodeOrigin = [0, 0], nodeExtent, onError, }) {\n    const node = nodeLookup.get(nodeId);\n    const parentNode = node.parentId ? nodeLookup.get(node.parentId) : undefined;\n    const { x: parentX, y: parentY } = parentNode ? parentNode.internals.positionAbsolute : { x: 0, y: 0 };\n    const origin = node.origin ?? nodeOrigin;\n    let extent = node.extent || nodeExtent;\n    if (node.extent === 'parent' && !node.expandParent) {\n        if (!parentNode) {\n            onError?.('005', errorMessages['error005']());\n        }\n        else {\n            const parentWidth = parentNode.measured.width;\n            const parentHeight = parentNode.measured.height;\n            if (parentWidth && parentHeight) {\n                extent = [\n                    [parentX, parentY],\n                    [parentX + parentWidth, parentY + parentHeight],\n                ];\n            }\n        }\n    }\n    else if (parentNode && isCoordinateExtent(node.extent)) {\n        extent = [\n            [node.extent[0][0] + parentX, node.extent[0][1] + parentY],\n            [node.extent[1][0] + parentX, node.extent[1][1] + parentY],\n        ];\n    }\n    const positionAbsolute = isCoordinateExtent(extent)\n        ? clampPosition(nextPosition, extent, node.measured)\n        : nextPosition;\n    if (node.measured.width === undefined || node.measured.height === undefined) {\n        onError?.('015', errorMessages['error015']());\n    }\n    return {\n        position: {\n            x: positionAbsolute.x - parentX + (node.measured.width ?? 0) * origin[0],\n            y: positionAbsolute.y - parentY + (node.measured.height ?? 0) * origin[1],\n        },\n        positionAbsolute,\n    };\n}\n/**\n * Pass in nodes & edges to delete, get arrays of nodes and edges that actually can be deleted\n * @internal\n * @param param.nodesToRemove - The nodes to remove\n * @param param.edgesToRemove - The edges to remove\n * @param param.nodes - All nodes\n * @param param.edges - All edges\n * @param param.onBeforeDelete - Callback to check which nodes and edges can be deleted\n * @returns nodes: nodes that can be deleted, edges: edges that can be deleted\n */\nasync function getElementsToRemove({ nodesToRemove = [], edgesToRemove = [], nodes, edges, onBeforeDelete, }) {\n    const nodeIds = new Set(nodesToRemove.map((node) => node.id));\n    const matchingNodes = [];\n    for (const node of nodes) {\n        if (node.deletable === false) {\n            continue;\n        }\n        const isIncluded = nodeIds.has(node.id);\n        const parentHit = !isIncluded && node.parentId && matchingNodes.find((n) => n.id === node.parentId);\n        if (isIncluded || parentHit) {\n            matchingNodes.push(node);\n        }\n    }\n    const edgeIds = new Set(edgesToRemove.map((edge) => edge.id));\n    const deletableEdges = edges.filter((edge) => edge.deletable !== false);\n    const connectedEdges = getConnectedEdges(matchingNodes, deletableEdges);\n    const matchingEdges = connectedEdges;\n    for (const edge of deletableEdges) {\n        const isIncluded = edgeIds.has(edge.id);\n        if (isIncluded && !matchingEdges.find((e) => e.id === edge.id)) {\n            matchingEdges.push(edge);\n        }\n    }\n    if (!onBeforeDelete) {\n        return {\n            edges: matchingEdges,\n            nodes: matchingNodes,\n        };\n    }\n    const onBeforeDeleteResult = await onBeforeDelete({\n        nodes: matchingNodes,\n        edges: matchingEdges,\n    });\n    if (typeof onBeforeDeleteResult === 'boolean') {\n        return onBeforeDeleteResult ? { edges: matchingEdges, nodes: matchingNodes } : { edges: [], nodes: [] };\n    }\n    return onBeforeDeleteResult;\n}\n\nconst clamp = (val, min = 0, max = 1) => Math.min(Math.max(val, min), max);\nconst clampPosition = (position = { x: 0, y: 0 }, extent, dimensions) => ({\n    x: clamp(position.x, extent[0][0], extent[1][0] - (dimensions?.width ?? 0)),\n    y: clamp(position.y, extent[0][1], extent[1][1] - (dimensions?.height ?? 0)),\n});\nfunction clampPositionToParent(childPosition, childDimensions, parent) {\n    const { width: parentWidth, height: parentHeight } = getNodeDimensions(parent);\n    const { x: parentX, y: parentY } = parent.internals.positionAbsolute;\n    return clampPosition(childPosition, [\n        [parentX, parentY],\n        [parentX + parentWidth, parentY + parentHeight],\n    ], childDimensions);\n}\n/**\n * Calculates the velocity of panning when the mouse is close to the edge of the canvas\n * @internal\n * @param value - One dimensional poition of the mouse (x or y)\n * @param min - Minimal position on canvas before panning starts\n * @param max - Maximal position on canvas before panning starts\n * @returns - A number between 0 and 1 that represents the velocity of panning\n */\nconst calcAutoPanVelocity = (value, min, max) => {\n    if (value < min) {\n        return clamp(Math.abs(value - min), 1, min) / min;\n    }\n    else if (value > max) {\n        return -clamp(Math.abs(value - max), 1, min) / min;\n    }\n    return 0;\n};\nconst calcAutoPan = (pos, bounds, speed = 15, distance = 40) => {\n    const xMovement = calcAutoPanVelocity(pos.x, distance, bounds.width - distance) * speed;\n    const yMovement = calcAutoPanVelocity(pos.y, distance, bounds.height - distance) * speed;\n    return [xMovement, yMovement];\n};\nconst getBoundsOfBoxes = (box1, box2) => ({\n    x: Math.min(box1.x, box2.x),\n    y: Math.min(box1.y, box2.y),\n    x2: Math.max(box1.x2, box2.x2),\n    y2: Math.max(box1.y2, box2.y2),\n});\nconst rectToBox = ({ x, y, width, height }) => ({\n    x,\n    y,\n    x2: x + width,\n    y2: y + height,\n});\nconst boxToRect = ({ x, y, x2, y2 }) => ({\n    x,\n    y,\n    width: x2 - x,\n    height: y2 - y,\n});\nconst nodeToRect = (node, nodeOrigin = [0, 0]) => {\n    const { x, y } = isInternalNodeBase(node)\n        ? node.internals.positionAbsolute\n        : getNodePositionWithOrigin(node, nodeOrigin);\n    return {\n        x,\n        y,\n        width: node.measured?.width ?? node.width ?? node.initialWidth ?? 0,\n        height: node.measured?.height ?? node.height ?? node.initialHeight ?? 0,\n    };\n};\nconst nodeToBox = (node, nodeOrigin = [0, 0]) => {\n    const { x, y } = isInternalNodeBase(node)\n        ? node.internals.positionAbsolute\n        : getNodePositionWithOrigin(node, nodeOrigin);\n    return {\n        x,\n        y,\n        x2: x + (node.measured?.width ?? node.width ?? node.initialWidth ?? 0),\n        y2: y + (node.measured?.height ?? node.height ?? node.initialHeight ?? 0),\n    };\n};\nconst getBoundsOfRects = (rect1, rect2) => boxToRect(getBoundsOfBoxes(rectToBox(rect1), rectToBox(rect2)));\nconst getOverlappingArea = (rectA, rectB) => {\n    const xOverlap = Math.max(0, Math.min(rectA.x + rectA.width, rectB.x + rectB.width) - Math.max(rectA.x, rectB.x));\n    const yOverlap = Math.max(0, Math.min(rectA.y + rectA.height, rectB.y + rectB.height) - Math.max(rectA.y, rectB.y));\n    return Math.ceil(xOverlap * yOverlap);\n};\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst isRectObject = (obj) => isNumeric(obj.width) && isNumeric(obj.height) && isNumeric(obj.x) && isNumeric(obj.y);\n/* eslint-disable-next-line @typescript-eslint/no-explicit-any */\nconst isNumeric = (n) => !isNaN(n) && isFinite(n);\n// used for a11y key board controls for nodes and edges\nconst devWarn = (id, message) => {\n    if (process.env.NODE_ENV === 'development') {\n        console.warn(`[React Flow]: ${message} Help: https://reactflow.dev/error#${id}`);\n    }\n};\nconst snapPosition = (position, snapGrid = [1, 1]) => {\n    return {\n        x: snapGrid[0] * Math.round(position.x / snapGrid[0]),\n        y: snapGrid[1] * Math.round(position.y / snapGrid[1]),\n    };\n};\nconst pointToRendererPoint = ({ x, y }, [tx, ty, tScale], snapToGrid = false, snapGrid = [1, 1]) => {\n    const position = {\n        x: (x - tx) / tScale,\n        y: (y - ty) / tScale,\n    };\n    return snapToGrid ? snapPosition(position, snapGrid) : position;\n};\nconst rendererPointToPoint = ({ x, y }, [tx, ty, tScale]) => {\n    return {\n        x: x * tScale + tx,\n        y: y * tScale + ty,\n    };\n};\n/**\n * Parses a single padding value to a number\n * @internal\n * @param padding - Padding to parse\n * @param viewport - Width or height of the viewport\n * @returns The padding in pixels\n */\nfunction parsePadding(padding, viewport) {\n    if (typeof padding === 'number') {\n        return Math.floor((viewport - viewport / (1 + padding)) * 0.5);\n    }\n    if (typeof padding === 'string' && padding.endsWith('px')) {\n        const paddingValue = parseFloat(padding);\n        if (!Number.isNaN(paddingValue)) {\n            return Math.floor(paddingValue);\n        }\n    }\n    if (typeof padding === 'string' && padding.endsWith('%')) {\n        const paddingValue = parseFloat(padding);\n        if (!Number.isNaN(paddingValue)) {\n            return Math.floor(viewport * paddingValue * 0.01);\n        }\n    }\n    console.error(`[React Flow] The padding value \"${padding}\" is invalid. Please provide a number or a string with a valid unit (px or %).`);\n    return 0;\n}\n/**\n * Parses the paddings to an object with top, right, bottom, left, x and y paddings\n * @internal\n * @param padding - Padding to parse\n * @param width - Width of the viewport\n * @param height - Height of the viewport\n * @returns An object with the paddings in pixels\n */\nfunction parsePaddings(padding, width, height) {\n    if (typeof padding === 'string' || typeof padding === 'number') {\n        const paddingY = parsePadding(padding, height);\n        const paddingX = parsePadding(padding, width);\n        return {\n            top: paddingY,\n            right: paddingX,\n            bottom: paddingY,\n            left: paddingX,\n            x: paddingX * 2,\n            y: paddingY * 2,\n        };\n    }\n    if (typeof padding === 'object') {\n        const top = parsePadding(padding.top ?? padding.y ?? 0, height);\n        const bottom = parsePadding(padding.bottom ?? padding.y ?? 0, height);\n        const left = parsePadding(padding.left ?? padding.x ?? 0, width);\n        const right = parsePadding(padding.right ?? padding.x ?? 0, width);\n        return { top, right, bottom, left, x: left + right, y: top + bottom };\n    }\n    return { top: 0, right: 0, bottom: 0, left: 0, x: 0, y: 0 };\n}\n/**\n * Calculates the resulting paddings if the new viewport is applied\n * @internal\n * @param bounds - Bounds to fit inside viewport\n * @param x - X position of the viewport\n * @param y - Y position of the viewport\n * @param zoom - Zoom level of the viewport\n * @param width - Width of the viewport\n * @param height - Height of the viewport\n * @returns An object with the minimum padding required to fit the bounds inside the viewport\n */\nfunction calculateAppliedPaddings(bounds, x, y, zoom, width, height) {\n    const { x: left, y: top } = rendererPointToPoint(bounds, [x, y, zoom]);\n    const { x: boundRight, y: boundBottom } = rendererPointToPoint({ x: bounds.x + bounds.width, y: bounds.y + bounds.height }, [x, y, zoom]);\n    const right = width - boundRight;\n    const bottom = height - boundBottom;\n    return {\n        left: Math.floor(left),\n        top: Math.floor(top),\n        right: Math.floor(right),\n        bottom: Math.floor(bottom),\n    };\n}\n/**\n * Returns a viewport that encloses the given bounds with padding.\n * @public\n * @remarks You can determine bounds of nodes with {@link getNodesBounds} and {@link getBoundsOfRects}\n * @param bounds - Bounds to fit inside viewport.\n * @param width - Width of the viewport.\n * @param height  - Height of the viewport.\n * @param minZoom - Minimum zoom level of the resulting viewport.\n * @param maxZoom - Maximum zoom level of the resulting viewport.\n * @param padding - Padding around the bounds.\n * @returns A transformed {@link Viewport} that encloses the given bounds which you can pass to e.g. {@link setViewport}.\n * @example\n * const { x, y, zoom } = getViewportForBounds(\n * { x: 0, y: 0, width: 100, height: 100},\n * 1200, 800, 0.5, 2);\n */\nconst getViewportForBounds = (bounds, width, height, minZoom, maxZoom, padding) => {\n    // First we resolve all the paddings to actual pixel values\n    const p = parsePaddings(padding, width, height);\n    const xZoom = (width - p.x) / bounds.width;\n    const yZoom = (height - p.y) / bounds.height;\n    // We calculate the new x, y, zoom for a centered view\n    const zoom = Math.min(xZoom, yZoom);\n    const clampedZoom = clamp(zoom, minZoom, maxZoom);\n    const boundsCenterX = bounds.x + bounds.width / 2;\n    const boundsCenterY = bounds.y + bounds.height / 2;\n    const x = width / 2 - boundsCenterX * clampedZoom;\n    const y = height / 2 - boundsCenterY * clampedZoom;\n    // Then we calculate the minimum padding, to respect asymmetric paddings\n    const newPadding = calculateAppliedPaddings(bounds, x, y, clampedZoom, width, height);\n    // We only want to have an offset if the newPadding is smaller than the required padding\n    const offset = {\n        left: Math.min(newPadding.left - p.left, 0),\n        top: Math.min(newPadding.top - p.top, 0),\n        right: Math.min(newPadding.right - p.right, 0),\n        bottom: Math.min(newPadding.bottom - p.bottom, 0),\n    };\n    return {\n        x: x - offset.left + offset.right,\n        y: y - offset.top + offset.bottom,\n        zoom: clampedZoom,\n    };\n};\nconst isMacOs = () => typeof navigator !== 'undefined' && navigator?.userAgent?.indexOf('Mac') >= 0;\nfunction isCoordinateExtent(extent) {\n    return extent !== undefined && extent !== null && extent !== 'parent';\n}\nfunction getNodeDimensions(node) {\n    return {\n        width: node.measured?.width ?? node.width ?? node.initialWidth ?? 0,\n        height: node.measured?.height ?? node.height ?? node.initialHeight ?? 0,\n    };\n}\nfunction nodeHasDimensions(node) {\n    return ((node.measured?.width ?? node.width ?? node.initialWidth) !== undefined &&\n        (node.measured?.height ?? node.height ?? node.initialHeight) !== undefined);\n}\n/**\n * Convert child position to aboslute position\n *\n * @internal\n * @param position\n * @param parentId\n * @param nodeLookup\n * @param nodeOrigin\n * @returns an internal node with an absolute position\n */\nfunction evaluateAbsolutePosition(position, dimensions = { width: 0, height: 0 }, parentId, nodeLookup, nodeOrigin) {\n    const positionAbsolute = { ...position };\n    const parent = nodeLookup.get(parentId);\n    if (parent) {\n        const origin = parent.origin || nodeOrigin;\n        positionAbsolute.x += parent.internals.positionAbsolute.x - (dimensions.width ?? 0) * origin[0];\n        positionAbsolute.y += parent.internals.positionAbsolute.y - (dimensions.height ?? 0) * origin[1];\n    }\n    return positionAbsolute;\n}\nfunction areSetsEqual(a, b) {\n    if (a.size !== b.size) {\n        return false;\n    }\n    for (const item of a) {\n        if (!b.has(item)) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Polyfill for Promise.withResolvers until we can use it in all browsers\n * @internal\n */\nfunction withResolvers() {\n    let resolve;\n    let reject;\n    const promise = new Promise((res, rej) => {\n        resolve = res;\n        reject = rej;\n    });\n    return { promise, resolve, reject };\n}\nfunction mergeAriaLabelConfig(partial) {\n    return { ...defaultAriaLabelConfig, ...(partial || {}) };\n}\n\nfunction getPointerPosition(event, { snapGrid = [0, 0], snapToGrid = false, transform, containerBounds }) {\n    const { x, y } = getEventPosition(event);\n    const pointerPos = pointToRendererPoint({ x: x - (containerBounds?.left ?? 0), y: y - (containerBounds?.top ?? 0) }, transform);\n    const { x: xSnapped, y: ySnapped } = snapToGrid ? snapPosition(pointerPos, snapGrid) : pointerPos;\n    // we need the snapped position in order to be able to skip unnecessary drag events\n    return {\n        xSnapped,\n        ySnapped,\n        ...pointerPos,\n    };\n}\nconst getDimensions = (node) => ({\n    width: node.offsetWidth,\n    height: node.offsetHeight,\n});\nconst getHostForElement = (element) => element?.getRootNode?.() || window?.document;\nconst inputTags = ['INPUT', 'SELECT', 'TEXTAREA'];\nfunction isInputDOMNode(event) {\n    // using composed path for handling shadow dom\n    const target = (event.composedPath?.()?.[0] || event.target);\n    if (target?.nodeType !== 1 /* Node.ELEMENT_NODE */)\n        return false;\n    const isInput = inputTags.includes(target.nodeName) || target.hasAttribute('contenteditable');\n    // when an input field is focused we don't want to trigger deletion or movement of nodes\n    return isInput || !!target.closest('.nokey');\n}\nconst isMouseEvent = (event) => 'clientX' in event;\nconst getEventPosition = (event, bounds) => {\n    const isMouse = isMouseEvent(event);\n    const evtX = isMouse ? event.clientX : event.touches?.[0].clientX;\n    const evtY = isMouse ? event.clientY : event.touches?.[0].clientY;\n    return {\n        x: evtX - (bounds?.left ?? 0),\n        y: evtY - (bounds?.top ?? 0),\n    };\n};\n/*\n * The handle bounds are calculated relative to the node element.\n * We store them in the internals object of the node in order to avoid\n * unnecessary recalculations.\n */\nconst getHandleBounds = (type, nodeElement, nodeBounds, zoom, nodeId) => {\n    const handles = nodeElement.querySelectorAll(`.${type}`);\n    if (!handles || !handles.length) {\n        return null;\n    }\n    return Array.from(handles).map((handle) => {\n        const handleBounds = handle.getBoundingClientRect();\n        return {\n            id: handle.getAttribute('data-handleid'),\n            type,\n            nodeId,\n            position: handle.getAttribute('data-handlepos'),\n            x: (handleBounds.left - nodeBounds.left) / zoom,\n            y: (handleBounds.top - nodeBounds.top) / zoom,\n            ...getDimensions(handle),\n        };\n    });\n};\n\nfunction getBezierEdgeCenter({ sourceX, sourceY, targetX, targetY, sourceControlX, sourceControlY, targetControlX, targetControlY, }) {\n    /*\n     * cubic bezier t=0.5 mid point, not the actual mid point, but easy to calculate\n     * https://stackoverflow.com/questions/67516101/how-to-find-distance-mid-point-of-bezier-curve\n     */\n    const centerX = sourceX * 0.125 + sourceControlX * 0.375 + targetControlX * 0.375 + targetX * 0.125;\n    const centerY = sourceY * 0.125 + sourceControlY * 0.375 + targetControlY * 0.375 + targetY * 0.125;\n    const offsetX = Math.abs(centerX - sourceX);\n    const offsetY = Math.abs(centerY - sourceY);\n    return [centerX, centerY, offsetX, offsetY];\n}\nfunction calculateControlOffset(distance, curvature) {\n    if (distance >= 0) {\n        return 0.5 * distance;\n    }\n    return curvature * 25 * Math.sqrt(-distance);\n}\nfunction getControlWithCurvature({ pos, x1, y1, x2, y2, c }) {\n    switch (pos) {\n        case Position.Left:\n            return [x1 - calculateControlOffset(x1 - x2, c), y1];\n        case Position.Right:\n            return [x1 + calculateControlOffset(x2 - x1, c), y1];\n        case Position.Top:\n            return [x1, y1 - calculateControlOffset(y1 - y2, c)];\n        case Position.Bottom:\n            return [x1, y1 + calculateControlOffset(y2 - y1, c)];\n    }\n}\n/**\n * The `getBezierPath` util returns everything you need to render a bezier edge\n *between two nodes.\n * @public\n * @returns A path string you can use in an SVG, the `labelX` and `labelY` position (center of path)\n * and `offsetX`, `offsetY` between source handle and label.\n * - `path`: the path to use in an SVG `<path>` element.\n * - `labelX`: the `x` position you can use to render a label for this edge.\n * - `labelY`: the `y` position you can use to render a label for this edge.\n * - `offsetX`: the absolute difference between the source `x` position and the `x` position of the\n * middle of this path.\n * - `offsetY`: the absolute difference between the source `y` position and the `y` position of the\n * middle of this path.\n * @example\n * ```js\n *  const source = { x: 0, y: 20 };\n *  const target = { x: 150, y: 100 };\n *\n *  const [path, labelX, labelY, offsetX, offsetY] = getBezierPath({\n *    sourceX: source.x,\n *    sourceY: source.y,\n *    sourcePosition: Position.Right,\n *    targetX: target.x,\n *    targetY: target.y,\n *    targetPosition: Position.Left,\n *});\n *```\n *\n * @remarks This function returns a tuple (aka a fixed-size array) to make it easier to\n *work with multiple edge paths at once.\n */\nfunction getBezierPath({ sourceX, sourceY, sourcePosition = Position.Bottom, targetX, targetY, targetPosition = Position.Top, curvature = 0.25, }) {\n    const [sourceControlX, sourceControlY] = getControlWithCurvature({\n        pos: sourcePosition,\n        x1: sourceX,\n        y1: sourceY,\n        x2: targetX,\n        y2: targetY,\n        c: curvature,\n    });\n    const [targetControlX, targetControlY] = getControlWithCurvature({\n        pos: targetPosition,\n        x1: targetX,\n        y1: targetY,\n        x2: sourceX,\n        y2: sourceY,\n        c: curvature,\n    });\n    const [labelX, labelY, offsetX, offsetY] = getBezierEdgeCenter({\n        sourceX,\n        sourceY,\n        targetX,\n        targetY,\n        sourceControlX,\n        sourceControlY,\n        targetControlX,\n        targetControlY,\n    });\n    return [\n        `M${sourceX},${sourceY} C${sourceControlX},${sourceControlY} ${targetControlX},${targetControlY} ${targetX},${targetY}`,\n        labelX,\n        labelY,\n        offsetX,\n        offsetY,\n    ];\n}\n\n// this is used for straight edges and simple smoothstep edges (LTR, RTL, BTT, TTB)\nfunction getEdgeCenter({ sourceX, sourceY, targetX, targetY, }) {\n    const xOffset = Math.abs(targetX - sourceX) / 2;\n    const centerX = targetX < sourceX ? targetX + xOffset : targetX - xOffset;\n    const yOffset = Math.abs(targetY - sourceY) / 2;\n    const centerY = targetY < sourceY ? targetY + yOffset : targetY - yOffset;\n    return [centerX, centerY, xOffset, yOffset];\n}\n/**\n * Returns the z-index for an edge based on the node it connects and whether it is selected.\n * By default, edges are rendered below nodes. This behaviour is different for edges that are\n * connected to nodes with a parent, as they are rendered above the parent node.\n */\nfunction getElevatedEdgeZIndex({ sourceNode, targetNode, selected = false, zIndex, elevateOnSelect = false, }) {\n    if (zIndex !== undefined) {\n        return zIndex;\n    }\n    const edgeZ = elevateOnSelect && selected ? 1000 : 0;\n    const nodeZ = Math.max(sourceNode.parentId ? sourceNode.internals.z : 0, targetNode.parentId ? targetNode.internals.z : 0);\n    return edgeZ + nodeZ;\n}\nfunction isEdgeVisible({ sourceNode, targetNode, width, height, transform }) {\n    const edgeBox = getBoundsOfBoxes(nodeToBox(sourceNode), nodeToBox(targetNode));\n    if (edgeBox.x === edgeBox.x2) {\n        edgeBox.x2 += 1;\n    }\n    if (edgeBox.y === edgeBox.y2) {\n        edgeBox.y2 += 1;\n    }\n    const viewRect = {\n        x: -transform[0] / transform[2],\n        y: -transform[1] / transform[2],\n        width: width / transform[2],\n        height: height / transform[2],\n    };\n    return getOverlappingArea(viewRect, boxToRect(edgeBox)) > 0;\n}\nconst getEdgeId = ({ source, sourceHandle, target, targetHandle }) => `xy-edge__${source}${sourceHandle || ''}-${target}${targetHandle || ''}`;\nconst connectionExists = (edge, edges) => {\n    return edges.some((el) => el.source === edge.source &&\n        el.target === edge.target &&\n        (el.sourceHandle === edge.sourceHandle || (!el.sourceHandle && !edge.sourceHandle)) &&\n        (el.targetHandle === edge.targetHandle || (!el.targetHandle && !edge.targetHandle)));\n};\n/**\n * This util is a convenience function to add a new Edge to an array of edges. It also performs some validation to make sure you don't add an invalid edge or duplicate an existing one.\n * @public\n * @param edgeParams - Either an `Edge` or a `Connection` you want to add.\n * @param edges - The array of all current edges.\n * @returns A new array of edges with the new edge added.\n *\n * @remarks If an edge with the same `target` and `source` already exists (and the same\n *`targetHandle` and `sourceHandle` if those are set), then this util won't add\n *a new edge even if the `id` property is different.\n *\n */\nconst addEdge = (edgeParams, edges) => {\n    if (!edgeParams.source || !edgeParams.target) {\n        devWarn('006', errorMessages['error006']());\n        return edges;\n    }\n    let edge;\n    if (isEdgeBase(edgeParams)) {\n        edge = { ...edgeParams };\n    }\n    else {\n        edge = {\n            ...edgeParams,\n            id: getEdgeId(edgeParams),\n        };\n    }\n    if (connectionExists(edge, edges)) {\n        return edges;\n    }\n    if (edge.sourceHandle === null) {\n        delete edge.sourceHandle;\n    }\n    if (edge.targetHandle === null) {\n        delete edge.targetHandle;\n    }\n    return edges.concat(edge);\n};\n/**\n * A handy utility to update an existing [`Edge`](/api-reference/types/edge) with new properties.\n *This searches your edge array for an edge with a matching `id` and updates its\n *properties with the connection you provide.\n * @public\n * @param oldEdge - The edge you want to update.\n * @param newConnection - The new connection you want to update the edge with.\n * @param edges - The array of all current edges.\n * @returns The updated edges array.\n *\n * @example\n * ```js\n *const onReconnect = useCallback(\n *  (oldEdge: Edge, newConnection: Connection) => setEdges((els) => reconnectEdge(oldEdge, newConnection, els)),[]);\n *```\n */\nconst reconnectEdge = (oldEdge, newConnection, edges, options = { shouldReplaceId: true }) => {\n    const { id: oldEdgeId, ...rest } = oldEdge;\n    if (!newConnection.source || !newConnection.target) {\n        devWarn('006', errorMessages['error006']());\n        return edges;\n    }\n    const foundEdge = edges.find((e) => e.id === oldEdge.id);\n    if (!foundEdge) {\n        devWarn('007', errorMessages['error007'](oldEdgeId));\n        return edges;\n    }\n    // Remove old edge and create the new edge with parameters of old edge.\n    const edge = {\n        ...rest,\n        id: options.shouldReplaceId ? getEdgeId(newConnection) : oldEdgeId,\n        source: newConnection.source,\n        target: newConnection.target,\n        sourceHandle: newConnection.sourceHandle,\n        targetHandle: newConnection.targetHandle,\n    };\n    return edges.filter((e) => e.id !== oldEdgeId).concat(edge);\n};\n\n/**\n * Calculates the straight line path between two points.\n * @public\n * @returns A path string you can use in an SVG, the `labelX` and `labelY` position (center of path)\n * and `offsetX`, `offsetY` between source handle and label.\n *\n * - `path`: the path to use in an SVG `<path>` element.\n * - `labelX`: the `x` position you can use to render a label for this edge.\n * - `labelY`: the `y` position you can use to render a label for this edge.\n * - `offsetX`: the absolute difference between the source `x` position and the `x` position of the\n * middle of this path.\n * - `offsetY`: the absolute difference between the source `y` position and the `y` position of the\n * middle of this path.\n * @example\n * ```js\n *  const source = { x: 0, y: 20 };\n *  const target = { x: 150, y: 100 };\n *\n *  const [path, labelX, labelY, offsetX, offsetY] = getStraightPath({\n *    sourceX: source.x,\n *    sourceY: source.y,\n *    sourcePosition: Position.Right,\n *    targetX: target.x,\n *    targetY: target.y,\n *    targetPosition: Position.Left,\n *  });\n * ```\n * @remarks This function returns a tuple (aka a fixed-size array) to make it easier to work with multiple edge paths at once.\n */\nfunction getStraightPath({ sourceX, sourceY, targetX, targetY, }) {\n    const [labelX, labelY, offsetX, offsetY] = getEdgeCenter({\n        sourceX,\n        sourceY,\n        targetX,\n        targetY,\n    });\n    return [`M ${sourceX},${sourceY}L ${targetX},${targetY}`, labelX, labelY, offsetX, offsetY];\n}\n\nconst handleDirections = {\n    [Position.Left]: { x: -1, y: 0 },\n    [Position.Right]: { x: 1, y: 0 },\n    [Position.Top]: { x: 0, y: -1 },\n    [Position.Bottom]: { x: 0, y: 1 },\n};\nconst getDirection = ({ source, sourcePosition = Position.Bottom, target, }) => {\n    if (sourcePosition === Position.Left || sourcePosition === Position.Right) {\n        return source.x < target.x ? { x: 1, y: 0 } : { x: -1, y: 0 };\n    }\n    return source.y < target.y ? { x: 0, y: 1 } : { x: 0, y: -1 };\n};\nconst distance = (a, b) => Math.sqrt(Math.pow(b.x - a.x, 2) + Math.pow(b.y - a.y, 2));\n/*\n * With this function we try to mimic an orthogonal edge routing behaviour\n * It's not as good as a real orthogonal edge routing, but it's faster and good enough as a default for step and smooth step edges\n */\nfunction getPoints({ source, sourcePosition = Position.Bottom, target, targetPosition = Position.Top, center, offset, stepPosition, }) {\n    const sourceDir = handleDirections[sourcePosition];\n    const targetDir = handleDirections[targetPosition];\n    const sourceGapped = { x: source.x + sourceDir.x * offset, y: source.y + sourceDir.y * offset };\n    const targetGapped = { x: target.x + targetDir.x * offset, y: target.y + targetDir.y * offset };\n    const dir = getDirection({\n        source: sourceGapped,\n        sourcePosition,\n        target: targetGapped,\n    });\n    const dirAccessor = dir.x !== 0 ? 'x' : 'y';\n    const currDir = dir[dirAccessor];\n    let points = [];\n    let centerX, centerY;\n    const sourceGapOffset = { x: 0, y: 0 };\n    const targetGapOffset = { x: 0, y: 0 };\n    const [, , defaultOffsetX, defaultOffsetY] = getEdgeCenter({\n        sourceX: source.x,\n        sourceY: source.y,\n        targetX: target.x,\n        targetY: target.y,\n    });\n    // opposite handle positions, default case\n    if (sourceDir[dirAccessor] * targetDir[dirAccessor] === -1) {\n        if (dirAccessor === 'x') {\n            // Primary direction is horizontal, so stepPosition affects X coordinate\n            centerX = center.x ?? (sourceGapped.x + (targetGapped.x - sourceGapped.x) * stepPosition);\n            centerY = center.y ?? (sourceGapped.y + targetGapped.y) / 2;\n        }\n        else {\n            // Primary direction is vertical, so stepPosition affects Y coordinate  \n            centerX = center.x ?? (sourceGapped.x + targetGapped.x) / 2;\n            centerY = center.y ?? (sourceGapped.y + (targetGapped.y - sourceGapped.y) * stepPosition);\n        }\n        /*\n         *    --->\n         *    |\n         * >---\n         */\n        const verticalSplit = [\n            { x: centerX, y: sourceGapped.y },\n            { x: centerX, y: targetGapped.y },\n        ];\n        /*\n         *    |\n         *  ---\n         *  |\n         */\n        const horizontalSplit = [\n            { x: sourceGapped.x, y: centerY },\n            { x: targetGapped.x, y: centerY },\n        ];\n        if (sourceDir[dirAccessor] === currDir) {\n            points = dirAccessor === 'x' ? verticalSplit : horizontalSplit;\n        }\n        else {\n            points = dirAccessor === 'x' ? horizontalSplit : verticalSplit;\n        }\n    }\n    else {\n        // sourceTarget means we take x from source and y from target, targetSource is the opposite\n        const sourceTarget = [{ x: sourceGapped.x, y: targetGapped.y }];\n        const targetSource = [{ x: targetGapped.x, y: sourceGapped.y }];\n        // this handles edges with same handle positions\n        if (dirAccessor === 'x') {\n            points = sourceDir.x === currDir ? targetSource : sourceTarget;\n        }\n        else {\n            points = sourceDir.y === currDir ? sourceTarget : targetSource;\n        }\n        if (sourcePosition === targetPosition) {\n            const diff = Math.abs(source[dirAccessor] - target[dirAccessor]);\n            // if an edge goes from right to right for example (sourcePosition === targetPosition) and the distance between source.x and target.x is less than the offset, the added point and the gapped source/target will overlap. This leads to a weird edge path. To avoid this we add a gapOffset to the source/target\n            if (diff <= offset) {\n                const gapOffset = Math.min(offset - 1, offset - diff);\n                if (sourceDir[dirAccessor] === currDir) {\n                    sourceGapOffset[dirAccessor] = (sourceGapped[dirAccessor] > source[dirAccessor] ? -1 : 1) * gapOffset;\n                }\n                else {\n                    targetGapOffset[dirAccessor] = (targetGapped[dirAccessor] > target[dirAccessor] ? -1 : 1) * gapOffset;\n                }\n            }\n        }\n        // these are conditions for handling mixed handle positions like Right -> Bottom for example\n        if (sourcePosition !== targetPosition) {\n            const dirAccessorOpposite = dirAccessor === 'x' ? 'y' : 'x';\n            const isSameDir = sourceDir[dirAccessor] === targetDir[dirAccessorOpposite];\n            const sourceGtTargetOppo = sourceGapped[dirAccessorOpposite] > targetGapped[dirAccessorOpposite];\n            const sourceLtTargetOppo = sourceGapped[dirAccessorOpposite] < targetGapped[dirAccessorOpposite];\n            const flipSourceTarget = (sourceDir[dirAccessor] === 1 && ((!isSameDir && sourceGtTargetOppo) || (isSameDir && sourceLtTargetOppo))) ||\n                (sourceDir[dirAccessor] !== 1 && ((!isSameDir && sourceLtTargetOppo) || (isSameDir && sourceGtTargetOppo)));\n            if (flipSourceTarget) {\n                points = dirAccessor === 'x' ? sourceTarget : targetSource;\n            }\n        }\n        const sourceGapPoint = { x: sourceGapped.x + sourceGapOffset.x, y: sourceGapped.y + sourceGapOffset.y };\n        const targetGapPoint = { x: targetGapped.x + targetGapOffset.x, y: targetGapped.y + targetGapOffset.y };\n        const maxXDistance = Math.max(Math.abs(sourceGapPoint.x - points[0].x), Math.abs(targetGapPoint.x - points[0].x));\n        const maxYDistance = Math.max(Math.abs(sourceGapPoint.y - points[0].y), Math.abs(targetGapPoint.y - points[0].y));\n        // we want to place the label on the longest segment of the edge\n        if (maxXDistance >= maxYDistance) {\n            centerX = (sourceGapPoint.x + targetGapPoint.x) / 2;\n            centerY = points[0].y;\n        }\n        else {\n            centerX = points[0].x;\n            centerY = (sourceGapPoint.y + targetGapPoint.y) / 2;\n        }\n    }\n    const pathPoints = [\n        source,\n        { x: sourceGapped.x + sourceGapOffset.x, y: sourceGapped.y + sourceGapOffset.y },\n        ...points,\n        { x: targetGapped.x + targetGapOffset.x, y: targetGapped.y + targetGapOffset.y },\n        target,\n    ];\n    return [pathPoints, centerX, centerY, defaultOffsetX, defaultOffsetY];\n}\nfunction getBend(a, b, c, size) {\n    const bendSize = Math.min(distance(a, b) / 2, distance(b, c) / 2, size);\n    const { x, y } = b;\n    // no bend\n    if ((a.x === x && x === c.x) || (a.y === y && y === c.y)) {\n        return `L${x} ${y}`;\n    }\n    // first segment is horizontal\n    if (a.y === y) {\n        const xDir = a.x < c.x ? -1 : 1;\n        const yDir = a.y < c.y ? 1 : -1;\n        return `L ${x + bendSize * xDir},${y}Q ${x},${y} ${x},${y + bendSize * yDir}`;\n    }\n    const xDir = a.x < c.x ? 1 : -1;\n    const yDir = a.y < c.y ? -1 : 1;\n    return `L ${x},${y + bendSize * yDir}Q ${x},${y} ${x + bendSize * xDir},${y}`;\n}\n/**\n * The `getSmoothStepPath` util returns everything you need to render a stepped path\n * between two nodes. The `borderRadius` property can be used to choose how rounded\n * the corners of those steps are.\n * @public\n * @returns A path string you can use in an SVG, the `labelX` and `labelY` position (center of path)\n * and `offsetX`, `offsetY` between source handle and label.\n *\n * - `path`: the path to use in an SVG `<path>` element.\n * - `labelX`: the `x` position you can use to render a label for this edge.\n * - `labelY`: the `y` position you can use to render a label for this edge.\n * - `offsetX`: the absolute difference between the source `x` position and the `x` position of the\n * middle of this path.\n * - `offsetY`: the absolute difference between the source `y` position and the `y` position of the\n * middle of this path.\n * @example\n * ```js\n *  const source = { x: 0, y: 20 };\n *  const target = { x: 150, y: 100 };\n *\n *  const [path, labelX, labelY, offsetX, offsetY] = getSmoothStepPath({\n *    sourceX: source.x,\n *    sourceY: source.y,\n *    sourcePosition: Position.Right,\n *    targetX: target.x,\n *    targetY: target.y,\n *    targetPosition: Position.Left,\n *  });\n * ```\n * @remarks This function returns a tuple (aka a fixed-size array) to make it easier to work with multiple edge paths at once.\n */\nfunction getSmoothStepPath({ sourceX, sourceY, sourcePosition = Position.Bottom, targetX, targetY, targetPosition = Position.Top, borderRadius = 5, centerX, centerY, offset = 20, stepPosition = 0.5, }) {\n    const [points, labelX, labelY, offsetX, offsetY] = getPoints({\n        source: { x: sourceX, y: sourceY },\n        sourcePosition,\n        target: { x: targetX, y: targetY },\n        targetPosition,\n        center: { x: centerX, y: centerY },\n        offset,\n        stepPosition,\n    });\n    const path = points.reduce((res, p, i) => {\n        let segment = '';\n        if (i > 0 && i < points.length - 1) {\n            segment = getBend(points[i - 1], p, points[i + 1], borderRadius);\n        }\n        else {\n            segment = `${i === 0 ? 'M' : 'L'}${p.x} ${p.y}`;\n        }\n        res += segment;\n        return res;\n    }, '');\n    return [path, labelX, labelY, offsetX, offsetY];\n}\n\nfunction isNodeInitialized(node) {\n    return (node &&\n        !!(node.internals.handleBounds || node.handles?.length) &&\n        !!(node.measured.width || node.width || node.initialWidth));\n}\nfunction getEdgePosition(params) {\n    const { sourceNode, targetNode } = params;\n    if (!isNodeInitialized(sourceNode) || !isNodeInitialized(targetNode)) {\n        return null;\n    }\n    const sourceHandleBounds = sourceNode.internals.handleBounds || toHandleBounds(sourceNode.handles);\n    const targetHandleBounds = targetNode.internals.handleBounds || toHandleBounds(targetNode.handles);\n    const sourceHandle = getHandle$1(sourceHandleBounds?.source ?? [], params.sourceHandle);\n    const targetHandle = getHandle$1(\n    // when connection type is loose we can define all handles as sources and connect source -> source\n    params.connectionMode === ConnectionMode.Strict\n        ? targetHandleBounds?.target ?? []\n        : (targetHandleBounds?.target ?? []).concat(targetHandleBounds?.source ?? []), params.targetHandle);\n    if (!sourceHandle || !targetHandle) {\n        params.onError?.('008', errorMessages['error008'](!sourceHandle ? 'source' : 'target', {\n            id: params.id,\n            sourceHandle: params.sourceHandle,\n            targetHandle: params.targetHandle,\n        }));\n        return null;\n    }\n    const sourcePosition = sourceHandle?.position || Position.Bottom;\n    const targetPosition = targetHandle?.position || Position.Top;\n    const source = getHandlePosition(sourceNode, sourceHandle, sourcePosition);\n    const target = getHandlePosition(targetNode, targetHandle, targetPosition);\n    return {\n        sourceX: source.x,\n        sourceY: source.y,\n        targetX: target.x,\n        targetY: target.y,\n        sourcePosition,\n        targetPosition,\n    };\n}\nfunction toHandleBounds(handles) {\n    if (!handles) {\n        return null;\n    }\n    const source = [];\n    const target = [];\n    for (const handle of handles) {\n        handle.width = handle.width ?? 1;\n        handle.height = handle.height ?? 1;\n        if (handle.type === 'source') {\n            source.push(handle);\n        }\n        else if (handle.type === 'target') {\n            target.push(handle);\n        }\n    }\n    return {\n        source,\n        target,\n    };\n}\nfunction getHandlePosition(node, handle, fallbackPosition = Position.Left, center = false) {\n    const x = (handle?.x ?? 0) + node.internals.positionAbsolute.x;\n    const y = (handle?.y ?? 0) + node.internals.positionAbsolute.y;\n    const { width, height } = handle ?? getNodeDimensions(node);\n    if (center) {\n        return { x: x + width / 2, y: y + height / 2 };\n    }\n    const position = handle?.position ?? fallbackPosition;\n    switch (position) {\n        case Position.Top:\n            return { x: x + width / 2, y };\n        case Position.Right:\n            return { x: x + width, y: y + height / 2 };\n        case Position.Bottom:\n            return { x: x + width / 2, y: y + height };\n        case Position.Left:\n            return { x, y: y + height / 2 };\n    }\n}\nfunction getHandle$1(bounds, handleId) {\n    if (!bounds) {\n        return null;\n    }\n    // if no handleId is given, we use the first handle, otherwise we check for the id\n    return (!handleId ? bounds[0] : bounds.find((d) => d.id === handleId)) || null;\n}\n\nfunction getMarkerId(marker, id) {\n    if (!marker) {\n        return '';\n    }\n    if (typeof marker === 'string') {\n        return marker;\n    }\n    const idPrefix = id ? `${id}__` : '';\n    return `${idPrefix}${Object.keys(marker)\n        .sort()\n        .map((key) => `${key}=${marker[key]}`)\n        .join('&')}`;\n}\nfunction createMarkerIds(edges, { id, defaultColor, defaultMarkerStart, defaultMarkerEnd, }) {\n    const ids = new Set();\n    return edges\n        .reduce((markers, edge) => {\n        [edge.markerStart || defaultMarkerStart, edge.markerEnd || defaultMarkerEnd].forEach((marker) => {\n            if (marker && typeof marker === 'object') {\n                const markerId = getMarkerId(marker, id);\n                if (!ids.has(markerId)) {\n                    markers.push({ id: markerId, color: marker.color || defaultColor, ...marker });\n                    ids.add(markerId);\n                }\n            }\n        });\n        return markers;\n    }, [])\n        .sort((a, b) => a.id.localeCompare(b.id));\n}\n\nfunction getNodeToolbarTransform(nodeRect, viewport, position, offset, align) {\n    let alignmentOffset = 0.5;\n    if (align === 'start') {\n        alignmentOffset = 0;\n    }\n    else if (align === 'end') {\n        alignmentOffset = 1;\n    }\n    /*\n     * position === Position.Top\n     * we set the x any y position of the toolbar based on the nodes position\n     */\n    let pos = [\n        (nodeRect.x + nodeRect.width * alignmentOffset) * viewport.zoom + viewport.x,\n        nodeRect.y * viewport.zoom + viewport.y - offset,\n    ];\n    // and than shift it based on the alignment. The shift values are in %.\n    let shift = [-100 * alignmentOffset, -100];\n    switch (position) {\n        case Position.Right:\n            pos = [\n                (nodeRect.x + nodeRect.width) * viewport.zoom + viewport.x + offset,\n                (nodeRect.y + nodeRect.height * alignmentOffset) * viewport.zoom + viewport.y,\n            ];\n            shift = [0, -100 * alignmentOffset];\n            break;\n        case Position.Bottom:\n            pos[1] = (nodeRect.y + nodeRect.height) * viewport.zoom + viewport.y + offset;\n            shift[1] = 0;\n            break;\n        case Position.Left:\n            pos = [\n                nodeRect.x * viewport.zoom + viewport.x - offset,\n                (nodeRect.y + nodeRect.height * alignmentOffset) * viewport.zoom + viewport.y,\n            ];\n            shift = [-100, -100 * alignmentOffset];\n            break;\n    }\n    return `translate(${pos[0]}px, ${pos[1]}px) translate(${shift[0]}%, ${shift[1]}%)`;\n}\n\nconst defaultOptions = {\n    nodeOrigin: [0, 0],\n    nodeExtent: infiniteExtent,\n    elevateNodesOnSelect: true,\n    defaults: {},\n};\nconst adoptUserNodesDefaultOptions = {\n    ...defaultOptions,\n    checkEquality: true,\n};\nfunction mergeObjects(base, incoming) {\n    const result = { ...base };\n    for (const key in incoming) {\n        if (incoming[key] !== undefined) {\n            // typecast is safe here, because we check for undefined\n            result[key] = incoming[key];\n        }\n    }\n    return result;\n}\nfunction updateAbsolutePositions(nodeLookup, parentLookup, options) {\n    const _options = mergeObjects(defaultOptions, options);\n    for (const node of nodeLookup.values()) {\n        if (node.parentId) {\n            updateChildNode(node, nodeLookup, parentLookup, _options);\n        }\n        else {\n            const positionWithOrigin = getNodePositionWithOrigin(node, _options.nodeOrigin);\n            const extent = isCoordinateExtent(node.extent) ? node.extent : _options.nodeExtent;\n            const clampedPosition = clampPosition(positionWithOrigin, extent, getNodeDimensions(node));\n            node.internals.positionAbsolute = clampedPosition;\n        }\n    }\n}\nfunction adoptUserNodes(nodes, nodeLookup, parentLookup, options) {\n    const _options = mergeObjects(adoptUserNodesDefaultOptions, options);\n    let nodesInitialized = nodes.length > 0;\n    const tmpLookup = new Map(nodeLookup);\n    const selectedNodeZ = _options?.elevateNodesOnSelect ? 1000 : 0;\n    nodeLookup.clear();\n    parentLookup.clear();\n    for (const userNode of nodes) {\n        let internalNode = tmpLookup.get(userNode.id);\n        if (_options.checkEquality && userNode === internalNode?.internals.userNode) {\n            nodeLookup.set(userNode.id, internalNode);\n        }\n        else {\n            const positionWithOrigin = getNodePositionWithOrigin(userNode, _options.nodeOrigin);\n            const extent = isCoordinateExtent(userNode.extent) ? userNode.extent : _options.nodeExtent;\n            const clampedPosition = clampPosition(positionWithOrigin, extent, getNodeDimensions(userNode));\n            internalNode = {\n                ..._options.defaults,\n                ...userNode,\n                measured: {\n                    width: userNode.measured?.width,\n                    height: userNode.measured?.height,\n                },\n                internals: {\n                    positionAbsolute: clampedPosition,\n                    // if user re-initializes the node or removes `measured` for whatever reason, we reset the handleBounds so that the node gets re-measured\n                    handleBounds: !userNode.measured ? undefined : internalNode?.internals.handleBounds,\n                    z: calculateZ(userNode, selectedNodeZ),\n                    userNode,\n                },\n            };\n            nodeLookup.set(userNode.id, internalNode);\n        }\n        if ((internalNode.measured === undefined ||\n            internalNode.measured.width === undefined ||\n            internalNode.measured.height === undefined) &&\n            !internalNode.hidden) {\n            nodesInitialized = false;\n        }\n        if (userNode.parentId) {\n            updateChildNode(internalNode, nodeLookup, parentLookup, options);\n        }\n    }\n    return nodesInitialized;\n}\nfunction updateParentLookup(node, parentLookup) {\n    if (!node.parentId) {\n        return;\n    }\n    const childNodes = parentLookup.get(node.parentId);\n    if (childNodes) {\n        childNodes.set(node.id, node);\n    }\n    else {\n        parentLookup.set(node.parentId, new Map([[node.id, node]]));\n    }\n}\n/**\n * Updates positionAbsolute and zIndex of a child node and the parentLookup.\n */\nfunction updateChildNode(node, nodeLookup, parentLookup, options) {\n    const { elevateNodesOnSelect, nodeOrigin, nodeExtent } = mergeObjects(defaultOptions, options);\n    const parentId = node.parentId;\n    const parentNode = nodeLookup.get(parentId);\n    if (!parentNode) {\n        console.warn(`Parent node ${parentId} not found. Please make sure that parent nodes are in front of their child nodes in the nodes array.`);\n        return;\n    }\n    updateParentLookup(node, parentLookup);\n    const selectedNodeZ = elevateNodesOnSelect ? 1000 : 0;\n    const { x, y, z } = calculateChildXYZ(node, parentNode, nodeOrigin, nodeExtent, selectedNodeZ);\n    const { positionAbsolute } = node.internals;\n    const positionChanged = x !== positionAbsolute.x || y !== positionAbsolute.y;\n    if (positionChanged || z !== node.internals.z) {\n        // we create a new object to mark the node as updated\n        nodeLookup.set(node.id, {\n            ...node,\n            internals: {\n                ...node.internals,\n                positionAbsolute: positionChanged ? { x, y } : positionAbsolute,\n                z,\n            },\n        });\n    }\n}\nfunction calculateZ(node, selectedNodeZ) {\n    return (isNumeric(node.zIndex) ? node.zIndex : 0) + (node.selected ? selectedNodeZ : 0);\n}\nfunction calculateChildXYZ(childNode, parentNode, nodeOrigin, nodeExtent, selectedNodeZ) {\n    const { x: parentX, y: parentY } = parentNode.internals.positionAbsolute;\n    const childDimensions = getNodeDimensions(childNode);\n    const positionWithOrigin = getNodePositionWithOrigin(childNode, nodeOrigin);\n    const clampedPosition = isCoordinateExtent(childNode.extent)\n        ? clampPosition(positionWithOrigin, childNode.extent, childDimensions)\n        : positionWithOrigin;\n    let absolutePosition = clampPosition({ x: parentX + clampedPosition.x, y: parentY + clampedPosition.y }, nodeExtent, childDimensions);\n    if (childNode.extent === 'parent') {\n        absolutePosition = clampPositionToParent(absolutePosition, childDimensions, parentNode);\n    }\n    const childZ = calculateZ(childNode, selectedNodeZ);\n    const parentZ = parentNode.internals.z ?? 0;\n    return {\n        x: absolutePosition.x,\n        y: absolutePosition.y,\n        z: parentZ >= childZ ? parentZ + 1 : childZ,\n    };\n}\nfunction handleExpandParent(children, nodeLookup, parentLookup, nodeOrigin = [0, 0]) {\n    const changes = [];\n    const parentExpansions = new Map();\n    // determine the expanded rectangle the child nodes would take for each parent\n    for (const child of children) {\n        const parent = nodeLookup.get(child.parentId);\n        if (!parent) {\n            continue;\n        }\n        const parentRect = parentExpansions.get(child.parentId)?.expandedRect ?? nodeToRect(parent);\n        const expandedRect = getBoundsOfRects(parentRect, child.rect);\n        parentExpansions.set(child.parentId, { expandedRect, parent });\n    }\n    if (parentExpansions.size > 0) {\n        parentExpansions.forEach(({ expandedRect, parent }, parentId) => {\n            // determine the position & dimensions of the parent\n            const positionAbsolute = parent.internals.positionAbsolute;\n            const dimensions = getNodeDimensions(parent);\n            const origin = parent.origin ?? nodeOrigin;\n            // determine how much the parent expands in width and position\n            const xChange = expandedRect.x < positionAbsolute.x ? Math.round(Math.abs(positionAbsolute.x - expandedRect.x)) : 0;\n            const yChange = expandedRect.y < positionAbsolute.y ? Math.round(Math.abs(positionAbsolute.y - expandedRect.y)) : 0;\n            const newWidth = Math.max(dimensions.width, Math.round(expandedRect.width));\n            const newHeight = Math.max(dimensions.height, Math.round(expandedRect.height));\n            const widthChange = (newWidth - dimensions.width) * origin[0];\n            const heightChange = (newHeight - dimensions.height) * origin[1];\n            // We need to correct the position of the parent node if the origin is not [0,0]\n            if (xChange > 0 || yChange > 0 || widthChange || heightChange) {\n                changes.push({\n                    id: parentId,\n                    type: 'position',\n                    position: {\n                        x: parent.position.x - xChange + widthChange,\n                        y: parent.position.y - yChange + heightChange,\n                    },\n                });\n                /*\n                 * We move all child nodes in the oppsite direction\n                 * so the x,y changes of the parent do not move the children\n                 */\n                parentLookup.get(parentId)?.forEach((childNode) => {\n                    if (!children.some((child) => child.id === childNode.id)) {\n                        changes.push({\n                            id: childNode.id,\n                            type: 'position',\n                            position: {\n                                x: childNode.position.x + xChange,\n                                y: childNode.position.y + yChange,\n                            },\n                        });\n                    }\n                });\n            }\n            // We need to correct the dimensions of the parent node if the origin is not [0,0]\n            if (dimensions.width < expandedRect.width || dimensions.height < expandedRect.height || xChange || yChange) {\n                changes.push({\n                    id: parentId,\n                    type: 'dimensions',\n                    setAttributes: true,\n                    dimensions: {\n                        width: newWidth + (xChange ? origin[0] * xChange - widthChange : 0),\n                        height: newHeight + (yChange ? origin[1] * yChange - heightChange : 0),\n                    },\n                });\n            }\n        });\n    }\n    return changes;\n}\nfunction updateNodeInternals(updates, nodeLookup, parentLookup, domNode, nodeOrigin, nodeExtent) {\n    const viewportNode = domNode?.querySelector('.xyflow__viewport');\n    let updatedInternals = false;\n    if (!viewportNode) {\n        return { changes: [], updatedInternals };\n    }\n    const changes = [];\n    const style = window.getComputedStyle(viewportNode);\n    const { m22: zoom } = new window.DOMMatrixReadOnly(style.transform);\n    // in this array we collect nodes, that might trigger changes (like expanding parent)\n    const parentExpandChildren = [];\n    for (const update of updates.values()) {\n        const node = nodeLookup.get(update.id);\n        if (!node) {\n            continue;\n        }\n        if (node.hidden) {\n            nodeLookup.set(node.id, {\n                ...node,\n                internals: {\n                    ...node.internals,\n                    handleBounds: undefined,\n                },\n            });\n            updatedInternals = true;\n            continue;\n        }\n        const dimensions = getDimensions(update.nodeElement);\n        const dimensionChanged = node.measured.width !== dimensions.width || node.measured.height !== dimensions.height;\n        const doUpdate = !!(dimensions.width &&\n            dimensions.height &&\n            (dimensionChanged || !node.internals.handleBounds || update.force));\n        if (doUpdate) {\n            const nodeBounds = update.nodeElement.getBoundingClientRect();\n            const extent = isCoordinateExtent(node.extent) ? node.extent : nodeExtent;\n            let { positionAbsolute } = node.internals;\n            if (node.parentId && node.extent === 'parent') {\n                positionAbsolute = clampPositionToParent(positionAbsolute, dimensions, nodeLookup.get(node.parentId));\n            }\n            else if (extent) {\n                positionAbsolute = clampPosition(positionAbsolute, extent, dimensions);\n            }\n            const newNode = {\n                ...node,\n                measured: dimensions,\n                internals: {\n                    ...node.internals,\n                    positionAbsolute,\n                    handleBounds: {\n                        source: getHandleBounds('source', update.nodeElement, nodeBounds, zoom, node.id),\n                        target: getHandleBounds('target', update.nodeElement, nodeBounds, zoom, node.id),\n                    },\n                },\n            };\n            nodeLookup.set(node.id, newNode);\n            if (node.parentId) {\n                updateChildNode(newNode, nodeLookup, parentLookup, { nodeOrigin });\n            }\n            updatedInternals = true;\n            if (dimensionChanged) {\n                changes.push({\n                    id: node.id,\n                    type: 'dimensions',\n                    dimensions,\n                });\n                if (node.expandParent && node.parentId) {\n                    parentExpandChildren.push({\n                        id: node.id,\n                        parentId: node.parentId,\n                        rect: nodeToRect(newNode, nodeOrigin),\n                    });\n                }\n            }\n        }\n    }\n    if (parentExpandChildren.length > 0) {\n        const parentExpandChanges = handleExpandParent(parentExpandChildren, nodeLookup, parentLookup, nodeOrigin);\n        changes.push(...parentExpandChanges);\n    }\n    return { changes, updatedInternals };\n}\nasync function panBy({ delta, panZoom, transform, translateExtent, width, height, }) {\n    if (!panZoom || (!delta.x && !delta.y)) {\n        return Promise.resolve(false);\n    }\n    const nextViewport = await panZoom.setViewportConstrained({\n        x: transform[0] + delta.x,\n        y: transform[1] + delta.y,\n        zoom: transform[2],\n    }, [\n        [0, 0],\n        [width, height],\n    ], translateExtent);\n    const transformChanged = !!nextViewport &&\n        (nextViewport.x !== transform[0] || nextViewport.y !== transform[1] || nextViewport.k !== transform[2]);\n    return Promise.resolve(transformChanged);\n}\n/**\n * this function adds the connection to the connectionLookup\n * at the following keys: nodeId-type-handleId, nodeId-type and nodeId\n * @param type type of the connection\n * @param connection connection that should be added to the lookup\n * @param connectionKey at which key the connection should be added\n * @param connectionLookup reference to the connection lookup\n * @param nodeId nodeId of the connection\n * @param handleId handleId of the conneciton\n */\nfunction addConnectionToLookup(type, connection, connectionKey, connectionLookup, nodeId, handleId) {\n    /*\n     * We add the connection to the connectionLookup at the following keys\n     * 1. nodeId, 2. nodeId-type, 3. nodeId-type-handleId\n     * If the key already exists, we add the connection to the existing map\n     */\n    let key = nodeId;\n    const nodeMap = connectionLookup.get(key) || new Map();\n    connectionLookup.set(key, nodeMap.set(connectionKey, connection));\n    key = `${nodeId}-${type}`;\n    const typeMap = connectionLookup.get(key) || new Map();\n    connectionLookup.set(key, typeMap.set(connectionKey, connection));\n    if (handleId) {\n        key = `${nodeId}-${type}-${handleId}`;\n        const handleMap = connectionLookup.get(key) || new Map();\n        connectionLookup.set(key, handleMap.set(connectionKey, connection));\n    }\n}\nfunction updateConnectionLookup(connectionLookup, edgeLookup, edges) {\n    connectionLookup.clear();\n    edgeLookup.clear();\n    for (const edge of edges) {\n        const { source: sourceNode, target: targetNode, sourceHandle = null, targetHandle = null } = edge;\n        const connection = { edgeId: edge.id, source: sourceNode, target: targetNode, sourceHandle, targetHandle };\n        const sourceKey = `${sourceNode}-${sourceHandle}--${targetNode}-${targetHandle}`;\n        const targetKey = `${targetNode}-${targetHandle}--${sourceNode}-${sourceHandle}`;\n        addConnectionToLookup('source', connection, targetKey, connectionLookup, sourceNode, sourceHandle);\n        addConnectionToLookup('target', connection, sourceKey, connectionLookup, targetNode, targetHandle);\n        edgeLookup.set(edge.id, edge);\n    }\n}\n\nfunction shallowNodeData(a, b) {\n    if (a === null || b === null) {\n        return false;\n    }\n    const _a = Array.isArray(a) ? a : [a];\n    const _b = Array.isArray(b) ? b : [b];\n    if (_a.length !== _b.length) {\n        return false;\n    }\n    for (let i = 0; i < _a.length; i++) {\n        if (_a[i].id !== _b[i].id || _a[i].type !== _b[i].type || !Object.is(_a[i].data, _b[i].data)) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction isParentSelected(node, nodeLookup) {\n    if (!node.parentId) {\n        return false;\n    }\n    const parentNode = nodeLookup.get(node.parentId);\n    if (!parentNode) {\n        return false;\n    }\n    if (parentNode.selected) {\n        return true;\n    }\n    return isParentSelected(parentNode, nodeLookup);\n}\nfunction hasSelector(target, selector, domNode) {\n    let current = target;\n    do {\n        if (current?.matches?.(selector))\n            return true;\n        if (current === domNode)\n            return false;\n        current = current?.parentElement;\n    } while (current);\n    return false;\n}\n// looks for all selected nodes and created a NodeDragItem for each of them\nfunction getDragItems(nodeLookup, nodesDraggable, mousePos, nodeId) {\n    const dragItems = new Map();\n    for (const [id, node] of nodeLookup) {\n        if ((node.selected || node.id === nodeId) &&\n            (!node.parentId || !isParentSelected(node, nodeLookup)) &&\n            (node.draggable || (nodesDraggable && typeof node.draggable === 'undefined'))) {\n            const internalNode = nodeLookup.get(id);\n            if (internalNode) {\n                dragItems.set(id, {\n                    id,\n                    position: internalNode.position || { x: 0, y: 0 },\n                    distance: {\n                        x: mousePos.x - internalNode.internals.positionAbsolute.x,\n                        y: mousePos.y - internalNode.internals.positionAbsolute.y,\n                    },\n                    extent: internalNode.extent,\n                    parentId: internalNode.parentId,\n                    origin: internalNode.origin,\n                    expandParent: internalNode.expandParent,\n                    internals: {\n                        positionAbsolute: internalNode.internals.positionAbsolute || { x: 0, y: 0 },\n                    },\n                    measured: {\n                        width: internalNode.measured.width ?? 0,\n                        height: internalNode.measured.height ?? 0,\n                    },\n                });\n            }\n        }\n    }\n    return dragItems;\n}\n/*\n * returns two params:\n * 1. the dragged node (or the first of the list, if we are dragging a node selection)\n * 2. array of selected nodes (for multi selections)\n */\nfunction getEventHandlerParams({ nodeId, dragItems, nodeLookup, dragging = true, }) {\n    const nodesFromDragItems = [];\n    for (const [id, dragItem] of dragItems) {\n        const node = nodeLookup.get(id)?.internals.userNode;\n        if (node) {\n            nodesFromDragItems.push({\n                ...node,\n                position: dragItem.position,\n                dragging,\n            });\n        }\n    }\n    if (!nodeId) {\n        return [nodesFromDragItems[0], nodesFromDragItems];\n    }\n    const node = nodeLookup.get(nodeId)?.internals.userNode;\n    return [\n        !node\n            ? nodesFromDragItems[0]\n            : {\n                ...node,\n                position: dragItems.get(nodeId)?.position || node.position,\n                dragging,\n            },\n        nodesFromDragItems,\n    ];\n}\n/**\n * If a selection is being dragged we want to apply the same snap offset to all nodes in the selection.\n * This function calculates the snap offset based on the first node in the selection.\n */\nfunction calculateSnapOffset({ dragItems, snapGrid, x, y, }) {\n    const refDragItem = dragItems.values().next().value;\n    if (!refDragItem) {\n        return null;\n    }\n    const refPos = {\n        x: x - refDragItem.distance.x,\n        y: y - refDragItem.distance.y,\n    };\n    const refPosSnapped = snapPosition(refPos, snapGrid);\n    return {\n        x: refPosSnapped.x - refPos.x,\n        y: refPosSnapped.y - refPos.y,\n    };\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction XYDrag({ onNodeMouseDown, getStoreItems, onDragStart, onDrag, onDragStop, }) {\n    let lastPos = { x: null, y: null };\n    let autoPanId = 0;\n    let dragItems = new Map();\n    let autoPanStarted = false;\n    let mousePosition = { x: 0, y: 0 };\n    let containerBounds = null;\n    let dragStarted = false;\n    let d3Selection = null;\n    let abortDrag = false; // prevents unintentional dragging on multitouch\n    let nodePositionsChanged = false;\n    // we store the last drag event to be able to use it in the update function\n    let dragEvent = null;\n    // public functions\n    function update({ noDragClassName, handleSelector, domNode, isSelectable, nodeId, nodeClickDistance = 0, }) {\n        d3Selection = select(domNode);\n        function updateNodes({ x, y }) {\n            const { nodeLookup, nodeExtent, snapGrid, snapToGrid, nodeOrigin, onNodeDrag, onSelectionDrag, onError, updateNodePositions, } = getStoreItems();\n            lastPos = { x, y };\n            let hasChange = false;\n            const isMultiDrag = dragItems.size > 1;\n            const nodesBox = isMultiDrag && nodeExtent ? rectToBox(getInternalNodesBounds(dragItems)) : null;\n            const multiDragSnapOffset = isMultiDrag && snapToGrid\n                ? calculateSnapOffset({\n                    dragItems,\n                    snapGrid,\n                    x,\n                    y,\n                })\n                : null;\n            for (const [id, dragItem] of dragItems) {\n                /*\n                 * if the node is not in the nodeLookup anymore, it was probably deleted while dragging\n                 */\n                if (!nodeLookup.has(id)) {\n                    continue;\n                }\n                let nextPosition = { x: x - dragItem.distance.x, y: y - dragItem.distance.y };\n                if (snapToGrid) {\n                    nextPosition = multiDragSnapOffset\n                        ? {\n                            x: Math.round(nextPosition.x + multiDragSnapOffset.x),\n                            y: Math.round(nextPosition.y + multiDragSnapOffset.y),\n                        }\n                        : snapPosition(nextPosition, snapGrid);\n                }\n                let adjustedNodeExtent = null;\n                if (isMultiDrag && nodeExtent && !dragItem.extent && nodesBox) {\n                    const { positionAbsolute } = dragItem.internals;\n                    const x1 = positionAbsolute.x - nodesBox.x + nodeExtent[0][0];\n                    const x2 = positionAbsolute.x + dragItem.measured.width - nodesBox.x2 + nodeExtent[1][0];\n                    const y1 = positionAbsolute.y - nodesBox.y + nodeExtent[0][1];\n                    const y2 = positionAbsolute.y + dragItem.measured.height - nodesBox.y2 + nodeExtent[1][1];\n                    adjustedNodeExtent = [\n                        [x1, y1],\n                        [x2, y2],\n                    ];\n                }\n                const { position, positionAbsolute } = calculateNodePosition({\n                    nodeId: id,\n                    nextPosition,\n                    nodeLookup,\n                    nodeExtent: adjustedNodeExtent ? adjustedNodeExtent : nodeExtent,\n                    nodeOrigin,\n                    onError,\n                });\n                // we want to make sure that we only fire a change event when there is a change\n                hasChange = hasChange || dragItem.position.x !== position.x || dragItem.position.y !== position.y;\n                dragItem.position = position;\n                dragItem.internals.positionAbsolute = positionAbsolute;\n            }\n            nodePositionsChanged = nodePositionsChanged || hasChange;\n            if (!hasChange) {\n                return;\n            }\n            updateNodePositions(dragItems, true);\n            if (dragEvent && (onDrag || onNodeDrag || (!nodeId && onSelectionDrag))) {\n                const [currentNode, currentNodes] = getEventHandlerParams({\n                    nodeId,\n                    dragItems,\n                    nodeLookup,\n                });\n                onDrag?.(dragEvent, dragItems, currentNode, currentNodes);\n                onNodeDrag?.(dragEvent, currentNode, currentNodes);\n                if (!nodeId) {\n                    onSelectionDrag?.(dragEvent, currentNodes);\n                }\n            }\n        }\n        async function autoPan() {\n            if (!containerBounds) {\n                return;\n            }\n            const { transform, panBy, autoPanSpeed, autoPanOnNodeDrag } = getStoreItems();\n            if (!autoPanOnNodeDrag) {\n                autoPanStarted = false;\n                cancelAnimationFrame(autoPanId);\n                return;\n            }\n            const [xMovement, yMovement] = calcAutoPan(mousePosition, containerBounds, autoPanSpeed);\n            if (xMovement !== 0 || yMovement !== 0) {\n                lastPos.x = (lastPos.x ?? 0) - xMovement / transform[2];\n                lastPos.y = (lastPos.y ?? 0) - yMovement / transform[2];\n                if (await panBy({ x: xMovement, y: yMovement })) {\n                    updateNodes(lastPos);\n                }\n            }\n            autoPanId = requestAnimationFrame(autoPan);\n        }\n        function startDrag(event) {\n            const { nodeLookup, multiSelectionActive, nodesDraggable, transform, snapGrid, snapToGrid, selectNodesOnDrag, onNodeDragStart, onSelectionDragStart, unselectNodesAndEdges, } = getStoreItems();\n            dragStarted = true;\n            if ((!selectNodesOnDrag || !isSelectable) && !multiSelectionActive && nodeId) {\n                if (!nodeLookup.get(nodeId)?.selected) {\n                    // we need to reset selected nodes when selectNodesOnDrag=false\n                    unselectNodesAndEdges();\n                }\n            }\n            if (isSelectable && selectNodesOnDrag && nodeId) {\n                onNodeMouseDown?.(nodeId);\n            }\n            const pointerPos = getPointerPosition(event.sourceEvent, { transform, snapGrid, snapToGrid, containerBounds });\n            lastPos = pointerPos;\n            dragItems = getDragItems(nodeLookup, nodesDraggable, pointerPos, nodeId);\n            if (dragItems.size > 0 && (onDragStart || onNodeDragStart || (!nodeId && onSelectionDragStart))) {\n                const [currentNode, currentNodes] = getEventHandlerParams({\n                    nodeId,\n                    dragItems,\n                    nodeLookup,\n                });\n                onDragStart?.(event.sourceEvent, dragItems, currentNode, currentNodes);\n                onNodeDragStart?.(event.sourceEvent, currentNode, currentNodes);\n                if (!nodeId) {\n                    onSelectionDragStart?.(event.sourceEvent, currentNodes);\n                }\n            }\n        }\n        const d3DragInstance = drag()\n            .clickDistance(nodeClickDistance)\n            .on('start', (event) => {\n            const { domNode, nodeDragThreshold, transform, snapGrid, snapToGrid } = getStoreItems();\n            containerBounds = domNode?.getBoundingClientRect() || null;\n            abortDrag = false;\n            nodePositionsChanged = false;\n            dragEvent = event.sourceEvent;\n            if (nodeDragThreshold === 0) {\n                startDrag(event);\n            }\n            const pointerPos = getPointerPosition(event.sourceEvent, { transform, snapGrid, snapToGrid, containerBounds });\n            lastPos = pointerPos;\n            mousePosition = getEventPosition(event.sourceEvent, containerBounds);\n        })\n            .on('drag', (event) => {\n            const { autoPanOnNodeDrag, transform, snapGrid, snapToGrid, nodeDragThreshold, nodeLookup } = getStoreItems();\n            const pointerPos = getPointerPosition(event.sourceEvent, { transform, snapGrid, snapToGrid, containerBounds });\n            dragEvent = event.sourceEvent;\n            if ((event.sourceEvent.type === 'touchmove' && event.sourceEvent.touches.length > 1) ||\n                // if user deletes a node while dragging, we need to abort the drag to prevent errors\n                (nodeId && !nodeLookup.has(nodeId))) {\n                abortDrag = true;\n            }\n            if (abortDrag) {\n                return;\n            }\n            if (!autoPanStarted && autoPanOnNodeDrag && dragStarted) {\n                autoPanStarted = true;\n                autoPan();\n            }\n            if (!dragStarted) {\n                const x = pointerPos.xSnapped - (lastPos.x ?? 0);\n                const y = pointerPos.ySnapped - (lastPos.y ?? 0);\n                const distance = Math.sqrt(x * x + y * y);\n                if (distance > nodeDragThreshold) {\n                    startDrag(event);\n                }\n            }\n            // skip events without movement\n            if ((lastPos.x !== pointerPos.xSnapped || lastPos.y !== pointerPos.ySnapped) && dragItems && dragStarted) {\n                mousePosition = getEventPosition(event.sourceEvent, containerBounds);\n                updateNodes(pointerPos);\n            }\n        })\n            .on('end', (event) => {\n            if (!dragStarted || abortDrag) {\n                return;\n            }\n            autoPanStarted = false;\n            dragStarted = false;\n            cancelAnimationFrame(autoPanId);\n            if (dragItems.size > 0) {\n                const { nodeLookup, updateNodePositions, onNodeDragStop, onSelectionDragStop } = getStoreItems();\n                if (nodePositionsChanged) {\n                    updateNodePositions(dragItems, false);\n                    nodePositionsChanged = false;\n                }\n                if (onDragStop || onNodeDragStop || (!nodeId && onSelectionDragStop)) {\n                    const [currentNode, currentNodes] = getEventHandlerParams({\n                        nodeId,\n                        dragItems,\n                        nodeLookup,\n                        dragging: false,\n                    });\n                    onDragStop?.(event.sourceEvent, dragItems, currentNode, currentNodes);\n                    onNodeDragStop?.(event.sourceEvent, currentNode, currentNodes);\n                    if (!nodeId) {\n                        onSelectionDragStop?.(event.sourceEvent, currentNodes);\n                    }\n                }\n            }\n        })\n            .filter((event) => {\n            const target = event.target;\n            const isDraggable = !event.button &&\n                (!noDragClassName || !hasSelector(target, `.${noDragClassName}`, domNode)) &&\n                (!handleSelector || hasSelector(target, handleSelector, domNode));\n            return isDraggable;\n        });\n        d3Selection.call(d3DragInstance);\n    }\n    function destroy() {\n        d3Selection?.on('.drag', null);\n    }\n    return {\n        update,\n        destroy,\n    };\n}\n\nfunction getNodesWithinDistance(position, nodeLookup, distance) {\n    const nodes = [];\n    const rect = {\n        x: position.x - distance,\n        y: position.y - distance,\n        width: distance * 2,\n        height: distance * 2,\n    };\n    for (const node of nodeLookup.values()) {\n        if (getOverlappingArea(rect, nodeToRect(node)) > 0) {\n            nodes.push(node);\n        }\n    }\n    return nodes;\n}\n/*\n * this distance is used for the area around the user pointer\n * while doing a connection for finding the closest nodes\n */\nconst ADDITIONAL_DISTANCE = 250;\nfunction getClosestHandle(position, connectionRadius, nodeLookup, fromHandle) {\n    let closestHandles = [];\n    let minDistance = Infinity;\n    const closeNodes = getNodesWithinDistance(position, nodeLookup, connectionRadius + ADDITIONAL_DISTANCE);\n    for (const node of closeNodes) {\n        const allHandles = [...(node.internals.handleBounds?.source ?? []), ...(node.internals.handleBounds?.target ?? [])];\n        for (const handle of allHandles) {\n            // if the handle is the same as the fromHandle we skip it\n            if (fromHandle.nodeId === handle.nodeId && fromHandle.type === handle.type && fromHandle.id === handle.id) {\n                continue;\n            }\n            // determine absolute position of the handle\n            const { x, y } = getHandlePosition(node, handle, handle.position, true);\n            const distance = Math.sqrt(Math.pow(x - position.x, 2) + Math.pow(y - position.y, 2));\n            if (distance > connectionRadius) {\n                continue;\n            }\n            if (distance < minDistance) {\n                closestHandles = [{ ...handle, x, y }];\n                minDistance = distance;\n            }\n            else if (distance === minDistance) {\n                // when multiple handles are on the same distance we collect all of them\n                closestHandles.push({ ...handle, x, y });\n            }\n        }\n    }\n    if (!closestHandles.length) {\n        return null;\n    }\n    // when multiple handles overlay each other we prefer the opposite handle\n    if (closestHandles.length > 1) {\n        const oppositeHandleType = fromHandle.type === 'source' ? 'target' : 'source';\n        return closestHandles.find((handle) => handle.type === oppositeHandleType) ?? closestHandles[0];\n    }\n    return closestHandles[0];\n}\nfunction getHandle(nodeId, handleType, handleId, nodeLookup, connectionMode, withAbsolutePosition = false) {\n    const node = nodeLookup.get(nodeId);\n    if (!node) {\n        return null;\n    }\n    const handles = connectionMode === 'strict'\n        ? node.internals.handleBounds?.[handleType]\n        : [...(node.internals.handleBounds?.source ?? []), ...(node.internals.handleBounds?.target ?? [])];\n    const handle = (handleId ? handles?.find((h) => h.id === handleId) : handles?.[0]) ?? null;\n    return handle && withAbsolutePosition\n        ? { ...handle, ...getHandlePosition(node, handle, handle.position, true) }\n        : handle;\n}\nfunction getHandleType(edgeUpdaterType, handleDomNode) {\n    if (edgeUpdaterType) {\n        return edgeUpdaterType;\n    }\n    else if (handleDomNode?.classList.contains('target')) {\n        return 'target';\n    }\n    else if (handleDomNode?.classList.contains('source')) {\n        return 'source';\n    }\n    return null;\n}\nfunction isConnectionValid(isInsideConnectionRadius, isHandleValid) {\n    let isValid = null;\n    if (isHandleValid) {\n        isValid = true;\n    }\n    else if (isInsideConnectionRadius && !isHandleValid) {\n        isValid = false;\n    }\n    return isValid;\n}\n\nconst alwaysValid = () => true;\nfunction onPointerDown(event, { connectionMode, connectionRadius, handleId, nodeId, edgeUpdaterType, isTarget, domNode, nodeLookup, lib, autoPanOnConnect, flowId, panBy, cancelConnection, onConnectStart, onConnect, onConnectEnd, isValidConnection = alwaysValid, onReconnectEnd, updateConnection, getTransform, getFromHandle, autoPanSpeed, dragThreshold = 1, handleDomNode, }) {\n    // when xyflow is used inside a shadow root we can't use document\n    const doc = getHostForElement(event.target);\n    let autoPanId = 0;\n    let closestHandle;\n    const { x, y } = getEventPosition(event);\n    const handleType = getHandleType(edgeUpdaterType, handleDomNode);\n    const containerBounds = domNode?.getBoundingClientRect();\n    let connectionStarted = false;\n    if (!containerBounds || !handleType) {\n        return;\n    }\n    const fromHandleInternal = getHandle(nodeId, handleType, handleId, nodeLookup, connectionMode);\n    if (!fromHandleInternal) {\n        return;\n    }\n    let position = getEventPosition(event, containerBounds);\n    let autoPanStarted = false;\n    let connection = null;\n    let isValid = false;\n    let resultHandleDomNode = null;\n    // when the user is moving the mouse close to the edge of the canvas while connecting we move the canvas\n    function autoPan() {\n        if (!autoPanOnConnect || !containerBounds) {\n            return;\n        }\n        const [x, y] = calcAutoPan(position, containerBounds, autoPanSpeed);\n        panBy({ x, y });\n        autoPanId = requestAnimationFrame(autoPan);\n    }\n    // Stays the same for all consecutive pointermove events\n    const fromHandle = {\n        ...fromHandleInternal,\n        nodeId,\n        type: handleType,\n        position: fromHandleInternal.position,\n    };\n    const fromNodeInternal = nodeLookup.get(nodeId);\n    const from = getHandlePosition(fromNodeInternal, fromHandle, Position.Left, true);\n    let previousConnection = {\n        inProgress: true,\n        isValid: null,\n        from,\n        fromHandle,\n        fromPosition: fromHandle.position,\n        fromNode: fromNodeInternal,\n        to: position,\n        toHandle: null,\n        toPosition: oppositePosition[fromHandle.position],\n        toNode: null,\n    };\n    function startConnection() {\n        connectionStarted = true;\n        updateConnection(previousConnection);\n        onConnectStart?.(event, { nodeId, handleId, handleType });\n    }\n    if (dragThreshold === 0) {\n        startConnection();\n    }\n    function onPointerMove(event) {\n        if (!connectionStarted) {\n            const { x: evtX, y: evtY } = getEventPosition(event);\n            const dx = evtX - x;\n            const dy = evtY - y;\n            const nextConnectionStarted = dx * dx + dy * dy > dragThreshold * dragThreshold;\n            if (!nextConnectionStarted) {\n                return;\n            }\n            startConnection();\n        }\n        if (!getFromHandle() || !fromHandle) {\n            onPointerUp(event);\n            return;\n        }\n        const transform = getTransform();\n        position = getEventPosition(event, containerBounds);\n        closestHandle = getClosestHandle(pointToRendererPoint(position, transform, false, [1, 1]), connectionRadius, nodeLookup, fromHandle);\n        if (!autoPanStarted) {\n            autoPan();\n            autoPanStarted = true;\n        }\n        const result = isValidHandle(event, {\n            handle: closestHandle,\n            connectionMode,\n            fromNodeId: nodeId,\n            fromHandleId: handleId,\n            fromType: isTarget ? 'target' : 'source',\n            isValidConnection,\n            doc,\n            lib,\n            flowId,\n            nodeLookup,\n        });\n        resultHandleDomNode = result.handleDomNode;\n        connection = result.connection;\n        isValid = isConnectionValid(!!closestHandle, result.isValid);\n        const newConnection = {\n            // from stays the same\n            ...previousConnection,\n            isValid,\n            to: result.toHandle && isValid\n                ? rendererPointToPoint({ x: result.toHandle.x, y: result.toHandle.y }, transform)\n                : position,\n            toHandle: result.toHandle,\n            toPosition: isValid && result.toHandle ? result.toHandle.position : oppositePosition[fromHandle.position],\n            toNode: result.toHandle ? nodeLookup.get(result.toHandle.nodeId) : null,\n        };\n        /*\n         * we don't want to trigger an update when the connection\n         * is snapped to the same handle as before\n         */\n        if (isValid &&\n            closestHandle &&\n            previousConnection.toHandle &&\n            newConnection.toHandle &&\n            previousConnection.toHandle.type === newConnection.toHandle.type &&\n            previousConnection.toHandle.nodeId === newConnection.toHandle.nodeId &&\n            previousConnection.toHandle.id === newConnection.toHandle.id &&\n            previousConnection.to.x === newConnection.to.x &&\n            previousConnection.to.y === newConnection.to.y) {\n            return;\n        }\n        updateConnection(newConnection);\n        previousConnection = newConnection;\n    }\n    function onPointerUp(event) {\n        if (connectionStarted) {\n            if ((closestHandle || resultHandleDomNode) && connection && isValid) {\n                onConnect?.(connection);\n            }\n            /*\n             * it's important to get a fresh reference from the store here\n             * in order to get the latest state of onConnectEnd\n             */\n            // eslint-disable-next-line @typescript-eslint/no-unused-vars\n            const { inProgress, ...connectionState } = previousConnection;\n            const finalConnectionState = {\n                ...connectionState,\n                toPosition: previousConnection.toHandle ? previousConnection.toPosition : null,\n            };\n            onConnectEnd?.(event, finalConnectionState);\n            if (edgeUpdaterType) {\n                onReconnectEnd?.(event, finalConnectionState);\n            }\n        }\n        cancelConnection();\n        cancelAnimationFrame(autoPanId);\n        autoPanStarted = false;\n        isValid = false;\n        connection = null;\n        resultHandleDomNode = null;\n        doc.removeEventListener('mousemove', onPointerMove);\n        doc.removeEventListener('mouseup', onPointerUp);\n        doc.removeEventListener('touchmove', onPointerMove);\n        doc.removeEventListener('touchend', onPointerUp);\n    }\n    doc.addEventListener('mousemove', onPointerMove);\n    doc.addEventListener('mouseup', onPointerUp);\n    doc.addEventListener('touchmove', onPointerMove);\n    doc.addEventListener('touchend', onPointerUp);\n}\n// checks if  and returns connection in fom of an object { source: 123, target: 312 }\nfunction isValidHandle(event, { handle, connectionMode, fromNodeId, fromHandleId, fromType, doc, lib, flowId, isValidConnection = alwaysValid, nodeLookup, }) {\n    const isTarget = fromType === 'target';\n    const handleDomNode = handle\n        ? doc.querySelector(`.${lib}-flow__handle[data-id=\"${flowId}-${handle?.nodeId}-${handle?.id}-${handle?.type}\"]`)\n        : null;\n    const { x, y } = getEventPosition(event);\n    const handleBelow = doc.elementFromPoint(x, y);\n    /*\n     * we always want to prioritize the handle below the mouse cursor over the closest distance handle,\n     * because it could be that the center of another handle is closer to the mouse pointer than the handle below the cursor\n     */\n    const handleToCheck = handleBelow?.classList.contains(`${lib}-flow__handle`) ? handleBelow : handleDomNode;\n    const result = {\n        handleDomNode: handleToCheck,\n        isValid: false,\n        connection: null,\n        toHandle: null,\n    };\n    if (handleToCheck) {\n        const handleType = getHandleType(undefined, handleToCheck);\n        const handleNodeId = handleToCheck.getAttribute('data-nodeid');\n        const handleId = handleToCheck.getAttribute('data-handleid');\n        const connectable = handleToCheck.classList.contains('connectable');\n        const connectableEnd = handleToCheck.classList.contains('connectableend');\n        if (!handleNodeId || !handleType) {\n            return result;\n        }\n        const connection = {\n            source: isTarget ? handleNodeId : fromNodeId,\n            sourceHandle: isTarget ? handleId : fromHandleId,\n            target: isTarget ? fromNodeId : handleNodeId,\n            targetHandle: isTarget ? fromHandleId : handleId,\n        };\n        result.connection = connection;\n        const isConnectable = connectable && connectableEnd;\n        // in strict mode we don't allow target to target or source to source connections\n        const isValid = isConnectable &&\n            (connectionMode === ConnectionMode.Strict\n                ? (isTarget && handleType === 'source') || (!isTarget && handleType === 'target')\n                : handleNodeId !== fromNodeId || handleId !== fromHandleId);\n        result.isValid = isValid && isValidConnection(connection);\n        result.toHandle = getHandle(handleNodeId, handleType, handleId, nodeLookup, connectionMode, true);\n    }\n    return result;\n}\nconst XYHandle = {\n    onPointerDown,\n    isValid: isValidHandle,\n};\n\nfunction XYMinimap({ domNode, panZoom, getTransform, getViewScale }) {\n    const selection = select(domNode);\n    function update({ translateExtent, width, height, zoomStep = 1, pannable = true, zoomable = true, inversePan = false, }) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const zoomHandler = (event) => {\n            if (event.sourceEvent.type !== 'wheel' || !panZoom) {\n                return;\n            }\n            const transform = getTransform();\n            const factor = event.sourceEvent.ctrlKey && isMacOs() ? 10 : 1;\n            const pinchDelta = -event.sourceEvent.deltaY *\n                (event.sourceEvent.deltaMode === 1 ? 0.05 : event.sourceEvent.deltaMode ? 1 : 0.002) *\n                zoomStep;\n            const nextZoom = transform[2] * Math.pow(2, pinchDelta * factor);\n            panZoom.scaleTo(nextZoom);\n        };\n        let panStart = [0, 0];\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const panStartHandler = (event) => {\n            if (event.sourceEvent.type === 'mousedown' || event.sourceEvent.type === 'touchstart') {\n                panStart = [\n                    event.sourceEvent.clientX ?? event.sourceEvent.touches[0].clientX,\n                    event.sourceEvent.clientY ?? event.sourceEvent.touches[0].clientY,\n                ];\n            }\n        };\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const panHandler = (event) => {\n            const transform = getTransform();\n            if ((event.sourceEvent.type !== 'mousemove' && event.sourceEvent.type !== 'touchmove') || !panZoom) {\n                return;\n            }\n            const panCurrent = [\n                event.sourceEvent.clientX ?? event.sourceEvent.touches[0].clientX,\n                event.sourceEvent.clientY ?? event.sourceEvent.touches[0].clientY,\n            ];\n            const panDelta = [panCurrent[0] - panStart[0], panCurrent[1] - panStart[1]];\n            panStart = panCurrent;\n            const moveScale = getViewScale() * Math.max(transform[2], Math.log(transform[2])) * (inversePan ? -1 : 1);\n            const position = {\n                x: transform[0] - panDelta[0] * moveScale,\n                y: transform[1] - panDelta[1] * moveScale,\n            };\n            const extent = [\n                [0, 0],\n                [width, height],\n            ];\n            panZoom.setViewportConstrained({\n                x: position.x,\n                y: position.y,\n                zoom: transform[2],\n            }, extent, translateExtent);\n        };\n        const zoomAndPanHandler = zoom()\n            .on('start', panStartHandler)\n            // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n            // @ts-ignore\n            .on('zoom', pannable ? panHandler : null)\n            // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n            // @ts-ignore\n            .on('zoom.wheel', zoomable ? zoomHandler : null);\n        selection.call(zoomAndPanHandler, {});\n    }\n    function destroy() {\n        selection.on('zoom', null);\n    }\n    return {\n        update,\n        destroy,\n        pointer,\n    };\n}\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\nconst viewChanged = (prevViewport, eventViewport) => prevViewport.x !== eventViewport.x || prevViewport.y !== eventViewport.y || prevViewport.zoom !== eventViewport.k;\nconst transformToViewport = (transform) => ({\n    x: transform.x,\n    y: transform.y,\n    zoom: transform.k,\n});\nconst viewportToTransform = ({ x, y, zoom }) => zoomIdentity.translate(x, y).scale(zoom);\nconst isWrappedWithClass = (event, className) => event.target.closest(`.${className}`);\nconst isRightClickPan = (panOnDrag, usedButton) => usedButton === 2 && Array.isArray(panOnDrag) && panOnDrag.includes(2);\n// taken from d3-ease: https://github.com/d3/d3-ease/blob/main/src/cubic.js\nconst defaultEase = (t) => ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;\nconst getD3Transition = (selection, duration = 0, ease = defaultEase, onEnd = () => { }) => {\n    const hasDuration = typeof duration === 'number' && duration > 0;\n    if (!hasDuration) {\n        onEnd();\n    }\n    return hasDuration ? selection.transition().duration(duration).ease(ease).on('end', onEnd) : selection;\n};\nconst wheelDelta = (event) => {\n    const factor = event.ctrlKey && isMacOs() ? 10 : 1;\n    return -event.deltaY * (event.deltaMode === 1 ? 0.05 : event.deltaMode ? 1 : 0.002) * factor;\n};\n\nfunction createPanOnScrollHandler({ zoomPanValues, noWheelClassName, d3Selection, d3Zoom, panOnScrollMode, panOnScrollSpeed, zoomOnPinch, onPanZoomStart, onPanZoom, onPanZoomEnd, }) {\n    return (event) => {\n        if (isWrappedWithClass(event, noWheelClassName)) {\n            return false;\n        }\n        event.preventDefault();\n        event.stopImmediatePropagation();\n        const currentZoom = d3Selection.property('__zoom').k || 1;\n        // macos sets ctrlKey=true for pinch gesture on a trackpad\n        if (event.ctrlKey && zoomOnPinch) {\n            const point = pointer(event);\n            const pinchDelta = wheelDelta(event);\n            const zoom = currentZoom * Math.pow(2, pinchDelta);\n            // @ts-ignore\n            d3Zoom.scaleTo(d3Selection, zoom, point, event);\n            return;\n        }\n        /*\n         * increase scroll speed in firefox\n         * firefox: deltaMode === 1; chrome: deltaMode === 0\n         */\n        const deltaNormalize = event.deltaMode === 1 ? 20 : 1;\n        let deltaX = panOnScrollMode === PanOnScrollMode.Vertical ? 0 : event.deltaX * deltaNormalize;\n        let deltaY = panOnScrollMode === PanOnScrollMode.Horizontal ? 0 : event.deltaY * deltaNormalize;\n        // this enables vertical scrolling with shift + scroll on windows\n        if (!isMacOs() && event.shiftKey && panOnScrollMode !== PanOnScrollMode.Vertical) {\n            deltaX = event.deltaY * deltaNormalize;\n            deltaY = 0;\n        }\n        d3Zoom.translateBy(d3Selection, -(deltaX / currentZoom) * panOnScrollSpeed, -(deltaY / currentZoom) * panOnScrollSpeed, \n        // @ts-ignore\n        { internal: true });\n        const nextViewport = transformToViewport(d3Selection.property('__zoom'));\n        clearTimeout(zoomPanValues.panScrollTimeout);\n        /*\n         * for pan on scroll we need to handle the event calls on our own\n         * we can't use the start, zoom and end events from d3-zoom\n         * because start and move gets called on every scroll event and not once at the beginning\n         */\n        if (!zoomPanValues.isPanScrolling) {\n            zoomPanValues.isPanScrolling = true;\n            onPanZoomStart?.(event, nextViewport);\n        }\n        if (zoomPanValues.isPanScrolling) {\n            onPanZoom?.(event, nextViewport);\n            zoomPanValues.panScrollTimeout = setTimeout(() => {\n                onPanZoomEnd?.(event, nextViewport);\n                zoomPanValues.isPanScrolling = false;\n            }, 150);\n        }\n    };\n}\nfunction createZoomOnScrollHandler({ noWheelClassName, preventScrolling, d3ZoomHandler }) {\n    return function (event, d) {\n        const isWheel = event.type === 'wheel';\n        // we still want to enable pinch zooming even if preventScrolling is set to false\n        const preventZoom = !preventScrolling && isWheel && !event.ctrlKey;\n        const hasNoWheelClass = isWrappedWithClass(event, noWheelClassName);\n        // if user is pinch zooming above a nowheel element, we don't want the browser to zoom\n        if (event.ctrlKey && isWheel && hasNoWheelClass) {\n            event.preventDefault();\n        }\n        if (preventZoom || hasNoWheelClass) {\n            return null;\n        }\n        event.preventDefault();\n        d3ZoomHandler.call(this, event, d);\n    };\n}\nfunction createPanZoomStartHandler({ zoomPanValues, onDraggingChange, onPanZoomStart }) {\n    return (event) => {\n        if (event.sourceEvent?.internal) {\n            return;\n        }\n        const viewport = transformToViewport(event.transform);\n        // we need to remember it here, because it's always 0 in the \"zoom\" event\n        zoomPanValues.mouseButton = event.sourceEvent?.button || 0;\n        zoomPanValues.isZoomingOrPanning = true;\n        zoomPanValues.prevViewport = viewport;\n        if (event.sourceEvent?.type === 'mousedown') {\n            onDraggingChange(true);\n        }\n        if (onPanZoomStart) {\n            onPanZoomStart?.(event.sourceEvent, viewport);\n        }\n    };\n}\nfunction createPanZoomHandler({ zoomPanValues, panOnDrag, onPaneContextMenu, onTransformChange, onPanZoom, }) {\n    return (event) => {\n        zoomPanValues.usedRightMouseButton = !!(onPaneContextMenu && isRightClickPan(panOnDrag, zoomPanValues.mouseButton ?? 0));\n        if (!event.sourceEvent?.sync) {\n            onTransformChange([event.transform.x, event.transform.y, event.transform.k]);\n        }\n        if (onPanZoom && !event.sourceEvent?.internal) {\n            onPanZoom?.(event.sourceEvent, transformToViewport(event.transform));\n        }\n    };\n}\nfunction createPanZoomEndHandler({ zoomPanValues, panOnDrag, panOnScroll, onDraggingChange, onPanZoomEnd, onPaneContextMenu, }) {\n    return (event) => {\n        if (event.sourceEvent?.internal) {\n            return;\n        }\n        zoomPanValues.isZoomingOrPanning = false;\n        if (onPaneContextMenu &&\n            isRightClickPan(panOnDrag, zoomPanValues.mouseButton ?? 0) &&\n            !zoomPanValues.usedRightMouseButton &&\n            event.sourceEvent) {\n            onPaneContextMenu(event.sourceEvent);\n        }\n        zoomPanValues.usedRightMouseButton = false;\n        onDraggingChange(false);\n        if (onPanZoomEnd && viewChanged(zoomPanValues.prevViewport, event.transform)) {\n            const viewport = transformToViewport(event.transform);\n            zoomPanValues.prevViewport = viewport;\n            clearTimeout(zoomPanValues.timerId);\n            zoomPanValues.timerId = setTimeout(() => {\n                onPanZoomEnd?.(event.sourceEvent, viewport);\n            }, \n            // we need a setTimeout for panOnScroll to supress multiple end events fired during scroll\n            panOnScroll ? 150 : 0);\n        }\n    };\n}\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\nfunction createFilter({ zoomActivationKeyPressed, zoomOnScroll, zoomOnPinch, panOnDrag, panOnScroll, zoomOnDoubleClick, userSelectionActive, noWheelClassName, noPanClassName, lib, }) {\n    return (event) => {\n        const zoomScroll = zoomActivationKeyPressed || zoomOnScroll;\n        const pinchZoom = zoomOnPinch && event.ctrlKey;\n        if (event.button === 1 &&\n            event.type === 'mousedown' &&\n            (isWrappedWithClass(event, `${lib}-flow__node`) || isWrappedWithClass(event, `${lib}-flow__edge`))) {\n            return true;\n        }\n        // if all interactions are disabled, we prevent all zoom events\n        if (!panOnDrag && !zoomScroll && !panOnScroll && !zoomOnDoubleClick && !zoomOnPinch) {\n            return false;\n        }\n        // during a selection we prevent all other interactions\n        if (userSelectionActive) {\n            return false;\n        }\n        // if the target element is inside an element with the nowheel class, we prevent zooming\n        if (isWrappedWithClass(event, noWheelClassName) && event.type === 'wheel') {\n            return false;\n        }\n        // if the target element is inside an element with the nopan class, we prevent panning\n        if (isWrappedWithClass(event, noPanClassName) &&\n            (event.type !== 'wheel' || (panOnScroll && event.type === 'wheel' && !zoomActivationKeyPressed))) {\n            return false;\n        }\n        if (!zoomOnPinch && event.ctrlKey && event.type === 'wheel') {\n            return false;\n        }\n        if (!zoomOnPinch && event.type === 'touchstart' && event.touches?.length > 1) {\n            event.preventDefault(); // if you manage to start with 2 touches, we prevent native zoom\n            return false;\n        }\n        // when there is no scroll handling enabled, we prevent all wheel events\n        if (!zoomScroll && !panOnScroll && !pinchZoom && event.type === 'wheel') {\n            return false;\n        }\n        // if the pane is not movable, we prevent dragging it with mousestart or touchstart\n        if (!panOnDrag && (event.type === 'mousedown' || event.type === 'touchstart')) {\n            return false;\n        }\n        // if the pane is only movable using allowed clicks\n        if (Array.isArray(panOnDrag) && !panOnDrag.includes(event.button) && event.type === 'mousedown') {\n            return false;\n        }\n        // We only allow right clicks if pan on drag is set to right click\n        const buttonAllowed = (Array.isArray(panOnDrag) && panOnDrag.includes(event.button)) || !event.button || event.button <= 1;\n        // default filter for d3-zoom\n        return (!event.ctrlKey || event.type === 'wheel') && buttonAllowed;\n    };\n}\n\nfunction XYPanZoom({ domNode, minZoom, maxZoom, paneClickDistance, translateExtent, viewport, onPanZoom, onPanZoomStart, onPanZoomEnd, onDraggingChange, }) {\n    const zoomPanValues = {\n        isZoomingOrPanning: false,\n        usedRightMouseButton: false,\n        prevViewport: { x: 0, y: 0, zoom: 0 },\n        mouseButton: 0,\n        timerId: undefined,\n        panScrollTimeout: undefined,\n        isPanScrolling: false,\n    };\n    const bbox = domNode.getBoundingClientRect();\n    const d3ZoomInstance = zoom()\n        .clickDistance(!isNumeric(paneClickDistance) || paneClickDistance < 0 ? 0 : paneClickDistance)\n        .scaleExtent([minZoom, maxZoom])\n        .translateExtent(translateExtent);\n    const d3Selection = select(domNode).call(d3ZoomInstance);\n    setViewportConstrained({\n        x: viewport.x,\n        y: viewport.y,\n        zoom: clamp(viewport.zoom, minZoom, maxZoom),\n    }, [\n        [0, 0],\n        [bbox.width, bbox.height],\n    ], translateExtent);\n    const d3ZoomHandler = d3Selection.on('wheel.zoom');\n    const d3DblClickZoomHandler = d3Selection.on('dblclick.zoom');\n    d3ZoomInstance.wheelDelta(wheelDelta);\n    function setTransform(transform, options) {\n        if (d3Selection) {\n            return new Promise((resolve) => {\n                d3ZoomInstance?.interpolate(options?.interpolate === 'linear' ? interpolate : interpolateZoom).transform(getD3Transition(d3Selection, options?.duration, options?.ease, () => resolve(true)), transform);\n            });\n        }\n        return Promise.resolve(false);\n    }\n    // public functions\n    function update({ noWheelClassName, noPanClassName, onPaneContextMenu, userSelectionActive, panOnScroll, panOnDrag, panOnScrollMode, panOnScrollSpeed, preventScrolling, zoomOnPinch, zoomOnScroll, zoomOnDoubleClick, zoomActivationKeyPressed, lib, onTransformChange, }) {\n        if (userSelectionActive && !zoomPanValues.isZoomingOrPanning) {\n            destroy();\n        }\n        const isPanOnScroll = panOnScroll && !zoomActivationKeyPressed && !userSelectionActive;\n        const wheelHandler = isPanOnScroll\n            ? createPanOnScrollHandler({\n                zoomPanValues,\n                noWheelClassName,\n                d3Selection,\n                d3Zoom: d3ZoomInstance,\n                panOnScrollMode,\n                panOnScrollSpeed,\n                zoomOnPinch,\n                onPanZoomStart,\n                onPanZoom,\n                onPanZoomEnd,\n            })\n            : createZoomOnScrollHandler({\n                noWheelClassName,\n                preventScrolling,\n                d3ZoomHandler,\n            });\n        d3Selection.on('wheel.zoom', wheelHandler, { passive: false });\n        if (!userSelectionActive) {\n            // pan zoom start\n            const startHandler = createPanZoomStartHandler({\n                zoomPanValues,\n                onDraggingChange,\n                onPanZoomStart,\n            });\n            d3ZoomInstance.on('start', startHandler);\n            // pan zoom\n            const panZoomHandler = createPanZoomHandler({\n                zoomPanValues,\n                panOnDrag,\n                onPaneContextMenu: !!onPaneContextMenu,\n                onPanZoom,\n                onTransformChange,\n            });\n            d3ZoomInstance.on('zoom', panZoomHandler);\n            // pan zoom end\n            const panZoomEndHandler = createPanZoomEndHandler({\n                zoomPanValues,\n                panOnDrag,\n                panOnScroll,\n                onPaneContextMenu,\n                onPanZoomEnd,\n                onDraggingChange,\n            });\n            d3ZoomInstance.on('end', panZoomEndHandler);\n        }\n        const filter = createFilter({\n            zoomActivationKeyPressed,\n            panOnDrag,\n            zoomOnScroll,\n            panOnScroll,\n            zoomOnDoubleClick,\n            zoomOnPinch,\n            userSelectionActive,\n            noPanClassName,\n            noWheelClassName,\n            lib,\n        });\n        d3ZoomInstance.filter(filter);\n        /*\n         * We cannot add zoomOnDoubleClick to the filter above because\n         * double tapping on touch screens circumvents the filter and\n         * dblclick.zoom is fired on the selection directly\n         */\n        if (zoomOnDoubleClick) {\n            d3Selection.on('dblclick.zoom', d3DblClickZoomHandler);\n        }\n        else {\n            d3Selection.on('dblclick.zoom', null);\n        }\n    }\n    function destroy() {\n        d3ZoomInstance.on('zoom', null);\n    }\n    async function setViewportConstrained(viewport, extent, translateExtent) {\n        const nextTransform = viewportToTransform(viewport);\n        const contrainedTransform = d3ZoomInstance?.constrain()(nextTransform, extent, translateExtent);\n        if (contrainedTransform) {\n            await setTransform(contrainedTransform);\n        }\n        return new Promise((resolve) => resolve(contrainedTransform));\n    }\n    async function setViewport(viewport, options) {\n        const nextTransform = viewportToTransform(viewport);\n        await setTransform(nextTransform, options);\n        return new Promise((resolve) => resolve(nextTransform));\n    }\n    function syncViewport(viewport) {\n        if (d3Selection) {\n            const nextTransform = viewportToTransform(viewport);\n            const currentTransform = d3Selection.property('__zoom');\n            if (currentTransform.k !== viewport.zoom ||\n                currentTransform.x !== viewport.x ||\n                currentTransform.y !== viewport.y) {\n                // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n                // @ts-ignore\n                d3ZoomInstance?.transform(d3Selection, nextTransform, null, { sync: true });\n            }\n        }\n    }\n    function getViewport() {\n        const transform = d3Selection ? zoomTransform(d3Selection.node()) : { x: 0, y: 0, k: 1 };\n        return { x: transform.x, y: transform.y, zoom: transform.k };\n    }\n    function scaleTo(zoom, options) {\n        if (d3Selection) {\n            return new Promise((resolve) => {\n                d3ZoomInstance?.interpolate(options?.interpolate === 'linear' ? interpolate : interpolateZoom).scaleTo(getD3Transition(d3Selection, options?.duration, options?.ease, () => resolve(true)), zoom);\n            });\n        }\n        return Promise.resolve(false);\n    }\n    function scaleBy(factor, options) {\n        if (d3Selection) {\n            return new Promise((resolve) => {\n                d3ZoomInstance?.interpolate(options?.interpolate === 'linear' ? interpolate : interpolateZoom).scaleBy(getD3Transition(d3Selection, options?.duration, options?.ease, () => resolve(true)), factor);\n            });\n        }\n        return Promise.resolve(false);\n    }\n    function setScaleExtent(scaleExtent) {\n        d3ZoomInstance?.scaleExtent(scaleExtent);\n    }\n    function setTranslateExtent(translateExtent) {\n        d3ZoomInstance?.translateExtent(translateExtent);\n    }\n    function setClickDistance(distance) {\n        const validDistance = !isNumeric(distance) || distance < 0 ? 0 : distance;\n        d3ZoomInstance?.clickDistance(validDistance);\n    }\n    return {\n        update,\n        destroy,\n        setViewport,\n        setViewportConstrained,\n        getViewport,\n        scaleTo,\n        scaleBy,\n        setScaleExtent,\n        setTranslateExtent,\n        syncViewport,\n        setClickDistance,\n    };\n}\n\n/**\n * Used to determine the variant of the resize control\n *\n * @public\n */\nvar ResizeControlVariant;\n(function (ResizeControlVariant) {\n    ResizeControlVariant[\"Line\"] = \"line\";\n    ResizeControlVariant[\"Handle\"] = \"handle\";\n})(ResizeControlVariant || (ResizeControlVariant = {}));\nconst XY_RESIZER_HANDLE_POSITIONS = ['top-left', 'top-right', 'bottom-left', 'bottom-right'];\nconst XY_RESIZER_LINE_POSITIONS = ['top', 'right', 'bottom', 'left'];\n\n/**\n * Get all connecting edges for a given set of nodes\n * @param width - new width of the node\n * @param prevWidth - previous width of the node\n * @param height - new height of the node\n * @param prevHeight - previous height of the node\n * @param affectsX - whether to invert the resize direction for the x axis\n * @param affectsY - whether to invert the resize direction for the y axis\n * @returns array of two numbers representing the direction of the resize for each axis, 0 = no change, 1 = increase, -1 = decrease\n */\nfunction getResizeDirection({ width, prevWidth, height, prevHeight, affectsX, affectsY, }) {\n    const deltaWidth = width - prevWidth;\n    const deltaHeight = height - prevHeight;\n    const direction = [deltaWidth > 0 ? 1 : deltaWidth < 0 ? -1 : 0, deltaHeight > 0 ? 1 : deltaHeight < 0 ? -1 : 0];\n    if (deltaWidth && affectsX) {\n        direction[0] = direction[0] * -1;\n    }\n    if (deltaHeight && affectsY) {\n        direction[1] = direction[1] * -1;\n    }\n    return direction;\n}\n/**\n * Parses the control position that is being dragged to dimensions that are being resized\n * @param controlPosition - position of the control that is being dragged\n * @returns isHorizontal, isVertical, affectsX, affectsY,\n */\nfunction getControlDirection(controlPosition) {\n    const isHorizontal = controlPosition.includes('right') || controlPosition.includes('left');\n    const isVertical = controlPosition.includes('bottom') || controlPosition.includes('top');\n    const affectsX = controlPosition.includes('left');\n    const affectsY = controlPosition.includes('top');\n    return {\n        isHorizontal,\n        isVertical,\n        affectsX,\n        affectsY,\n    };\n}\nfunction getLowerExtentClamp(lowerExtent, lowerBound) {\n    return Math.max(0, lowerBound - lowerExtent);\n}\nfunction getUpperExtentClamp(upperExtent, upperBound) {\n    return Math.max(0, upperExtent - upperBound);\n}\nfunction getSizeClamp(size, minSize, maxSize) {\n    return Math.max(0, minSize - size, size - maxSize);\n}\nfunction xor(a, b) {\n    return a ? !b : b;\n}\n/**\n * Calculates new width & height and x & y of node after resize based on pointer position\n * @description - Buckle up, this is a chunky one... If you want to determine the new dimensions of a node after a resize,\n * you have to account for all possible restrictions: min/max width/height of the node, the maximum extent the node is allowed\n * to move in (in this case: resize into) determined by the parent node, the minimal extent determined by child nodes\n * with expandParent or extent: 'parent' set and oh yeah, these things also have to work with keepAspectRatio!\n * The way this is done is by determining how much each of these restricting actually restricts the resize and then applying the\n * strongest restriction. Because the resize affects x, y and width, height and width, height of a opposing side with keepAspectRatio,\n * the resize amount is always kept in distX & distY amount (the distance in mouse movement)\n * Instead of clamping each value, we first calculate the biggest 'clamp' (for the lack of a better name) and then apply it to all values.\n * To complicate things nodeOrigin has to be taken into account as well. This is done by offsetting the nodes as if their origin is [0, 0],\n * then calculating the restrictions as usual\n * @param startValues - starting values of resize\n * @param controlDirection - dimensions affected by the resize\n * @param pointerPosition - the current pointer position corrected for snapping\n * @param boundaries - minimum and maximum dimensions of the node\n * @param keepAspectRatio - prevent changes of asprect ratio\n * @returns x, y, width and height of the node after resize\n */\nfunction getDimensionsAfterResize(startValues, controlDirection, pointerPosition, boundaries, keepAspectRatio, nodeOrigin, extent, childExtent) {\n    let { affectsX, affectsY } = controlDirection;\n    const { isHorizontal, isVertical } = controlDirection;\n    const isDiagonal = isHorizontal && isVertical;\n    const { xSnapped, ySnapped } = pointerPosition;\n    const { minWidth, maxWidth, minHeight, maxHeight } = boundaries;\n    const { x: startX, y: startY, width: startWidth, height: startHeight, aspectRatio } = startValues;\n    let distX = Math.floor(isHorizontal ? xSnapped - startValues.pointerX : 0);\n    let distY = Math.floor(isVertical ? ySnapped - startValues.pointerY : 0);\n    const newWidth = startWidth + (affectsX ? -distX : distX);\n    const newHeight = startHeight + (affectsY ? -distY : distY);\n    const originOffsetX = -nodeOrigin[0] * startWidth;\n    const originOffsetY = -nodeOrigin[1] * startHeight;\n    // Check if maxWidth, minWWidth, maxHeight, minHeight are restricting the resize\n    let clampX = getSizeClamp(newWidth, minWidth, maxWidth);\n    let clampY = getSizeClamp(newHeight, minHeight, maxHeight);\n    // Check if extent is restricting the resize\n    if (extent) {\n        let xExtentClamp = 0;\n        let yExtentClamp = 0;\n        if (affectsX && distX < 0) {\n            xExtentClamp = getLowerExtentClamp(startX + distX + originOffsetX, extent[0][0]);\n        }\n        else if (!affectsX && distX > 0) {\n            xExtentClamp = getUpperExtentClamp(startX + newWidth + originOffsetX, extent[1][0]);\n        }\n        if (affectsY && distY < 0) {\n            yExtentClamp = getLowerExtentClamp(startY + distY + originOffsetY, extent[0][1]);\n        }\n        else if (!affectsY && distY > 0) {\n            yExtentClamp = getUpperExtentClamp(startY + newHeight + originOffsetY, extent[1][1]);\n        }\n        clampX = Math.max(clampX, xExtentClamp);\n        clampY = Math.max(clampY, yExtentClamp);\n    }\n    // Check if the child extent is restricting the resize\n    if (childExtent) {\n        let xExtentClamp = 0;\n        let yExtentClamp = 0;\n        if (affectsX && distX > 0) {\n            xExtentClamp = getUpperExtentClamp(startX + distX, childExtent[0][0]);\n        }\n        else if (!affectsX && distX < 0) {\n            xExtentClamp = getLowerExtentClamp(startX + newWidth, childExtent[1][0]);\n        }\n        if (affectsY && distY > 0) {\n            yExtentClamp = getUpperExtentClamp(startY + distY, childExtent[0][1]);\n        }\n        else if (!affectsY && distY < 0) {\n            yExtentClamp = getLowerExtentClamp(startY + newHeight, childExtent[1][1]);\n        }\n        clampX = Math.max(clampX, xExtentClamp);\n        clampY = Math.max(clampY, yExtentClamp);\n    }\n    // Check if the aspect ratio resizing of the other side is restricting the resize\n    if (keepAspectRatio) {\n        if (isHorizontal) {\n            // Check if the max dimensions might be restricting the resize\n            const aspectHeightClamp = getSizeClamp(newWidth / aspectRatio, minHeight, maxHeight) * aspectRatio;\n            clampX = Math.max(clampX, aspectHeightClamp);\n            // Check if the extent is restricting the resize\n            if (extent) {\n                let aspectExtentClamp = 0;\n                if ((!affectsX && !affectsY) || (affectsX && !affectsY && isDiagonal)) {\n                    aspectExtentClamp =\n                        getUpperExtentClamp(startY + originOffsetY + newWidth / aspectRatio, extent[1][1]) * aspectRatio;\n                }\n                else {\n                    aspectExtentClamp =\n                        getLowerExtentClamp(startY + originOffsetY + (affectsX ? distX : -distX) / aspectRatio, extent[0][1]) *\n                            aspectRatio;\n                }\n                clampX = Math.max(clampX, aspectExtentClamp);\n            }\n            // Check if the child extent is restricting the resize\n            if (childExtent) {\n                let aspectExtentClamp = 0;\n                if ((!affectsX && !affectsY) || (affectsX && !affectsY && isDiagonal)) {\n                    aspectExtentClamp = getLowerExtentClamp(startY + newWidth / aspectRatio, childExtent[1][1]) * aspectRatio;\n                }\n                else {\n                    aspectExtentClamp =\n                        getUpperExtentClamp(startY + (affectsX ? distX : -distX) / aspectRatio, childExtent[0][1]) * aspectRatio;\n                }\n                clampX = Math.max(clampX, aspectExtentClamp);\n            }\n        }\n        // Do the same thing for vertical resizing\n        if (isVertical) {\n            const aspectWidthClamp = getSizeClamp(newHeight * aspectRatio, minWidth, maxWidth) / aspectRatio;\n            clampY = Math.max(clampY, aspectWidthClamp);\n            if (extent) {\n                let aspectExtentClamp = 0;\n                if ((!affectsX && !affectsY) || (affectsY && !affectsX && isDiagonal)) {\n                    aspectExtentClamp =\n                        getUpperExtentClamp(startX + newHeight * aspectRatio + originOffsetX, extent[1][0]) / aspectRatio;\n                }\n                else {\n                    aspectExtentClamp =\n                        getLowerExtentClamp(startX + (affectsY ? distY : -distY) * aspectRatio + originOffsetX, extent[0][0]) /\n                            aspectRatio;\n                }\n                clampY = Math.max(clampY, aspectExtentClamp);\n            }\n            if (childExtent) {\n                let aspectExtentClamp = 0;\n                if ((!affectsX && !affectsY) || (affectsY && !affectsX && isDiagonal)) {\n                    aspectExtentClamp = getLowerExtentClamp(startX + newHeight * aspectRatio, childExtent[1][0]) / aspectRatio;\n                }\n                else {\n                    aspectExtentClamp =\n                        getUpperExtentClamp(startX + (affectsY ? distY : -distY) * aspectRatio, childExtent[0][0]) / aspectRatio;\n                }\n                clampY = Math.max(clampY, aspectExtentClamp);\n            }\n        }\n    }\n    distY = distY + (distY < 0 ? clampY : -clampY);\n    distX = distX + (distX < 0 ? clampX : -clampX);\n    if (keepAspectRatio) {\n        if (isDiagonal) {\n            if (newWidth > newHeight * aspectRatio) {\n                distY = (xor(affectsX, affectsY) ? -distX : distX) / aspectRatio;\n            }\n            else {\n                distX = (xor(affectsX, affectsY) ? -distY : distY) * aspectRatio;\n            }\n        }\n        else {\n            if (isHorizontal) {\n                distY = distX / aspectRatio;\n                affectsY = affectsX;\n            }\n            else {\n                distX = distY * aspectRatio;\n                affectsX = affectsY;\n            }\n        }\n    }\n    const x = affectsX ? startX + distX : startX;\n    const y = affectsY ? startY + distY : startY;\n    return {\n        width: startWidth + (affectsX ? -distX : distX),\n        height: startHeight + (affectsY ? -distY : distY),\n        x: nodeOrigin[0] * distX * (!affectsX ? 1 : -1) + x,\n        y: nodeOrigin[1] * distY * (!affectsY ? 1 : -1) + y,\n    };\n}\n\nconst initPrevValues = { width: 0, height: 0, x: 0, y: 0 };\nconst initStartValues = {\n    ...initPrevValues,\n    pointerX: 0,\n    pointerY: 0,\n    aspectRatio: 1,\n};\nfunction nodeToParentExtent(node) {\n    return [\n        [0, 0],\n        [node.measured.width, node.measured.height],\n    ];\n}\nfunction nodeToChildExtent(child, parent, nodeOrigin) {\n    const x = parent.position.x + child.position.x;\n    const y = parent.position.y + child.position.y;\n    const width = child.measured.width ?? 0;\n    const height = child.measured.height ?? 0;\n    const originOffsetX = nodeOrigin[0] * width;\n    const originOffsetY = nodeOrigin[1] * height;\n    return [\n        [x - originOffsetX, y - originOffsetY],\n        [x + width - originOffsetX, y + height - originOffsetY],\n    ];\n}\nfunction XYResizer({ domNode, nodeId, getStoreItems, onChange, onEnd }) {\n    const selection = select(domNode);\n    function update({ controlPosition, boundaries, keepAspectRatio, resizeDirection, onResizeStart, onResize, onResizeEnd, shouldResize, }) {\n        let prevValues = { ...initPrevValues };\n        let startValues = { ...initStartValues };\n        const controlDirection = getControlDirection(controlPosition);\n        let node = undefined;\n        let containerBounds = null;\n        let childNodes = [];\n        let parentNode = undefined; // Needed to fix expandParent\n        let parentExtent = undefined;\n        let childExtent = undefined;\n        const dragHandler = drag()\n            .on('start', (event) => {\n            const { nodeLookup, transform, snapGrid, snapToGrid, nodeOrigin, paneDomNode } = getStoreItems();\n            node = nodeLookup.get(nodeId);\n            if (!node) {\n                return;\n            }\n            containerBounds = paneDomNode?.getBoundingClientRect() ?? null;\n            const { xSnapped, ySnapped } = getPointerPosition(event.sourceEvent, {\n                transform,\n                snapGrid,\n                snapToGrid,\n                containerBounds,\n            });\n            prevValues = {\n                width: node.measured.width ?? 0,\n                height: node.measured.height ?? 0,\n                x: node.position.x ?? 0,\n                y: node.position.y ?? 0,\n            };\n            startValues = {\n                ...prevValues,\n                pointerX: xSnapped,\n                pointerY: ySnapped,\n                aspectRatio: prevValues.width / prevValues.height,\n            };\n            parentNode = undefined;\n            if (node.parentId && (node.extent === 'parent' || node.expandParent)) {\n                parentNode = nodeLookup.get(node.parentId);\n                parentExtent = parentNode && node.extent === 'parent' ? nodeToParentExtent(parentNode) : undefined;\n            }\n            /*\n             * Collect all child nodes to correct their relative positions when top/left changes\n             * Determine largest minimal extent the parent node is allowed to resize to\n             */\n            childNodes = [];\n            childExtent = undefined;\n            for (const [childId, child] of nodeLookup) {\n                if (child.parentId === nodeId) {\n                    childNodes.push({\n                        id: childId,\n                        position: { ...child.position },\n                        extent: child.extent,\n                    });\n                    if (child.extent === 'parent' || child.expandParent) {\n                        const extent = nodeToChildExtent(child, node, child.origin ?? nodeOrigin);\n                        if (childExtent) {\n                            childExtent = [\n                                [Math.min(extent[0][0], childExtent[0][0]), Math.min(extent[0][1], childExtent[0][1])],\n                                [Math.max(extent[1][0], childExtent[1][0]), Math.max(extent[1][1], childExtent[1][1])],\n                            ];\n                        }\n                        else {\n                            childExtent = extent;\n                        }\n                    }\n                }\n            }\n            onResizeStart?.(event, { ...prevValues });\n        })\n            .on('drag', (event) => {\n            const { transform, snapGrid, snapToGrid, nodeOrigin: storeNodeOrigin } = getStoreItems();\n            const pointerPosition = getPointerPosition(event.sourceEvent, {\n                transform,\n                snapGrid,\n                snapToGrid,\n                containerBounds,\n            });\n            const childChanges = [];\n            if (!node) {\n                return;\n            }\n            const { x: prevX, y: prevY, width: prevWidth, height: prevHeight } = prevValues;\n            const change = {};\n            const nodeOrigin = node.origin ?? storeNodeOrigin;\n            const { width, height, x, y } = getDimensionsAfterResize(startValues, controlDirection, pointerPosition, boundaries, keepAspectRatio, nodeOrigin, parentExtent, childExtent);\n            const isWidthChange = width !== prevWidth;\n            const isHeightChange = height !== prevHeight;\n            const isXPosChange = x !== prevX && isWidthChange;\n            const isYPosChange = y !== prevY && isHeightChange;\n            if (!isXPosChange && !isYPosChange && !isWidthChange && !isHeightChange) {\n                return;\n            }\n            if (isXPosChange || isYPosChange || nodeOrigin[0] === 1 || nodeOrigin[1] === 1) {\n                change.x = isXPosChange ? x : prevValues.x;\n                change.y = isYPosChange ? y : prevValues.y;\n                prevValues.x = change.x;\n                prevValues.y = change.y;\n                /*\n                 * when top/left changes, correct the relative positions of child nodes\n                 * so that they stay in the same position\n                 */\n                if (childNodes.length > 0) {\n                    const xChange = x - prevX;\n                    const yChange = y - prevY;\n                    for (const childNode of childNodes) {\n                        childNode.position = {\n                            x: childNode.position.x - xChange + nodeOrigin[0] * (width - prevWidth),\n                            y: childNode.position.y - yChange + nodeOrigin[1] * (height - prevHeight),\n                        };\n                        childChanges.push(childNode);\n                    }\n                }\n            }\n            if (isWidthChange || isHeightChange) {\n                change.width =\n                    isWidthChange && (!resizeDirection || resizeDirection === 'horizontal') ? width : prevValues.width;\n                change.height =\n                    isHeightChange && (!resizeDirection || resizeDirection === 'vertical') ? height : prevValues.height;\n                prevValues.width = change.width;\n                prevValues.height = change.height;\n            }\n            // Fix expandParent when resizing from top/left\n            if (parentNode && node.expandParent) {\n                const xLimit = nodeOrigin[0] * (change.width ?? 0);\n                if (change.x && change.x < xLimit) {\n                    prevValues.x = xLimit;\n                    startValues.x = startValues.x - (change.x - xLimit);\n                }\n                const yLimit = nodeOrigin[1] * (change.height ?? 0);\n                if (change.y && change.y < yLimit) {\n                    prevValues.y = yLimit;\n                    startValues.y = startValues.y - (change.y - yLimit);\n                }\n            }\n            const direction = getResizeDirection({\n                width: prevValues.width,\n                prevWidth,\n                height: prevValues.height,\n                prevHeight,\n                affectsX: controlDirection.affectsX,\n                affectsY: controlDirection.affectsY,\n            });\n            const nextValues = { ...prevValues, direction };\n            const callResize = shouldResize?.(event, nextValues);\n            if (callResize === false) {\n                return;\n            }\n            onResize?.(event, nextValues);\n            onChange(change, childChanges);\n        })\n            .on('end', (event) => {\n            onResizeEnd?.(event, { ...prevValues });\n            onEnd?.({ ...prevValues });\n        });\n        selection.call(dragHandler);\n    }\n    function destroy() {\n        selection.on('.drag', null);\n    }\n    return {\n        update,\n        destroy,\n    };\n}\n\nexport { ConnectionLineType, ConnectionMode, MarkerType, PanOnScrollMode, Position, ResizeControlVariant, SelectionMode, XYDrag, XYHandle, XYMinimap, XYPanZoom, XYResizer, XY_RESIZER_HANDLE_POSITIONS, XY_RESIZER_LINE_POSITIONS, addEdge, adoptUserNodes, areConnectionMapsEqual, areSetsEqual, boxToRect, calcAutoPan, calculateNodePosition, clamp, clampPosition, clampPositionToParent, createMarkerIds, defaultAriaLabelConfig, devWarn, elementSelectionKeys, errorMessages, evaluateAbsolutePosition, fitViewport, getBezierEdgeCenter, getBezierPath, getBoundsOfBoxes, getBoundsOfRects, getConnectedEdges, getConnectionStatus, getDimensions, getEdgeCenter, getEdgePosition, getElementsToRemove, getElevatedEdgeZIndex, getEventPosition, getHandleBounds, getHandlePosition, getHostForElement, getIncomers, getInternalNodesBounds, getMarkerId, getNodeDimensions, getNodePositionWithOrigin, getNodeToolbarTransform, getNodesBounds, getNodesInside, getOutgoers, getOverlappingArea, getPointerPosition, getSmoothStepPath, getStraightPath, getViewportForBounds, handleConnectionChange, handleExpandParent, infiniteExtent, initialConnection, isCoordinateExtent, isEdgeBase, isEdgeVisible, isInputDOMNode, isInternalNodeBase, isMacOs, isMouseEvent, isNodeBase, isNumeric, isRectObject, mergeAriaLabelConfig, nodeHasDimensions, nodeToBox, nodeToRect, oppositePosition, panBy, pointToRendererPoint, reconnectEdge, rectToBox, rendererPointToPoint, shallowNodeData, snapPosition, updateAbsolutePositions, updateConnectionLookup, updateNodeInternals, withResolvers };\n"],"mappings":"AAAA,SAASA,IAAI,QAAQ,SAAS;AAC9B,SAASC,MAAM,EAAEC,OAAO,QAAQ,cAAc;AAC9C,SAASC,IAAI,EAAEC,YAAY,EAAEC,aAAa,QAAQ,SAAS;AAC3D,SAASC,eAAe,EAAEC,WAAW,QAAQ,gBAAgB;AAE7D,MAAMC,aAAa,GAAG;EAClBC,QAAQ,EAAEA,CAAA,KAAM,mHAAmH;EACnIC,QAAQ,EAAEA,CAAA,KAAM,6KAA6K;EAC7LC,QAAQ,EAAGC,QAAQ,IAAK,cAAcA,QAAQ,6CAA6C;EAC3FC,QAAQ,EAAEA,CAAA,KAAM,iFAAiF;EACjGC,QAAQ,EAAEA,CAAA,KAAM,2CAA2C;EAC3DC,QAAQ,EAAEA,CAAA,KAAM,yDAAyD;EACzEC,QAAQ,EAAGC,EAAE,IAAK,wBAAwBA,EAAE,kBAAkB;EAC9DC,QAAQ,EAAGC,IAAI,IAAK,gBAAgBA,IAAI,kBAAkB;EAC1DC,QAAQ,EAAEA,CAACC,UAAU,EAAE;IAAEJ,EAAE;IAAEK,YAAY;IAAEC;EAAa,CAAC,KAAK,4BAA4BF,UAAU,gBAAgBA,UAAU,KAAK,QAAQ,GAAGC,YAAY,GAAGC,YAAY,eAAeN,EAAE,GAAG;EAC7LO,QAAQ,EAAEA,CAAA,KAAM,gFAAgF;EAChGC,QAAQ,EAAGC,QAAQ,IAAK,cAAcA,QAAQ,6CAA6C;EAC3FC,QAAQ,EAAGV,EAAE,IAAK,iBAAiBA,EAAE,gIAAgI;EACrKW,QAAQ,EAAEA,CAACC,GAAG,GAAG,OAAO,KAAK,uEAAuEA,GAAG,2EAA2E;EAClLC,QAAQ,EAAEA,CAAA,KAAM,0GAA0G;EAC1HC,QAAQ,EAAEA,CAAA,KAAM;AACpB,CAAC;AACD,MAAMC,cAAc,GAAG,CACnB,CAACC,MAAM,CAACC,iBAAiB,EAAED,MAAM,CAACC,iBAAiB,CAAC,EACpD,CAACD,MAAM,CAACE,iBAAiB,EAAEF,MAAM,CAACE,iBAAiB,CAAC,CACvD;AACD,MAAMC,oBAAoB,GAAG,CAAC,OAAO,EAAE,GAAG,EAAE,QAAQ,CAAC;AACrD,MAAMC,sBAAsB,GAAG;EAC3B,8BAA8B,EAAE,wFAAwF;EACxH,uCAAuC,EAAE,iJAAiJ;EAC1L,sCAAsC,EAAEC,CAAC;IAAEC,SAAS;IAAEC,CAAC;IAAEC;EAAE,CAAC,KAAK,uBAAuBF,SAAS,sBAAsBC,CAAC,QAAQC,CAAC,EAAE;EACnI,8BAA8B,EAAE,qGAAqG;EACrI;EACA,oBAAoB,EAAE,eAAe;EACrC,2BAA2B,EAAE,SAAS;EACtC,4BAA4B,EAAE,UAAU;EACxC,4BAA4B,EAAE,UAAU;EACxC,gCAAgC,EAAE,sBAAsB;EACxD;EACA,mBAAmB,EAAE,UAAU;EAC/B;EACA,kBAAkB,EAAE;AACxB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAIC,cAAc;AAClB,CAAC,UAAUA,cAAc,EAAE;EACvBA,cAAc,CAAC,QAAQ,CAAC,GAAG,QAAQ;EACnCA,cAAc,CAAC,OAAO,CAAC,GAAG,OAAO;AACrC,CAAC,EAAEA,cAAc,KAAKA,cAAc,GAAG,CAAC,CAAC,CAAC,CAAC;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAIC,eAAe;AACnB,CAAC,UAAUA,eAAe,EAAE;EACxBA,eAAe,CAAC,MAAM,CAAC,GAAG,MAAM;EAChCA,eAAe,CAAC,UAAU,CAAC,GAAG,UAAU;EACxCA,eAAe,CAAC,YAAY,CAAC,GAAG,YAAY;AAChD,CAAC,EAAEA,eAAe,KAAKA,eAAe,GAAG,CAAC,CAAC,CAAC,CAAC;AAC7C,IAAIC,aAAa;AACjB,CAAC,UAAUA,aAAa,EAAE;EACtBA,aAAa,CAAC,SAAS,CAAC,GAAG,SAAS;EACpCA,aAAa,CAAC,MAAM,CAAC,GAAG,MAAM;AAClC,CAAC,EAAEA,aAAa,KAAKA,aAAa,GAAG,CAAC,CAAC,CAAC,CAAC;AACzC,MAAMC,iBAAiB,GAAG;EACtBC,UAAU,EAAE,KAAK;EACjBC,OAAO,EAAE,IAAI;EACbC,IAAI,EAAE,IAAI;EACVC,UAAU,EAAE,IAAI;EAChBC,YAAY,EAAE,IAAI;EAClBC,QAAQ,EAAE,IAAI;EACdC,EAAE,EAAE,IAAI;EACRC,QAAQ,EAAE,IAAI;EACdC,UAAU,EAAE,IAAI;EAChBC,MAAM,EAAE;AACZ,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAIC,kBAAkB;AACtB,CAAC,UAAUA,kBAAkB,EAAE;EAC3BA,kBAAkB,CAAC,QAAQ,CAAC,GAAG,SAAS;EACxCA,kBAAkB,CAAC,UAAU,CAAC,GAAG,UAAU;EAC3CA,kBAAkB,CAAC,MAAM,CAAC,GAAG,MAAM;EACnCA,kBAAkB,CAAC,YAAY,CAAC,GAAG,YAAY;EAC/CA,kBAAkB,CAAC,cAAc,CAAC,GAAG,cAAc;AACvD,CAAC,EAAEA,kBAAkB,KAAKA,kBAAkB,GAAG,CAAC,CAAC,CAAC,CAAC;AACnD;AACA;AACA;AACA;AACA;AACA;AACA,IAAIC,UAAU;AACd,CAAC,UAAUA,UAAU,EAAE;EACnBA,UAAU,CAAC,OAAO,CAAC,GAAG,OAAO;EAC7BA,UAAU,CAAC,aAAa,CAAC,GAAG,aAAa;AAC7C,CAAC,EAAEA,UAAU,KAAKA,UAAU,GAAG,CAAC,CAAC,CAAC,CAAC;;AAEnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAIC,QAAQ;AACZ,CAAC,UAAUA,QAAQ,EAAE;EACjBA,QAAQ,CAAC,MAAM,CAAC,GAAG,MAAM;EACzBA,QAAQ,CAAC,KAAK,CAAC,GAAG,KAAK;EACvBA,QAAQ,CAAC,OAAO,CAAC,GAAG,OAAO;EAC3BA,QAAQ,CAAC,QAAQ,CAAC,GAAG,QAAQ;AACjC,CAAC,EAAEA,QAAQ,KAAKA,QAAQ,GAAG,CAAC,CAAC,CAAC,CAAC;AAC/B,MAAMC,gBAAgB,GAAG;EACrB,CAACD,QAAQ,CAACE,IAAI,GAAGF,QAAQ,CAACG,KAAK;EAC/B,CAACH,QAAQ,CAACG,KAAK,GAAGH,QAAQ,CAACE,IAAI;EAC/B,CAACF,QAAQ,CAACI,GAAG,GAAGJ,QAAQ,CAACK,MAAM;EAC/B,CAACL,QAAQ,CAACK,MAAM,GAAGL,QAAQ,CAACI;AAChC,CAAC;;AAED;AACA;AACA;AACA,SAASE,sBAAsBA,CAACC,CAAC,EAAEC,CAAC,EAAE;EAClC,IAAI,CAACD,CAAC,IAAI,CAACC,CAAC,EAAE;IACV,OAAO,IAAI;EACf;EACA,IAAI,CAACD,CAAC,IAAI,CAACC,CAAC,IAAID,CAAC,CAACE,IAAI,KAAKD,CAAC,CAACC,IAAI,EAAE;IAC/B,OAAO,KAAK;EAChB;EACA,IAAI,CAACF,CAAC,CAACE,IAAI,IAAI,CAACD,CAAC,CAACC,IAAI,EAAE;IACpB,OAAO,IAAI;EACf;EACA,KAAK,MAAMC,GAAG,IAAIH,CAAC,CAACI,IAAI,CAAC,CAAC,EAAE;IACxB,IAAI,CAACH,CAAC,CAACI,GAAG,CAACF,GAAG,CAAC,EAAE;MACb,OAAO,KAAK;IAChB;EACJ;EACA,OAAO,IAAI;AACf;AACA;AACA;AACA;AACA;AACA;AACA,SAASG,sBAAsBA,CAACN,CAAC,EAAEC,CAAC,EAAEM,EAAE,EAAE;EACtC,IAAI,CAACA,EAAE,EAAE;IACL;EACJ;EACA,MAAMC,IAAI,GAAG,EAAE;EACfR,CAAC,CAACS,OAAO,CAAC,CAACC,UAAU,EAAEP,GAAG,KAAK;IAC3B,IAAI,CAACF,CAAC,EAAEI,GAAG,CAACF,GAAG,CAAC,EAAE;MACdK,IAAI,CAACG,IAAI,CAACD,UAAU,CAAC;IACzB;EACJ,CAAC,CAAC;EACF,IAAIF,IAAI,CAACI,MAAM,EAAE;IACbL,EAAE,CAACC,IAAI,CAAC;EACZ;AACJ;AACA,SAASK,mBAAmBA,CAAC/B,OAAO,EAAE;EAClC,OAAOA,OAAO,KAAK,IAAI,GAAG,IAAI,GAAGA,OAAO,GAAG,OAAO,GAAG,SAAS;AAClE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMgC,UAAU,GAAIC,OAAO,IAAK,IAAI,IAAIA,OAAO,IAAI,QAAQ,IAAIA,OAAO,IAAI,QAAQ,IAAIA,OAAO;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,UAAU,GAAID,OAAO,IAAK,IAAI,IAAIA,OAAO,IAAI,UAAU,IAAIA,OAAO,IAAI,EAAE,QAAQ,IAAIA,OAAO,CAAC,IAAI,EAAE,QAAQ,IAAIA,OAAO,CAAC;AAC5H,MAAME,kBAAkB,GAAIF,OAAO,IAAK,IAAI,IAAIA,OAAO,IAAI,WAAW,IAAIA,OAAO,IAAI,EAAE,QAAQ,IAAIA,OAAO,CAAC,IAAI,EAAE,QAAQ,IAAIA,OAAO,CAAC;AACrI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMG,WAAW,GAAGA,CAACC,IAAI,EAAEC,KAAK,EAAEC,KAAK,KAAK;EACxC,IAAI,CAACF,IAAI,CAACnE,EAAE,EAAE;IACV,OAAO,EAAE;EACb;EACA,MAAMsE,UAAU,GAAG,IAAIC,GAAG,CAAC,CAAC;EAC5BF,KAAK,CAACZ,OAAO,CAAEe,IAAI,IAAK;IACpB,IAAIA,IAAI,CAACC,MAAM,KAAKN,IAAI,CAACnE,EAAE,EAAE;MACzBsE,UAAU,CAACI,GAAG,CAACF,IAAI,CAACG,MAAM,CAAC;IAC/B;EACJ,CAAC,CAAC;EACF,OAAOP,KAAK,CAACQ,MAAM,CAAEC,CAAC,IAAKP,UAAU,CAACjB,GAAG,CAACwB,CAAC,CAAC7E,EAAE,CAAC,CAAC;AACpD,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM8E,WAAW,GAAGA,CAACX,IAAI,EAAEC,KAAK,EAAEC,KAAK,KAAK;EACxC,IAAI,CAACF,IAAI,CAACnE,EAAE,EAAE;IACV,OAAO,EAAE;EACb;EACA,MAAM+E,WAAW,GAAG,IAAIR,GAAG,CAAC,CAAC;EAC7BF,KAAK,CAACZ,OAAO,CAAEe,IAAI,IAAK;IACpB,IAAIA,IAAI,CAACG,MAAM,KAAKR,IAAI,CAACnE,EAAE,EAAE;MACzB+E,WAAW,CAACL,GAAG,CAACF,IAAI,CAACC,MAAM,CAAC;IAChC;EACJ,CAAC,CAAC;EACF,OAAOL,KAAK,CAACQ,MAAM,CAAEC,CAAC,IAAKE,WAAW,CAAC1B,GAAG,CAACwB,CAAC,CAAC7E,EAAE,CAAC,CAAC;AACrD,CAAC;AACD,MAAMgF,yBAAyB,GAAGA,CAACb,IAAI,EAAEc,UAAU,GAAG,CAAC,CAAC,EAAE,CAAC,CAAC,KAAK;EAC7D,MAAM;IAAEC,KAAK;IAAEC;EAAO,CAAC,GAAGC,iBAAiB,CAACjB,IAAI,CAAC;EACjD,MAAMkB,MAAM,GAAGlB,IAAI,CAACkB,MAAM,IAAIJ,UAAU;EACxC,MAAMK,OAAO,GAAGJ,KAAK,GAAGG,MAAM,CAAC,CAAC,CAAC;EACjC,MAAME,OAAO,GAAGJ,MAAM,GAAGE,MAAM,CAAC,CAAC,CAAC;EAClC,OAAO;IACH9D,CAAC,EAAE4C,IAAI,CAACqB,QAAQ,CAACjE,CAAC,GAAG+D,OAAO;IAC5B9D,CAAC,EAAE2C,IAAI,CAACqB,QAAQ,CAAChE,CAAC,GAAG+D;EACzB,CAAC;AACL,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAME,cAAc,GAAGA,CAACrB,KAAK,EAAEsB,MAAM,GAAG;EAAET,UAAU,EAAE,CAAC,CAAC,EAAE,CAAC;AAAE,CAAC,KAAK;EAC/D,IAAIU,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,aAAa,IAAI,CAACH,MAAM,CAACI,UAAU,EAAE;IAC9DC,OAAO,CAACC,IAAI,CAAC,sLAAsL,CAAC;EACxM;EACA,IAAI5B,KAAK,CAACR,MAAM,KAAK,CAAC,EAAE;IACpB,OAAO;MAAErC,CAAC,EAAE,CAAC;MAAEC,CAAC,EAAE,CAAC;MAAE0D,KAAK,EAAE,CAAC;MAAEC,MAAM,EAAE;IAAE,CAAC;EAC9C;EACA,MAAMc,GAAG,GAAG7B,KAAK,CAAC8B,MAAM,CAAC,CAACC,OAAO,EAAEC,QAAQ,KAAK;IAC5C,MAAMC,IAAI,GAAG,OAAOD,QAAQ,KAAK,QAAQ;IACzC,IAAIE,WAAW,GAAG,CAACZ,MAAM,CAACI,UAAU,IAAI,CAACO,IAAI,GAAGD,QAAQ,GAAGG,SAAS;IACpE,IAAIb,MAAM,CAACI,UAAU,EAAE;MACnBQ,WAAW,GAAGD,IAAI,GACZX,MAAM,CAACI,UAAU,CAACU,GAAG,CAACJ,QAAQ,CAAC,GAC/B,CAACnC,kBAAkB,CAACmC,QAAQ,CAAC,GACzBV,MAAM,CAACI,UAAU,CAACU,GAAG,CAACJ,QAAQ,CAACpG,EAAE,CAAC,GAClCoG,QAAQ;IACtB;IACA,MAAMK,OAAO,GAAGH,WAAW,GAAGI,SAAS,CAACJ,WAAW,EAAEZ,MAAM,CAACT,UAAU,CAAC,GAAG;MAAE1D,CAAC,EAAE,CAAC;MAAEC,CAAC,EAAE,CAAC;MAAEmF,EAAE,EAAE,CAAC;MAAEC,EAAE,EAAE;IAAE,CAAC;IACtG,OAAOC,gBAAgB,CAACV,OAAO,EAAEM,OAAO,CAAC;EAC7C,CAAC,EAAE;IAAElF,CAAC,EAAEuF,QAAQ;IAAEtF,CAAC,EAAEsF,QAAQ;IAAEH,EAAE,EAAE,CAACG,QAAQ;IAAEF,EAAE,EAAE,CAACE;EAAS,CAAC,CAAC;EAC9D,OAAOC,SAAS,CAACd,GAAG,CAAC;AACzB,CAAC;AACD;AACA;AACA;AACA;AACA,MAAMe,sBAAsB,GAAGA,CAAClB,UAAU,EAAEJ,MAAM,GAAG,CAAC,CAAC,KAAK;EACxD,IAAII,UAAU,CAAC5C,IAAI,KAAK,CAAC,EAAE;IACvB,OAAO;MAAE3B,CAAC,EAAE,CAAC;MAAEC,CAAC,EAAE,CAAC;MAAE0D,KAAK,EAAE,CAAC;MAAEC,MAAM,EAAE;IAAE,CAAC;EAC9C;EACA,IAAIc,GAAG,GAAG;IAAE1E,CAAC,EAAEuF,QAAQ;IAAEtF,CAAC,EAAEsF,QAAQ;IAAEH,EAAE,EAAE,CAACG,QAAQ;IAAEF,EAAE,EAAE,CAACE;EAAS,CAAC;EACpEhB,UAAU,CAACrC,OAAO,CAAEU,IAAI,IAAK;IACzB,IAAIuB,MAAM,CAACd,MAAM,KAAK2B,SAAS,IAAIb,MAAM,CAACd,MAAM,CAACT,IAAI,CAAC,EAAE;MACpD,MAAMsC,OAAO,GAAGC,SAAS,CAACvC,IAAI,CAAC;MAC/B8B,GAAG,GAAGY,gBAAgB,CAACZ,GAAG,EAAEQ,OAAO,CAAC;IACxC;EACJ,CAAC,CAAC;EACF,OAAOM,SAAS,CAACd,GAAG,CAAC;AACzB,CAAC;AACD,MAAMgB,cAAc,GAAGA,CAAC7C,KAAK,EAAE8C,IAAI,EAAE,CAACC,EAAE,EAAEC,EAAE,EAAEC,MAAM,CAAC,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EAAEC,SAAS,GAAG,KAAK;AACpF;AACAC,yBAAyB,GAAG,KAAK,KAAK;EAClC,MAAMC,QAAQ,GAAG;IACb,GAAGC,oBAAoB,CAACP,IAAI,EAAE,CAACC,EAAE,EAAEC,EAAE,EAAEC,MAAM,CAAC,CAAC;IAC/CnC,KAAK,EAAEgC,IAAI,CAAChC,KAAK,GAAGmC,MAAM;IAC1BlC,MAAM,EAAE+B,IAAI,CAAC/B,MAAM,GAAGkC;EAC1B,CAAC;EACD,MAAMK,YAAY,GAAG,EAAE;EACvB,KAAK,MAAMvD,IAAI,IAAIC,KAAK,CAACuD,MAAM,CAAC,CAAC,EAAE;IAC/B,MAAM;MAAEC,QAAQ;MAAEC,UAAU,GAAG,IAAI;MAAEC,MAAM,GAAG;IAAM,CAAC,GAAG3D,IAAI;IAC5D,IAAKoD,yBAAyB,IAAI,CAACM,UAAU,IAAKC,MAAM,EAAE;MACtD;IACJ;IACA,MAAM5C,KAAK,GAAG0C,QAAQ,CAAC1C,KAAK,IAAIf,IAAI,CAACe,KAAK,IAAIf,IAAI,CAAC4D,YAAY,IAAI,IAAI;IACvE,MAAM5C,MAAM,GAAGyC,QAAQ,CAACzC,MAAM,IAAIhB,IAAI,CAACgB,MAAM,IAAIhB,IAAI,CAAC6D,aAAa,IAAI,IAAI;IAC3E,MAAMC,eAAe,GAAGC,kBAAkB,CAACV,QAAQ,EAAEW,UAAU,CAAChE,IAAI,CAAC,CAAC;IACtE,MAAMiE,IAAI,GAAG,CAAClD,KAAK,IAAI,CAAC,KAAKC,MAAM,IAAI,CAAC,CAAC;IACzC,MAAMkD,gBAAgB,GAAGf,SAAS,IAAIW,eAAe,GAAG,CAAC;IACzD,MAAMK,kBAAkB,GAAG,CAACnE,IAAI,CAACoE,SAAS,CAACC,YAAY;IACvD,MAAMC,SAAS,GAAGH,kBAAkB,IAAID,gBAAgB,IAAIJ,eAAe,IAAIG,IAAI;IACnF,IAAIK,SAAS,IAAItE,IAAI,CAACuE,QAAQ,EAAE;MAC5BhB,YAAY,CAAC/D,IAAI,CAACQ,IAAI,CAAC;IAC3B;EACJ;EACA,OAAOuD,YAAY;AACvB,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMiB,iBAAiB,GAAGA,CAACvE,KAAK,EAAEC,KAAK,KAAK;EACxC,MAAMuE,OAAO,GAAG,IAAIrE,GAAG,CAAC,CAAC;EACzBH,KAAK,CAACX,OAAO,CAAEU,IAAI,IAAK;IACpByE,OAAO,CAAClE,GAAG,CAACP,IAAI,CAACnE,EAAE,CAAC;EACxB,CAAC,CAAC;EACF,OAAOqE,KAAK,CAACO,MAAM,CAAEJ,IAAI,IAAKoE,OAAO,CAACvF,GAAG,CAACmB,IAAI,CAACC,MAAM,CAAC,IAAImE,OAAO,CAACvF,GAAG,CAACmB,IAAI,CAACG,MAAM,CAAC,CAAC;AACvF,CAAC;AACD,SAASkE,eAAeA,CAAC/C,UAAU,EAAEgD,OAAO,EAAE;EAC1C,MAAMC,YAAY,GAAG,IAAIC,GAAG,CAAC,CAAC;EAC9B,MAAMC,aAAa,GAAGH,OAAO,EAAE1E,KAAK,GAAG,IAAIG,GAAG,CAACuE,OAAO,CAAC1E,KAAK,CAAC8E,GAAG,CAAE/E,IAAI,IAAKA,IAAI,CAACnE,EAAE,CAAC,CAAC,GAAG,IAAI;EAC3F8F,UAAU,CAACrC,OAAO,CAAEoB,CAAC,IAAK;IACtB,MAAM4D,SAAS,GAAG5D,CAAC,CAAC+C,QAAQ,CAAC1C,KAAK,IAAIL,CAAC,CAAC+C,QAAQ,CAACzC,MAAM,KAAK2D,OAAO,EAAEK,kBAAkB,IAAI,CAACtE,CAAC,CAACiD,MAAM,CAAC;IACrG,IAAIW,SAAS,KAAK,CAACQ,aAAa,IAAIA,aAAa,CAAC5F,GAAG,CAACwB,CAAC,CAAC7E,EAAE,CAAC,CAAC,EAAE;MAC1D+I,YAAY,CAACK,GAAG,CAACvE,CAAC,CAAC7E,EAAE,EAAE6E,CAAC,CAAC;IAC7B;EACJ,CAAC,CAAC;EACF,OAAOkE,YAAY;AACvB;AACA,eAAeM,WAAWA,CAAC;EAAEjF,KAAK;EAAEc,KAAK;EAAEC,MAAM;EAAEmE,OAAO;EAAEC,OAAO;EAAEC;AAAQ,CAAC,EAAEV,OAAO,EAAE;EACrF,IAAI1E,KAAK,CAAClB,IAAI,KAAK,CAAC,EAAE;IAClB,OAAOuG,OAAO,CAACC,OAAO,CAAC,IAAI,CAAC;EAChC;EACA,MAAMC,UAAU,GAAGd,eAAe,CAACzE,KAAK,EAAE0E,OAAO,CAAC;EAClD,MAAMc,MAAM,GAAG5C,sBAAsB,CAAC2C,UAAU,CAAC;EACjD,MAAME,QAAQ,GAAGC,oBAAoB,CAACF,MAAM,EAAE1E,KAAK,EAAEC,MAAM,EAAE2D,OAAO,EAAES,OAAO,IAAIA,OAAO,EAAET,OAAO,EAAEU,OAAO,IAAIA,OAAO,EAAEV,OAAO,EAAEiB,OAAO,IAAI,GAAG,CAAC;EAC/I,MAAMT,OAAO,CAACU,WAAW,CAACH,QAAQ,EAAE;IAChCI,QAAQ,EAAEnB,OAAO,EAAEmB,QAAQ;IAC3BC,IAAI,EAAEpB,OAAO,EAAEoB,IAAI;IACnB5K,WAAW,EAAEwJ,OAAO,EAAExJ;EAC1B,CAAC,CAAC;EACF,OAAOmK,OAAO,CAACC,OAAO,CAAC,IAAI,CAAC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASS,qBAAqBA,CAAC;EAAEC,MAAM;EAAEC,YAAY;EAAEvE,UAAU;EAAEb,UAAU,GAAG,CAAC,CAAC,EAAE,CAAC,CAAC;EAAEqF,UAAU;EAAEC;AAAS,CAAC,EAAE;EAC5G,MAAMpG,IAAI,GAAG2B,UAAU,CAACU,GAAG,CAAC4D,MAAM,CAAC;EACnC,MAAMI,UAAU,GAAGrG,IAAI,CAACsG,QAAQ,GAAG3E,UAAU,CAACU,GAAG,CAACrC,IAAI,CAACsG,QAAQ,CAAC,GAAGlE,SAAS;EAC5E,MAAM;IAAEhF,CAAC,EAAEmJ,OAAO;IAAElJ,CAAC,EAAEmJ;EAAQ,CAAC,GAAGH,UAAU,GAAGA,UAAU,CAACjC,SAAS,CAACqC,gBAAgB,GAAG;IAAErJ,CAAC,EAAE,CAAC;IAAEC,CAAC,EAAE;EAAE,CAAC;EACtG,MAAM6D,MAAM,GAAGlB,IAAI,CAACkB,MAAM,IAAIJ,UAAU;EACxC,IAAI4F,MAAM,GAAG1G,IAAI,CAAC0G,MAAM,IAAIP,UAAU;EACtC,IAAInG,IAAI,CAAC0G,MAAM,KAAK,QAAQ,IAAI,CAAC1G,IAAI,CAAC2G,YAAY,EAAE;IAChD,IAAI,CAACN,UAAU,EAAE;MACbD,OAAO,GAAG,KAAK,EAAEhL,aAAa,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;IACjD,CAAC,MACI;MACD,MAAMwL,WAAW,GAAGP,UAAU,CAAC5C,QAAQ,CAAC1C,KAAK;MAC7C,MAAM8F,YAAY,GAAGR,UAAU,CAAC5C,QAAQ,CAACzC,MAAM;MAC/C,IAAI4F,WAAW,IAAIC,YAAY,EAAE;QAC7BH,MAAM,GAAG,CACL,CAACH,OAAO,EAAEC,OAAO,CAAC,EAClB,CAACD,OAAO,GAAGK,WAAW,EAAEJ,OAAO,GAAGK,YAAY,CAAC,CAClD;MACL;IACJ;EACJ,CAAC,MACI,IAAIR,UAAU,IAAIS,kBAAkB,CAAC9G,IAAI,CAAC0G,MAAM,CAAC,EAAE;IACpDA,MAAM,GAAG,CACL,CAAC1G,IAAI,CAAC0G,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAGH,OAAO,EAAEvG,IAAI,CAAC0G,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAGF,OAAO,CAAC,EAC1D,CAACxG,IAAI,CAAC0G,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAGH,OAAO,EAAEvG,IAAI,CAAC0G,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAGF,OAAO,CAAC,CAC7D;EACL;EACA,MAAMC,gBAAgB,GAAGK,kBAAkB,CAACJ,MAAM,CAAC,GAC7CK,aAAa,CAACb,YAAY,EAAEQ,MAAM,EAAE1G,IAAI,CAACyD,QAAQ,CAAC,GAClDyC,YAAY;EAClB,IAAIlG,IAAI,CAACyD,QAAQ,CAAC1C,KAAK,KAAKqB,SAAS,IAAIpC,IAAI,CAACyD,QAAQ,CAACzC,MAAM,KAAKoB,SAAS,EAAE;IACzEgE,OAAO,GAAG,KAAK,EAAEhL,aAAa,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;EACjD;EACA,OAAO;IACHiG,QAAQ,EAAE;MACNjE,CAAC,EAAEqJ,gBAAgB,CAACrJ,CAAC,GAAGmJ,OAAO,GAAG,CAACvG,IAAI,CAACyD,QAAQ,CAAC1C,KAAK,IAAI,CAAC,IAAIG,MAAM,CAAC,CAAC,CAAC;MACxE7D,CAAC,EAAEoJ,gBAAgB,CAACpJ,CAAC,GAAGmJ,OAAO,GAAG,CAACxG,IAAI,CAACyD,QAAQ,CAACzC,MAAM,IAAI,CAAC,IAAIE,MAAM,CAAC,CAAC;IAC5E,CAAC;IACDuF;EACJ,CAAC;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAeO,mBAAmBA,CAAC;EAAEC,aAAa,GAAG,EAAE;EAAEC,aAAa,GAAG,EAAE;EAAEjH,KAAK;EAAEC,KAAK;EAAEiH;AAAgB,CAAC,EAAE;EAC1G,MAAM1C,OAAO,GAAG,IAAIrE,GAAG,CAAC6G,aAAa,CAAClC,GAAG,CAAE/E,IAAI,IAAKA,IAAI,CAACnE,EAAE,CAAC,CAAC;EAC7D,MAAMuL,aAAa,GAAG,EAAE;EACxB,KAAK,MAAMpH,IAAI,IAAIC,KAAK,EAAE;IACtB,IAAID,IAAI,CAACqH,SAAS,KAAK,KAAK,EAAE;MAC1B;IACJ;IACA,MAAMC,UAAU,GAAG7C,OAAO,CAACvF,GAAG,CAACc,IAAI,CAACnE,EAAE,CAAC;IACvC,MAAM0L,SAAS,GAAG,CAACD,UAAU,IAAItH,IAAI,CAACsG,QAAQ,IAAIc,aAAa,CAACI,IAAI,CAAE9G,CAAC,IAAKA,CAAC,CAAC7E,EAAE,KAAKmE,IAAI,CAACsG,QAAQ,CAAC;IACnG,IAAIgB,UAAU,IAAIC,SAAS,EAAE;MACzBH,aAAa,CAAC5H,IAAI,CAACQ,IAAI,CAAC;IAC5B;EACJ;EACA,MAAMyH,OAAO,GAAG,IAAIrH,GAAG,CAAC8G,aAAa,CAACnC,GAAG,CAAE1E,IAAI,IAAKA,IAAI,CAACxE,EAAE,CAAC,CAAC;EAC7D,MAAM6L,cAAc,GAAGxH,KAAK,CAACO,MAAM,CAAEJ,IAAI,IAAKA,IAAI,CAACgH,SAAS,KAAK,KAAK,CAAC;EACvE,MAAMM,cAAc,GAAGnD,iBAAiB,CAAC4C,aAAa,EAAEM,cAAc,CAAC;EACvE,MAAME,aAAa,GAAGD,cAAc;EACpC,KAAK,MAAMtH,IAAI,IAAIqH,cAAc,EAAE;IAC/B,MAAMJ,UAAU,GAAGG,OAAO,CAACvI,GAAG,CAACmB,IAAI,CAACxE,EAAE,CAAC;IACvC,IAAIyL,UAAU,IAAI,CAACM,aAAa,CAACJ,IAAI,CAAEK,CAAC,IAAKA,CAAC,CAAChM,EAAE,KAAKwE,IAAI,CAACxE,EAAE,CAAC,EAAE;MAC5D+L,aAAa,CAACpI,IAAI,CAACa,IAAI,CAAC;IAC5B;EACJ;EACA,IAAI,CAAC8G,cAAc,EAAE;IACjB,OAAO;MACHjH,KAAK,EAAE0H,aAAa;MACpB3H,KAAK,EAAEmH;IACX,CAAC;EACL;EACA,MAAMU,oBAAoB,GAAG,MAAMX,cAAc,CAAC;IAC9ClH,KAAK,EAAEmH,aAAa;IACpBlH,KAAK,EAAE0H;EACX,CAAC,CAAC;EACF,IAAI,OAAOE,oBAAoB,KAAK,SAAS,EAAE;IAC3C,OAAOA,oBAAoB,GAAG;MAAE5H,KAAK,EAAE0H,aAAa;MAAE3H,KAAK,EAAEmH;IAAc,CAAC,GAAG;MAAElH,KAAK,EAAE,EAAE;MAAED,KAAK,EAAE;IAAG,CAAC;EAC3G;EACA,OAAO6H,oBAAoB;AAC/B;AAEA,MAAMC,KAAK,GAAGA,CAACC,GAAG,EAAEC,GAAG,GAAG,CAAC,EAAEC,GAAG,GAAG,CAAC,KAAKC,IAAI,CAACF,GAAG,CAACE,IAAI,CAACD,GAAG,CAACF,GAAG,EAAEC,GAAG,CAAC,EAAEC,GAAG,CAAC;AAC1E,MAAMnB,aAAa,GAAGA,CAAC1F,QAAQ,GAAG;EAAEjE,CAAC,EAAE,CAAC;EAAEC,CAAC,EAAE;AAAE,CAAC,EAAEqJ,MAAM,EAAE0B,UAAU,MAAM;EACtEhL,CAAC,EAAE2K,KAAK,CAAC1G,QAAQ,CAACjE,CAAC,EAAEsJ,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAEA,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI0B,UAAU,EAAErH,KAAK,IAAI,CAAC,CAAC,CAAC;EAC3E1D,CAAC,EAAE0K,KAAK,CAAC1G,QAAQ,CAAChE,CAAC,EAAEqJ,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAEA,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI0B,UAAU,EAAEpH,MAAM,IAAI,CAAC,CAAC;AAC/E,CAAC,CAAC;AACF,SAASqH,qBAAqBA,CAACC,aAAa,EAAEC,eAAe,EAAEC,MAAM,EAAE;EACnE,MAAM;IAAEzH,KAAK,EAAE6F,WAAW;IAAE5F,MAAM,EAAE6F;EAAa,CAAC,GAAG5F,iBAAiB,CAACuH,MAAM,CAAC;EAC9E,MAAM;IAAEpL,CAAC,EAAEmJ,OAAO;IAAElJ,CAAC,EAAEmJ;EAAQ,CAAC,GAAGgC,MAAM,CAACpE,SAAS,CAACqC,gBAAgB;EACpE,OAAOM,aAAa,CAACuB,aAAa,EAAE,CAChC,CAAC/B,OAAO,EAAEC,OAAO,CAAC,EAClB,CAACD,OAAO,GAAGK,WAAW,EAAEJ,OAAO,GAAGK,YAAY,CAAC,CAClD,EAAE0B,eAAe,CAAC;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAME,mBAAmB,GAAGA,CAACC,KAAK,EAAET,GAAG,EAAEC,GAAG,KAAK;EAC7C,IAAIQ,KAAK,GAAGT,GAAG,EAAE;IACb,OAAOF,KAAK,CAACI,IAAI,CAACQ,GAAG,CAACD,KAAK,GAAGT,GAAG,CAAC,EAAE,CAAC,EAAEA,GAAG,CAAC,GAAGA,GAAG;EACrD,CAAC,MACI,IAAIS,KAAK,GAAGR,GAAG,EAAE;IAClB,OAAO,CAACH,KAAK,CAACI,IAAI,CAACQ,GAAG,CAACD,KAAK,GAAGR,GAAG,CAAC,EAAE,CAAC,EAAED,GAAG,CAAC,GAAGA,GAAG;EACtD;EACA,OAAO,CAAC;AACZ,CAAC;AACD,MAAMW,WAAW,GAAGA,CAACC,GAAG,EAAEpD,MAAM,EAAEqD,KAAK,GAAG,EAAE,EAAEC,QAAQ,GAAG,EAAE,KAAK;EAC5D,MAAMC,SAAS,GAAGP,mBAAmB,CAACI,GAAG,CAACzL,CAAC,EAAE2L,QAAQ,EAAEtD,MAAM,CAAC1E,KAAK,GAAGgI,QAAQ,CAAC,GAAGD,KAAK;EACvF,MAAMG,SAAS,GAAGR,mBAAmB,CAACI,GAAG,CAACxL,CAAC,EAAE0L,QAAQ,EAAEtD,MAAM,CAACzE,MAAM,GAAG+H,QAAQ,CAAC,GAAGD,KAAK;EACxF,OAAO,CAACE,SAAS,EAAEC,SAAS,CAAC;AACjC,CAAC;AACD,MAAMvG,gBAAgB,GAAGA,CAACwG,IAAI,EAAEC,IAAI,MAAM;EACtC/L,CAAC,EAAE+K,IAAI,CAACF,GAAG,CAACiB,IAAI,CAAC9L,CAAC,EAAE+L,IAAI,CAAC/L,CAAC,CAAC;EAC3BC,CAAC,EAAE8K,IAAI,CAACF,GAAG,CAACiB,IAAI,CAAC7L,CAAC,EAAE8L,IAAI,CAAC9L,CAAC,CAAC;EAC3BmF,EAAE,EAAE2F,IAAI,CAACD,GAAG,CAACgB,IAAI,CAAC1G,EAAE,EAAE2G,IAAI,CAAC3G,EAAE,CAAC;EAC9BC,EAAE,EAAE0F,IAAI,CAACD,GAAG,CAACgB,IAAI,CAACzG,EAAE,EAAE0G,IAAI,CAAC1G,EAAE;AACjC,CAAC,CAAC;AACF,MAAM2G,SAAS,GAAGA,CAAC;EAAEhM,CAAC;EAAEC,CAAC;EAAE0D,KAAK;EAAEC;AAAO,CAAC,MAAM;EAC5C5D,CAAC;EACDC,CAAC;EACDmF,EAAE,EAAEpF,CAAC,GAAG2D,KAAK;EACb0B,EAAE,EAAEpF,CAAC,GAAG2D;AACZ,CAAC,CAAC;AACF,MAAM4B,SAAS,GAAGA,CAAC;EAAExF,CAAC;EAAEC,CAAC;EAAEmF,EAAE;EAAEC;AAAG,CAAC,MAAM;EACrCrF,CAAC;EACDC,CAAC;EACD0D,KAAK,EAAEyB,EAAE,GAAGpF,CAAC;EACb4D,MAAM,EAAEyB,EAAE,GAAGpF;AACjB,CAAC,CAAC;AACF,MAAM2G,UAAU,GAAGA,CAAChE,IAAI,EAAEc,UAAU,GAAG,CAAC,CAAC,EAAE,CAAC,CAAC,KAAK;EAC9C,MAAM;IAAE1D,CAAC;IAAEC;EAAE,CAAC,GAAGyC,kBAAkB,CAACE,IAAI,CAAC,GACnCA,IAAI,CAACoE,SAAS,CAACqC,gBAAgB,GAC/B5F,yBAAyB,CAACb,IAAI,EAAEc,UAAU,CAAC;EACjD,OAAO;IACH1D,CAAC;IACDC,CAAC;IACD0D,KAAK,EAAEf,IAAI,CAACyD,QAAQ,EAAE1C,KAAK,IAAIf,IAAI,CAACe,KAAK,IAAIf,IAAI,CAAC4D,YAAY,IAAI,CAAC;IACnE5C,MAAM,EAAEhB,IAAI,CAACyD,QAAQ,EAAEzC,MAAM,IAAIhB,IAAI,CAACgB,MAAM,IAAIhB,IAAI,CAAC6D,aAAa,IAAI;EAC1E,CAAC;AACL,CAAC;AACD,MAAMtB,SAAS,GAAGA,CAACvC,IAAI,EAAEc,UAAU,GAAG,CAAC,CAAC,EAAE,CAAC,CAAC,KAAK;EAC7C,MAAM;IAAE1D,CAAC;IAAEC;EAAE,CAAC,GAAGyC,kBAAkB,CAACE,IAAI,CAAC,GACnCA,IAAI,CAACoE,SAAS,CAACqC,gBAAgB,GAC/B5F,yBAAyB,CAACb,IAAI,EAAEc,UAAU,CAAC;EACjD,OAAO;IACH1D,CAAC;IACDC,CAAC;IACDmF,EAAE,EAAEpF,CAAC,IAAI4C,IAAI,CAACyD,QAAQ,EAAE1C,KAAK,IAAIf,IAAI,CAACe,KAAK,IAAIf,IAAI,CAAC4D,YAAY,IAAI,CAAC,CAAC;IACtEnB,EAAE,EAAEpF,CAAC,IAAI2C,IAAI,CAACyD,QAAQ,EAAEzC,MAAM,IAAIhB,IAAI,CAACgB,MAAM,IAAIhB,IAAI,CAAC6D,aAAa,IAAI,CAAC;EAC5E,CAAC;AACL,CAAC;AACD,MAAMwF,gBAAgB,GAAGA,CAACC,KAAK,EAAEC,KAAK,KAAK3G,SAAS,CAACF,gBAAgB,CAAC0G,SAAS,CAACE,KAAK,CAAC,EAAEF,SAAS,CAACG,KAAK,CAAC,CAAC,CAAC;AAC1G,MAAMxF,kBAAkB,GAAGA,CAACyF,KAAK,EAAEC,KAAK,KAAK;EACzC,MAAMC,QAAQ,GAAGvB,IAAI,CAACD,GAAG,CAAC,CAAC,EAAEC,IAAI,CAACF,GAAG,CAACuB,KAAK,CAACpM,CAAC,GAAGoM,KAAK,CAACzI,KAAK,EAAE0I,KAAK,CAACrM,CAAC,GAAGqM,KAAK,CAAC1I,KAAK,CAAC,GAAGoH,IAAI,CAACD,GAAG,CAACsB,KAAK,CAACpM,CAAC,EAAEqM,KAAK,CAACrM,CAAC,CAAC,CAAC;EACjH,MAAMuM,QAAQ,GAAGxB,IAAI,CAACD,GAAG,CAAC,CAAC,EAAEC,IAAI,CAACF,GAAG,CAACuB,KAAK,CAACnM,CAAC,GAAGmM,KAAK,CAACxI,MAAM,EAAEyI,KAAK,CAACpM,CAAC,GAAGoM,KAAK,CAACzI,MAAM,CAAC,GAAGmH,IAAI,CAACD,GAAG,CAACsB,KAAK,CAACnM,CAAC,EAAEoM,KAAK,CAACpM,CAAC,CAAC,CAAC;EACnH,OAAO8K,IAAI,CAACyB,IAAI,CAACF,QAAQ,GAAGC,QAAQ,CAAC;AACzC,CAAC;AACD;AACA,MAAME,YAAY,GAAIC,GAAG,IAAKC,SAAS,CAACD,GAAG,CAAC/I,KAAK,CAAC,IAAIgJ,SAAS,CAACD,GAAG,CAAC9I,MAAM,CAAC,IAAI+I,SAAS,CAACD,GAAG,CAAC1M,CAAC,CAAC,IAAI2M,SAAS,CAACD,GAAG,CAACzM,CAAC,CAAC;AACnH;AACA,MAAM0M,SAAS,GAAIrJ,CAAC,IAAK,CAACsJ,KAAK,CAACtJ,CAAC,CAAC,IAAIuJ,QAAQ,CAACvJ,CAAC,CAAC;AACjD;AACA,MAAMwJ,OAAO,GAAGA,CAACrO,EAAE,EAAEsO,OAAO,KAAK;EAC7B,IAAI3I,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,aAAa,EAAE;IACxCE,OAAO,CAACC,IAAI,CAAC,iBAAiBsI,OAAO,sCAAsCtO,EAAE,EAAE,CAAC;EACpF;AACJ,CAAC;AACD,MAAMuO,YAAY,GAAGA,CAAC/I,QAAQ,EAAEgJ,QAAQ,GAAG,CAAC,CAAC,EAAE,CAAC,CAAC,KAAK;EAClD,OAAO;IACHjN,CAAC,EAAEiN,QAAQ,CAAC,CAAC,CAAC,GAAGlC,IAAI,CAACmC,KAAK,CAACjJ,QAAQ,CAACjE,CAAC,GAAGiN,QAAQ,CAAC,CAAC,CAAC,CAAC;IACrDhN,CAAC,EAAEgN,QAAQ,CAAC,CAAC,CAAC,GAAGlC,IAAI,CAACmC,KAAK,CAACjJ,QAAQ,CAAChE,CAAC,GAAGgN,QAAQ,CAAC,CAAC,CAAC;EACxD,CAAC;AACL,CAAC;AACD,MAAM/G,oBAAoB,GAAGA,CAAC;EAAElG,CAAC;EAAEC;AAAE,CAAC,EAAE,CAAC2F,EAAE,EAAEC,EAAE,EAAEC,MAAM,CAAC,EAAEqH,UAAU,GAAG,KAAK,EAAEF,QAAQ,GAAG,CAAC,CAAC,EAAE,CAAC,CAAC,KAAK;EAChG,MAAMhJ,QAAQ,GAAG;IACbjE,CAAC,EAAE,CAACA,CAAC,GAAG4F,EAAE,IAAIE,MAAM;IACpB7F,CAAC,EAAE,CAACA,CAAC,GAAG4F,EAAE,IAAIC;EAClB,CAAC;EACD,OAAOqH,UAAU,GAAGH,YAAY,CAAC/I,QAAQ,EAAEgJ,QAAQ,CAAC,GAAGhJ,QAAQ;AACnE,CAAC;AACD,MAAMmJ,oBAAoB,GAAGA,CAAC;EAAEpN,CAAC;EAAEC;AAAE,CAAC,EAAE,CAAC2F,EAAE,EAAEC,EAAE,EAAEC,MAAM,CAAC,KAAK;EACzD,OAAO;IACH9F,CAAC,EAAEA,CAAC,GAAG8F,MAAM,GAAGF,EAAE;IAClB3F,CAAC,EAAEA,CAAC,GAAG6F,MAAM,GAAGD;EACpB,CAAC;AACL,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASwH,YAAYA,CAAC7E,OAAO,EAAEF,QAAQ,EAAE;EACrC,IAAI,OAAOE,OAAO,KAAK,QAAQ,EAAE;IAC7B,OAAOuC,IAAI,CAACuC,KAAK,CAAC,CAAChF,QAAQ,GAAGA,QAAQ,IAAI,CAAC,GAAGE,OAAO,CAAC,IAAI,GAAG,CAAC;EAClE;EACA,IAAI,OAAOA,OAAO,KAAK,QAAQ,IAAIA,OAAO,CAAC+E,QAAQ,CAAC,IAAI,CAAC,EAAE;IACvD,MAAMC,YAAY,GAAGC,UAAU,CAACjF,OAAO,CAAC;IACxC,IAAI,CAAC/I,MAAM,CAACmN,KAAK,CAACY,YAAY,CAAC,EAAE;MAC7B,OAAOzC,IAAI,CAACuC,KAAK,CAACE,YAAY,CAAC;IACnC;EACJ;EACA,IAAI,OAAOhF,OAAO,KAAK,QAAQ,IAAIA,OAAO,CAAC+E,QAAQ,CAAC,GAAG,CAAC,EAAE;IACtD,MAAMC,YAAY,GAAGC,UAAU,CAACjF,OAAO,CAAC;IACxC,IAAI,CAAC/I,MAAM,CAACmN,KAAK,CAACY,YAAY,CAAC,EAAE;MAC7B,OAAOzC,IAAI,CAACuC,KAAK,CAAChF,QAAQ,GAAGkF,YAAY,GAAG,IAAI,CAAC;IACrD;EACJ;EACAhJ,OAAO,CAACkJ,KAAK,CAAC,mCAAmClF,OAAO,gFAAgF,CAAC;EACzI,OAAO,CAAC;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASmF,aAAaA,CAACnF,OAAO,EAAE7E,KAAK,EAAEC,MAAM,EAAE;EAC3C,IAAI,OAAO4E,OAAO,KAAK,QAAQ,IAAI,OAAOA,OAAO,KAAK,QAAQ,EAAE;IAC5D,MAAMoF,QAAQ,GAAGP,YAAY,CAAC7E,OAAO,EAAE5E,MAAM,CAAC;IAC9C,MAAMiK,QAAQ,GAAGR,YAAY,CAAC7E,OAAO,EAAE7E,KAAK,CAAC;IAC7C,OAAO;MACHmK,GAAG,EAAEF,QAAQ;MACbG,KAAK,EAAEF,QAAQ;MACfG,MAAM,EAAEJ,QAAQ;MAChBK,IAAI,EAAEJ,QAAQ;MACd7N,CAAC,EAAE6N,QAAQ,GAAG,CAAC;MACf5N,CAAC,EAAE2N,QAAQ,GAAG;IAClB,CAAC;EACL;EACA,IAAI,OAAOpF,OAAO,KAAK,QAAQ,EAAE;IAC7B,MAAMsF,GAAG,GAAGT,YAAY,CAAC7E,OAAO,CAACsF,GAAG,IAAItF,OAAO,CAACvI,CAAC,IAAI,CAAC,EAAE2D,MAAM,CAAC;IAC/D,MAAMoK,MAAM,GAAGX,YAAY,CAAC7E,OAAO,CAACwF,MAAM,IAAIxF,OAAO,CAACvI,CAAC,IAAI,CAAC,EAAE2D,MAAM,CAAC;IACrE,MAAMqK,IAAI,GAAGZ,YAAY,CAAC7E,OAAO,CAACyF,IAAI,IAAIzF,OAAO,CAACxI,CAAC,IAAI,CAAC,EAAE2D,KAAK,CAAC;IAChE,MAAMoK,KAAK,GAAGV,YAAY,CAAC7E,OAAO,CAACuF,KAAK,IAAIvF,OAAO,CAACxI,CAAC,IAAI,CAAC,EAAE2D,KAAK,CAAC;IAClE,OAAO;MAAEmK,GAAG;MAAEC,KAAK;MAAEC,MAAM;MAAEC,IAAI;MAAEjO,CAAC,EAAEiO,IAAI,GAAGF,KAAK;MAAE9N,CAAC,EAAE6N,GAAG,GAAGE;IAAO,CAAC;EACzE;EACA,OAAO;IAAEF,GAAG,EAAE,CAAC;IAAEC,KAAK,EAAE,CAAC;IAAEC,MAAM,EAAE,CAAC;IAAEC,IAAI,EAAE,CAAC;IAAEjO,CAAC,EAAE,CAAC;IAAEC,CAAC,EAAE;EAAE,CAAC;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASiO,wBAAwBA,CAAC7F,MAAM,EAAErI,CAAC,EAAEC,CAAC,EAAEtC,IAAI,EAAEgG,KAAK,EAAEC,MAAM,EAAE;EACjE,MAAM;IAAE5D,CAAC,EAAEiO,IAAI;IAAEhO,CAAC,EAAE6N;EAAI,CAAC,GAAGV,oBAAoB,CAAC/E,MAAM,EAAE,CAACrI,CAAC,EAAEC,CAAC,EAAEtC,IAAI,CAAC,CAAC;EACtE,MAAM;IAAEqC,CAAC,EAAEmO,UAAU;IAAElO,CAAC,EAAEmO;EAAY,CAAC,GAAGhB,oBAAoB,CAAC;IAAEpN,CAAC,EAAEqI,MAAM,CAACrI,CAAC,GAAGqI,MAAM,CAAC1E,KAAK;IAAE1D,CAAC,EAAEoI,MAAM,CAACpI,CAAC,GAAGoI,MAAM,CAACzE;EAAO,CAAC,EAAE,CAAC5D,CAAC,EAAEC,CAAC,EAAEtC,IAAI,CAAC,CAAC;EACzI,MAAMoQ,KAAK,GAAGpK,KAAK,GAAGwK,UAAU;EAChC,MAAMH,MAAM,GAAGpK,MAAM,GAAGwK,WAAW;EACnC,OAAO;IACHH,IAAI,EAAElD,IAAI,CAACuC,KAAK,CAACW,IAAI,CAAC;IACtBH,GAAG,EAAE/C,IAAI,CAACuC,KAAK,CAACQ,GAAG,CAAC;IACpBC,KAAK,EAAEhD,IAAI,CAACuC,KAAK,CAACS,KAAK,CAAC;IACxBC,MAAM,EAAEjD,IAAI,CAACuC,KAAK,CAACU,MAAM;EAC7B,CAAC;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMzF,oBAAoB,GAAGA,CAACF,MAAM,EAAE1E,KAAK,EAAEC,MAAM,EAAEoE,OAAO,EAAEC,OAAO,EAAEO,OAAO,KAAK;EAC/E;EACA,MAAM6F,CAAC,GAAGV,aAAa,CAACnF,OAAO,EAAE7E,KAAK,EAAEC,MAAM,CAAC;EAC/C,MAAM0K,KAAK,GAAG,CAAC3K,KAAK,GAAG0K,CAAC,CAACrO,CAAC,IAAIqI,MAAM,CAAC1E,KAAK;EAC1C,MAAM4K,KAAK,GAAG,CAAC3K,MAAM,GAAGyK,CAAC,CAACpO,CAAC,IAAIoI,MAAM,CAACzE,MAAM;EAC5C;EACA,MAAMjG,IAAI,GAAGoN,IAAI,CAACF,GAAG,CAACyD,KAAK,EAAEC,KAAK,CAAC;EACnC,MAAMC,WAAW,GAAG7D,KAAK,CAAChN,IAAI,EAAEqK,OAAO,EAAEC,OAAO,CAAC;EACjD,MAAMwG,aAAa,GAAGpG,MAAM,CAACrI,CAAC,GAAGqI,MAAM,CAAC1E,KAAK,GAAG,CAAC;EACjD,MAAM+K,aAAa,GAAGrG,MAAM,CAACpI,CAAC,GAAGoI,MAAM,CAACzE,MAAM,GAAG,CAAC;EAClD,MAAM5D,CAAC,GAAG2D,KAAK,GAAG,CAAC,GAAG8K,aAAa,GAAGD,WAAW;EACjD,MAAMvO,CAAC,GAAG2D,MAAM,GAAG,CAAC,GAAG8K,aAAa,GAAGF,WAAW;EAClD;EACA,MAAMG,UAAU,GAAGT,wBAAwB,CAAC7F,MAAM,EAAErI,CAAC,EAAEC,CAAC,EAAEuO,WAAW,EAAE7K,KAAK,EAAEC,MAAM,CAAC;EACrF;EACA,MAAMgL,MAAM,GAAG;IACXX,IAAI,EAAElD,IAAI,CAACF,GAAG,CAAC8D,UAAU,CAACV,IAAI,GAAGI,CAAC,CAACJ,IAAI,EAAE,CAAC,CAAC;IAC3CH,GAAG,EAAE/C,IAAI,CAACF,GAAG,CAAC8D,UAAU,CAACb,GAAG,GAAGO,CAAC,CAACP,GAAG,EAAE,CAAC,CAAC;IACxCC,KAAK,EAAEhD,IAAI,CAACF,GAAG,CAAC8D,UAAU,CAACZ,KAAK,GAAGM,CAAC,CAACN,KAAK,EAAE,CAAC,CAAC;IAC9CC,MAAM,EAAEjD,IAAI,CAACF,GAAG,CAAC8D,UAAU,CAACX,MAAM,GAAGK,CAAC,CAACL,MAAM,EAAE,CAAC;EACpD,CAAC;EACD,OAAO;IACHhO,CAAC,EAAEA,CAAC,GAAG4O,MAAM,CAACX,IAAI,GAAGW,MAAM,CAACb,KAAK;IACjC9N,CAAC,EAAEA,CAAC,GAAG2O,MAAM,CAACd,GAAG,GAAGc,MAAM,CAACZ,MAAM;IACjCrQ,IAAI,EAAE6Q;EACV,CAAC;AACL,CAAC;AACD,MAAMK,OAAO,GAAGA,CAAA,KAAM,OAAOC,SAAS,KAAK,WAAW,IAAIA,SAAS,EAAEC,SAAS,EAAEC,OAAO,CAAC,KAAK,CAAC,IAAI,CAAC;AACnG,SAAStF,kBAAkBA,CAACJ,MAAM,EAAE;EAChC,OAAOA,MAAM,KAAKtE,SAAS,IAAIsE,MAAM,KAAK,IAAI,IAAIA,MAAM,KAAK,QAAQ;AACzE;AACA,SAASzF,iBAAiBA,CAACjB,IAAI,EAAE;EAC7B,OAAO;IACHe,KAAK,EAAEf,IAAI,CAACyD,QAAQ,EAAE1C,KAAK,IAAIf,IAAI,CAACe,KAAK,IAAIf,IAAI,CAAC4D,YAAY,IAAI,CAAC;IACnE5C,MAAM,EAAEhB,IAAI,CAACyD,QAAQ,EAAEzC,MAAM,IAAIhB,IAAI,CAACgB,MAAM,IAAIhB,IAAI,CAAC6D,aAAa,IAAI;EAC1E,CAAC;AACL;AACA,SAASwI,iBAAiBA,CAACrM,IAAI,EAAE;EAC7B,OAAQ,CAACA,IAAI,CAACyD,QAAQ,EAAE1C,KAAK,IAAIf,IAAI,CAACe,KAAK,IAAIf,IAAI,CAAC4D,YAAY,MAAMxB,SAAS,IAC3E,CAACpC,IAAI,CAACyD,QAAQ,EAAEzC,MAAM,IAAIhB,IAAI,CAACgB,MAAM,IAAIhB,IAAI,CAAC6D,aAAa,MAAMzB,SAAS;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASkK,wBAAwBA,CAACjL,QAAQ,EAAE+G,UAAU,GAAG;EAAErH,KAAK,EAAE,CAAC;EAAEC,MAAM,EAAE;AAAE,CAAC,EAAEsF,QAAQ,EAAE3E,UAAU,EAAEb,UAAU,EAAE;EAChH,MAAM2F,gBAAgB,GAAG;IAAE,GAAGpF;EAAS,CAAC;EACxC,MAAMmH,MAAM,GAAG7G,UAAU,CAACU,GAAG,CAACiE,QAAQ,CAAC;EACvC,IAAIkC,MAAM,EAAE;IACR,MAAMtH,MAAM,GAAGsH,MAAM,CAACtH,MAAM,IAAIJ,UAAU;IAC1C2F,gBAAgB,CAACrJ,CAAC,IAAIoL,MAAM,CAACpE,SAAS,CAACqC,gBAAgB,CAACrJ,CAAC,GAAG,CAACgL,UAAU,CAACrH,KAAK,IAAI,CAAC,IAAIG,MAAM,CAAC,CAAC,CAAC;IAC/FuF,gBAAgB,CAACpJ,CAAC,IAAImL,MAAM,CAACpE,SAAS,CAACqC,gBAAgB,CAACpJ,CAAC,GAAG,CAAC+K,UAAU,CAACpH,MAAM,IAAI,CAAC,IAAIE,MAAM,CAAC,CAAC,CAAC;EACpG;EACA,OAAOuF,gBAAgB;AAC3B;AACA,SAAS8F,YAAYA,CAAC1N,CAAC,EAAEC,CAAC,EAAE;EACxB,IAAID,CAAC,CAACE,IAAI,KAAKD,CAAC,CAACC,IAAI,EAAE;IACnB,OAAO,KAAK;EAChB;EACA,KAAK,MAAMyN,IAAI,IAAI3N,CAAC,EAAE;IAClB,IAAI,CAACC,CAAC,CAACI,GAAG,CAACsN,IAAI,CAAC,EAAE;MACd,OAAO,KAAK;IAChB;EACJ;EACA,OAAO,IAAI;AACf;AACA;AACA;AACA;AACA;AACA,SAASC,aAAaA,CAAA,EAAG;EACrB,IAAIlH,OAAO;EACX,IAAImH,MAAM;EACV,MAAMC,OAAO,GAAG,IAAIrH,OAAO,CAAC,CAACsH,GAAG,EAAEC,GAAG,KAAK;IACtCtH,OAAO,GAAGqH,GAAG;IACbF,MAAM,GAAGG,GAAG;EAChB,CAAC,CAAC;EACF,OAAO;IAAEF,OAAO;IAAEpH,OAAO;IAAEmH;EAAO,CAAC;AACvC;AACA,SAASI,oBAAoBA,CAACC,OAAO,EAAE;EACnC,OAAO;IAAE,GAAG9P,sBAAsB;IAAE,IAAI8P,OAAO,IAAI,CAAC,CAAC;EAAE,CAAC;AAC5D;AAEA,SAASC,kBAAkBA,CAACC,KAAK,EAAE;EAAE5C,QAAQ,GAAG,CAAC,CAAC,EAAE,CAAC,CAAC;EAAEE,UAAU,GAAG,KAAK;EAAE2C,SAAS;EAAEC;AAAgB,CAAC,EAAE;EACtG,MAAM;IAAE/P,CAAC;IAAEC;EAAE,CAAC,GAAG+P,gBAAgB,CAACH,KAAK,CAAC;EACxC,MAAMI,UAAU,GAAG/J,oBAAoB,CAAC;IAAElG,CAAC,EAAEA,CAAC,IAAI+P,eAAe,EAAE9B,IAAI,IAAI,CAAC,CAAC;IAAEhO,CAAC,EAAEA,CAAC,IAAI8P,eAAe,EAAEjC,GAAG,IAAI,CAAC;EAAE,CAAC,EAAEgC,SAAS,CAAC;EAC/H,MAAM;IAAE9P,CAAC,EAAEkQ,QAAQ;IAAEjQ,CAAC,EAAEkQ;EAAS,CAAC,GAAGhD,UAAU,GAAGH,YAAY,CAACiD,UAAU,EAAEhD,QAAQ,CAAC,GAAGgD,UAAU;EACjG;EACA,OAAO;IACHC,QAAQ;IACRC,QAAQ;IACR,GAAGF;EACP,CAAC;AACL;AACA,MAAMG,aAAa,GAAIxN,IAAI,KAAM;EAC7Be,KAAK,EAAEf,IAAI,CAACyN,WAAW;EACvBzM,MAAM,EAAEhB,IAAI,CAAC0N;AACjB,CAAC,CAAC;AACF,MAAMC,iBAAiB,GAAI/N,OAAO,IAAKA,OAAO,EAAEgO,WAAW,GAAG,CAAC,IAAIC,MAAM,EAAEC,QAAQ;AACnF,MAAMC,SAAS,GAAG,CAAC,OAAO,EAAE,QAAQ,EAAE,UAAU,CAAC;AACjD,SAASC,cAAcA,CAACf,KAAK,EAAE;EAC3B;EACA,MAAMzM,MAAM,GAAIyM,KAAK,CAACgB,YAAY,GAAG,CAAC,GAAG,CAAC,CAAC,IAAIhB,KAAK,CAACzM,MAAO;EAC5D,IAAIA,MAAM,EAAEhF,QAAQ,KAAK,CAAC,CAAC,yBACvB,OAAO,KAAK;EAChB,MAAM0S,OAAO,GAAGH,SAAS,CAACI,QAAQ,CAAC3N,MAAM,CAAC4N,QAAQ,CAAC,IAAI5N,MAAM,CAAC6N,YAAY,CAAC,iBAAiB,CAAC;EAC7F;EACA,OAAOH,OAAO,IAAI,CAAC,CAAC1N,MAAM,CAAC8N,OAAO,CAAC,QAAQ,CAAC;AAChD;AACA,MAAMC,YAAY,GAAItB,KAAK,IAAK,SAAS,IAAIA,KAAK;AAClD,MAAMG,gBAAgB,GAAGA,CAACH,KAAK,EAAExH,MAAM,KAAK;EACxC,MAAM+I,OAAO,GAAGD,YAAY,CAACtB,KAAK,CAAC;EACnC,MAAMwB,IAAI,GAAGD,OAAO,GAAGvB,KAAK,CAACyB,OAAO,GAAGzB,KAAK,CAAC0B,OAAO,GAAG,CAAC,CAAC,CAACD,OAAO;EACjE,MAAME,IAAI,GAAGJ,OAAO,GAAGvB,KAAK,CAAC4B,OAAO,GAAG5B,KAAK,CAAC0B,OAAO,GAAG,CAAC,CAAC,CAACE,OAAO;EACjE,OAAO;IACHzR,CAAC,EAAEqR,IAAI,IAAIhJ,MAAM,EAAE4F,IAAI,IAAI,CAAC,CAAC;IAC7BhO,CAAC,EAAEuR,IAAI,IAAInJ,MAAM,EAAEyF,GAAG,IAAI,CAAC;EAC/B,CAAC;AACL,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,MAAM4D,eAAe,GAAGA,CAAC/S,IAAI,EAAEgT,WAAW,EAAEC,UAAU,EAAEjU,IAAI,EAAEkL,MAAM,KAAK;EACrE,MAAMgJ,OAAO,GAAGF,WAAW,CAACG,gBAAgB,CAAC,IAAInT,IAAI,EAAE,CAAC;EACxD,IAAI,CAACkT,OAAO,IAAI,CAACA,OAAO,CAACxP,MAAM,EAAE;IAC7B,OAAO,IAAI;EACf;EACA,OAAO0P,KAAK,CAACvR,IAAI,CAACqR,OAAO,CAAC,CAAClK,GAAG,CAAEqK,MAAM,IAAK;IACvC,MAAM/K,YAAY,GAAG+K,MAAM,CAACC,qBAAqB,CAAC,CAAC;IACnD,OAAO;MACHxT,EAAE,EAAEuT,MAAM,CAACE,YAAY,CAAC,eAAe,CAAC;MACxCvT,IAAI;MACJkK,MAAM;MACN5E,QAAQ,EAAE+N,MAAM,CAACE,YAAY,CAAC,gBAAgB,CAAC;MAC/ClS,CAAC,EAAE,CAACiH,YAAY,CAACgH,IAAI,GAAG2D,UAAU,CAAC3D,IAAI,IAAItQ,IAAI;MAC/CsC,CAAC,EAAE,CAACgH,YAAY,CAAC6G,GAAG,GAAG8D,UAAU,CAAC9D,GAAG,IAAInQ,IAAI;MAC7C,GAAGyS,aAAa,CAAC4B,MAAM;IAC3B,CAAC;EACL,CAAC,CAAC;AACN,CAAC;AAED,SAASG,mBAAmBA,CAAC;EAAEC,OAAO;EAAEC,OAAO;EAAEC,OAAO;EAAEC,OAAO;EAAEC,cAAc;EAAEC,cAAc;EAAEC,cAAc;EAAEC;AAAgB,CAAC,EAAE;EAClI;AACJ;AACA;AACA;EACI,MAAMC,OAAO,GAAGR,OAAO,GAAG,KAAK,GAAGI,cAAc,GAAG,KAAK,GAAGE,cAAc,GAAG,KAAK,GAAGJ,OAAO,GAAG,KAAK;EACnG,MAAMO,OAAO,GAAGR,OAAO,GAAG,KAAK,GAAGI,cAAc,GAAG,KAAK,GAAGE,cAAc,GAAG,KAAK,GAAGJ,OAAO,GAAG,KAAK;EACnG,MAAMxO,OAAO,GAAGgH,IAAI,CAACQ,GAAG,CAACqH,OAAO,GAAGR,OAAO,CAAC;EAC3C,MAAMpO,OAAO,GAAG+G,IAAI,CAACQ,GAAG,CAACsH,OAAO,GAAGR,OAAO,CAAC;EAC3C,OAAO,CAACO,OAAO,EAAEC,OAAO,EAAE9O,OAAO,EAAEC,OAAO,CAAC;AAC/C;AACA,SAAS8O,sBAAsBA,CAACnH,QAAQ,EAAEoH,SAAS,EAAE;EACjD,IAAIpH,QAAQ,IAAI,CAAC,EAAE;IACf,OAAO,GAAG,GAAGA,QAAQ;EACzB;EACA,OAAOoH,SAAS,GAAG,EAAE,GAAGhI,IAAI,CAACiI,IAAI,CAAC,CAACrH,QAAQ,CAAC;AAChD;AACA,SAASsH,uBAAuBA,CAAC;EAAExH,GAAG;EAAEyH,EAAE;EAAEC,EAAE;EAAE/N,EAAE;EAAEC,EAAE;EAAE+N;AAAE,CAAC,EAAE;EACzD,QAAQ3H,GAAG;IACP,KAAKvK,QAAQ,CAACE,IAAI;MACd,OAAO,CAAC8R,EAAE,GAAGJ,sBAAsB,CAACI,EAAE,GAAG9N,EAAE,EAAEgO,CAAC,CAAC,EAAED,EAAE,CAAC;IACxD,KAAKjS,QAAQ,CAACG,KAAK;MACf,OAAO,CAAC6R,EAAE,GAAGJ,sBAAsB,CAAC1N,EAAE,GAAG8N,EAAE,EAAEE,CAAC,CAAC,EAAED,EAAE,CAAC;IACxD,KAAKjS,QAAQ,CAACI,GAAG;MACb,OAAO,CAAC4R,EAAE,EAAEC,EAAE,GAAGL,sBAAsB,CAACK,EAAE,GAAG9N,EAAE,EAAE+N,CAAC,CAAC,CAAC;IACxD,KAAKlS,QAAQ,CAACK,MAAM;MAChB,OAAO,CAAC2R,EAAE,EAAEC,EAAE,GAAGL,sBAAsB,CAACzN,EAAE,GAAG8N,EAAE,EAAEC,CAAC,CAAC,CAAC;EAC5D;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,aAAaA,CAAC;EAAEjB,OAAO;EAAEC,OAAO;EAAEiB,cAAc,GAAGpS,QAAQ,CAACK,MAAM;EAAE+Q,OAAO;EAAEC,OAAO;EAAEgB,cAAc,GAAGrS,QAAQ,CAACI,GAAG;EAAEyR,SAAS,GAAG;AAAM,CAAC,EAAE;EAC/I,MAAM,CAACP,cAAc,EAAEC,cAAc,CAAC,GAAGQ,uBAAuB,CAAC;IAC7DxH,GAAG,EAAE6H,cAAc;IACnBJ,EAAE,EAAEd,OAAO;IACXe,EAAE,EAAEd,OAAO;IACXjN,EAAE,EAAEkN,OAAO;IACXjN,EAAE,EAAEkN,OAAO;IACXa,CAAC,EAAEL;EACP,CAAC,CAAC;EACF,MAAM,CAACL,cAAc,EAAEC,cAAc,CAAC,GAAGM,uBAAuB,CAAC;IAC7DxH,GAAG,EAAE8H,cAAc;IACnBL,EAAE,EAAEZ,OAAO;IACXa,EAAE,EAAEZ,OAAO;IACXnN,EAAE,EAAEgN,OAAO;IACX/M,EAAE,EAAEgN,OAAO;IACXe,CAAC,EAAEL;EACP,CAAC,CAAC;EACF,MAAM,CAACS,MAAM,EAAEC,MAAM,EAAE1P,OAAO,EAAEC,OAAO,CAAC,GAAGmO,mBAAmB,CAAC;IAC3DC,OAAO;IACPC,OAAO;IACPC,OAAO;IACPC,OAAO;IACPC,cAAc;IACdC,cAAc;IACdC,cAAc;IACdC;EACJ,CAAC,CAAC;EACF,OAAO,CACH,IAAIP,OAAO,IAAIC,OAAO,KAAKG,cAAc,IAAIC,cAAc,IAAIC,cAAc,IAAIC,cAAc,IAAIL,OAAO,IAAIC,OAAO,EAAE,EACvHiB,MAAM,EACNC,MAAM,EACN1P,OAAO,EACPC,OAAO,CACV;AACL;;AAEA;AACA,SAAS0P,aAAaA,CAAC;EAAEtB,OAAO;EAAEC,OAAO;EAAEC,OAAO;EAAEC;AAAS,CAAC,EAAE;EAC5D,MAAMoB,OAAO,GAAG5I,IAAI,CAACQ,GAAG,CAAC+G,OAAO,GAAGF,OAAO,CAAC,GAAG,CAAC;EAC/C,MAAMQ,OAAO,GAAGN,OAAO,GAAGF,OAAO,GAAGE,OAAO,GAAGqB,OAAO,GAAGrB,OAAO,GAAGqB,OAAO;EACzE,MAAMC,OAAO,GAAG7I,IAAI,CAACQ,GAAG,CAACgH,OAAO,GAAGF,OAAO,CAAC,GAAG,CAAC;EAC/C,MAAMQ,OAAO,GAAGN,OAAO,GAAGF,OAAO,GAAGE,OAAO,GAAGqB,OAAO,GAAGrB,OAAO,GAAGqB,OAAO;EACzE,OAAO,CAAChB,OAAO,EAAEC,OAAO,EAAEc,OAAO,EAAEC,OAAO,CAAC;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,qBAAqBA,CAAC;EAAEC,UAAU;EAAEC,UAAU;EAAEC,QAAQ,GAAG,KAAK;EAAEC,MAAM;EAAEC,eAAe,GAAG;AAAO,CAAC,EAAE;EAC3G,IAAID,MAAM,KAAKjP,SAAS,EAAE;IACtB,OAAOiP,MAAM;EACjB;EACA,MAAME,KAAK,GAAGD,eAAe,IAAIF,QAAQ,GAAG,IAAI,GAAG,CAAC;EACpD,MAAMI,KAAK,GAAGrJ,IAAI,CAACD,GAAG,CAACgJ,UAAU,CAAC5K,QAAQ,GAAG4K,UAAU,CAAC9M,SAAS,CAACqN,CAAC,GAAG,CAAC,EAAEN,UAAU,CAAC7K,QAAQ,GAAG6K,UAAU,CAAC/M,SAAS,CAACqN,CAAC,GAAG,CAAC,CAAC;EAC1H,OAAOF,KAAK,GAAGC,KAAK;AACxB;AACA,SAASE,aAAaA,CAAC;EAAER,UAAU;EAAEC,UAAU;EAAEpQ,KAAK;EAAEC,MAAM;EAAEkM;AAAU,CAAC,EAAE;EACzE,MAAMyE,OAAO,GAAGjP,gBAAgB,CAACH,SAAS,CAAC2O,UAAU,CAAC,EAAE3O,SAAS,CAAC4O,UAAU,CAAC,CAAC;EAC9E,IAAIQ,OAAO,CAACvU,CAAC,KAAKuU,OAAO,CAACnP,EAAE,EAAE;IAC1BmP,OAAO,CAACnP,EAAE,IAAI,CAAC;EACnB;EACA,IAAImP,OAAO,CAACtU,CAAC,KAAKsU,OAAO,CAAClP,EAAE,EAAE;IAC1BkP,OAAO,CAAClP,EAAE,IAAI,CAAC;EACnB;EACA,MAAMmP,QAAQ,GAAG;IACbxU,CAAC,EAAE,CAAC8P,SAAS,CAAC,CAAC,CAAC,GAAGA,SAAS,CAAC,CAAC,CAAC;IAC/B7P,CAAC,EAAE,CAAC6P,SAAS,CAAC,CAAC,CAAC,GAAGA,SAAS,CAAC,CAAC,CAAC;IAC/BnM,KAAK,EAAEA,KAAK,GAAGmM,SAAS,CAAC,CAAC,CAAC;IAC3BlM,MAAM,EAAEA,MAAM,GAAGkM,SAAS,CAAC,CAAC;EAChC,CAAC;EACD,OAAOnJ,kBAAkB,CAAC6N,QAAQ,EAAEhP,SAAS,CAAC+O,OAAO,CAAC,CAAC,GAAG,CAAC;AAC/D;AACA,MAAME,SAAS,GAAGA,CAAC;EAAEvR,MAAM;EAAEpE,YAAY;EAAEsE,MAAM;EAAErE;AAAa,CAAC,KAAK,YAAYmE,MAAM,GAAGpE,YAAY,IAAI,EAAE,IAAIsE,MAAM,GAAGrE,YAAY,IAAI,EAAE,EAAE;AAC9I,MAAM2V,gBAAgB,GAAGA,CAACzR,IAAI,EAAEH,KAAK,KAAK;EACtC,OAAOA,KAAK,CAAC6R,IAAI,CAAEC,EAAE,IAAKA,EAAE,CAAC1R,MAAM,KAAKD,IAAI,CAACC,MAAM,IAC/C0R,EAAE,CAACxR,MAAM,KAAKH,IAAI,CAACG,MAAM,KACxBwR,EAAE,CAAC9V,YAAY,KAAKmE,IAAI,CAACnE,YAAY,IAAK,CAAC8V,EAAE,CAAC9V,YAAY,IAAI,CAACmE,IAAI,CAACnE,YAAa,CAAC,KAClF8V,EAAE,CAAC7V,YAAY,KAAKkE,IAAI,CAAClE,YAAY,IAAK,CAAC6V,EAAE,CAAC7V,YAAY,IAAI,CAACkE,IAAI,CAAClE,YAAa,CAAC,CAAC;AAC5F,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM8V,OAAO,GAAGA,CAACC,UAAU,EAAEhS,KAAK,KAAK;EACnC,IAAI,CAACgS,UAAU,CAAC5R,MAAM,IAAI,CAAC4R,UAAU,CAAC1R,MAAM,EAAE;IAC1C0J,OAAO,CAAC,KAAK,EAAE9O,aAAa,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;IAC3C,OAAO8E,KAAK;EAChB;EACA,IAAIG,IAAI;EACR,IAAIV,UAAU,CAACuS,UAAU,CAAC,EAAE;IACxB7R,IAAI,GAAG;MAAE,GAAG6R;IAAW,CAAC;EAC5B,CAAC,MACI;IACD7R,IAAI,GAAG;MACH,GAAG6R,UAAU;MACbrW,EAAE,EAAEgW,SAAS,CAACK,UAAU;IAC5B,CAAC;EACL;EACA,IAAIJ,gBAAgB,CAACzR,IAAI,EAAEH,KAAK,CAAC,EAAE;IAC/B,OAAOA,KAAK;EAChB;EACA,IAAIG,IAAI,CAACnE,YAAY,KAAK,IAAI,EAAE;IAC5B,OAAOmE,IAAI,CAACnE,YAAY;EAC5B;EACA,IAAImE,IAAI,CAAClE,YAAY,KAAK,IAAI,EAAE;IAC5B,OAAOkE,IAAI,CAAClE,YAAY;EAC5B;EACA,OAAO+D,KAAK,CAACiS,MAAM,CAAC9R,IAAI,CAAC;AAC7B,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM+R,aAAa,GAAGA,CAACC,OAAO,EAAEC,aAAa,EAAEpS,KAAK,EAAEyE,OAAO,GAAG;EAAE4N,eAAe,EAAE;AAAK,CAAC,KAAK;EAC1F,MAAM;IAAE1W,EAAE,EAAE2W,SAAS;IAAE,GAAGC;EAAK,CAAC,GAAGJ,OAAO;EAC1C,IAAI,CAACC,aAAa,CAAChS,MAAM,IAAI,CAACgS,aAAa,CAAC9R,MAAM,EAAE;IAChD0J,OAAO,CAAC,KAAK,EAAE9O,aAAa,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;IAC3C,OAAO8E,KAAK;EAChB;EACA,MAAMwS,SAAS,GAAGxS,KAAK,CAACsH,IAAI,CAAEK,CAAC,IAAKA,CAAC,CAAChM,EAAE,KAAKwW,OAAO,CAACxW,EAAE,CAAC;EACxD,IAAI,CAAC6W,SAAS,EAAE;IACZxI,OAAO,CAAC,KAAK,EAAE9O,aAAa,CAAC,UAAU,CAAC,CAACoX,SAAS,CAAC,CAAC;IACpD,OAAOtS,KAAK;EAChB;EACA;EACA,MAAMG,IAAI,GAAG;IACT,GAAGoS,IAAI;IACP5W,EAAE,EAAE8I,OAAO,CAAC4N,eAAe,GAAGV,SAAS,CAACS,aAAa,CAAC,GAAGE,SAAS;IAClElS,MAAM,EAAEgS,aAAa,CAAChS,MAAM;IAC5BE,MAAM,EAAE8R,aAAa,CAAC9R,MAAM;IAC5BtE,YAAY,EAAEoW,aAAa,CAACpW,YAAY;IACxCC,YAAY,EAAEmW,aAAa,CAACnW;EAChC,CAAC;EACD,OAAO+D,KAAK,CAACO,MAAM,CAAEoH,CAAC,IAAKA,CAAC,CAAChM,EAAE,KAAK2W,SAAS,CAAC,CAACL,MAAM,CAAC9R,IAAI,CAAC;AAC/D,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASsS,eAAeA,CAAC;EAAEnD,OAAO;EAAEC,OAAO;EAAEC,OAAO;EAAEC;AAAS,CAAC,EAAE;EAC9D,MAAM,CAACiB,MAAM,EAAEC,MAAM,EAAE1P,OAAO,EAAEC,OAAO,CAAC,GAAG0P,aAAa,CAAC;IACrDtB,OAAO;IACPC,OAAO;IACPC,OAAO;IACPC;EACJ,CAAC,CAAC;EACF,OAAO,CAAC,KAAKH,OAAO,IAAIC,OAAO,KAAKC,OAAO,IAAIC,OAAO,EAAE,EAAEiB,MAAM,EAAEC,MAAM,EAAE1P,OAAO,EAAEC,OAAO,CAAC;AAC/F;AAEA,MAAMwR,gBAAgB,GAAG;EACrB,CAACtU,QAAQ,CAACE,IAAI,GAAG;IAAEpB,CAAC,EAAE,CAAC,CAAC;IAAEC,CAAC,EAAE;EAAE,CAAC;EAChC,CAACiB,QAAQ,CAACG,KAAK,GAAG;IAAErB,CAAC,EAAE,CAAC;IAAEC,CAAC,EAAE;EAAE,CAAC;EAChC,CAACiB,QAAQ,CAACI,GAAG,GAAG;IAAEtB,CAAC,EAAE,CAAC;IAAEC,CAAC,EAAE,CAAC;EAAE,CAAC;EAC/B,CAACiB,QAAQ,CAACK,MAAM,GAAG;IAAEvB,CAAC,EAAE,CAAC;IAAEC,CAAC,EAAE;EAAE;AACpC,CAAC;AACD,MAAMwV,YAAY,GAAGA,CAAC;EAAEvS,MAAM;EAAEoQ,cAAc,GAAGpS,QAAQ,CAACK,MAAM;EAAE6B;AAAQ,CAAC,KAAK;EAC5E,IAAIkQ,cAAc,KAAKpS,QAAQ,CAACE,IAAI,IAAIkS,cAAc,KAAKpS,QAAQ,CAACG,KAAK,EAAE;IACvE,OAAO6B,MAAM,CAAClD,CAAC,GAAGoD,MAAM,CAACpD,CAAC,GAAG;MAAEA,CAAC,EAAE,CAAC;MAAEC,CAAC,EAAE;IAAE,CAAC,GAAG;MAAED,CAAC,EAAE,CAAC,CAAC;MAAEC,CAAC,EAAE;IAAE,CAAC;EACjE;EACA,OAAOiD,MAAM,CAACjD,CAAC,GAAGmD,MAAM,CAACnD,CAAC,GAAG;IAAED,CAAC,EAAE,CAAC;IAAEC,CAAC,EAAE;EAAE,CAAC,GAAG;IAAED,CAAC,EAAE,CAAC;IAAEC,CAAC,EAAE,CAAC;EAAE,CAAC;AACjE,CAAC;AACD,MAAM0L,QAAQ,GAAGA,CAAClK,CAAC,EAAEC,CAAC,KAAKqJ,IAAI,CAACiI,IAAI,CAACjI,IAAI,CAAC2K,GAAG,CAAChU,CAAC,CAAC1B,CAAC,GAAGyB,CAAC,CAACzB,CAAC,EAAE,CAAC,CAAC,GAAG+K,IAAI,CAAC2K,GAAG,CAAChU,CAAC,CAACzB,CAAC,GAAGwB,CAAC,CAACxB,CAAC,EAAE,CAAC,CAAC,CAAC;AACrF;AACA;AACA;AACA;AACA,SAAS0V,SAASA,CAAC;EAAEzS,MAAM;EAAEoQ,cAAc,GAAGpS,QAAQ,CAACK,MAAM;EAAE6B,MAAM;EAAEmQ,cAAc,GAAGrS,QAAQ,CAACI,GAAG;EAAEsU,MAAM;EAAEhH,MAAM;EAAEiH;AAAc,CAAC,EAAE;EACnI,MAAMC,SAAS,GAAGN,gBAAgB,CAAClC,cAAc,CAAC;EAClD,MAAMyC,SAAS,GAAGP,gBAAgB,CAACjC,cAAc,CAAC;EAClD,MAAMyC,YAAY,GAAG;IAAEhW,CAAC,EAAEkD,MAAM,CAAClD,CAAC,GAAG8V,SAAS,CAAC9V,CAAC,GAAG4O,MAAM;IAAE3O,CAAC,EAAEiD,MAAM,CAACjD,CAAC,GAAG6V,SAAS,CAAC7V,CAAC,GAAG2O;EAAO,CAAC;EAC/F,MAAMqH,YAAY,GAAG;IAAEjW,CAAC,EAAEoD,MAAM,CAACpD,CAAC,GAAG+V,SAAS,CAAC/V,CAAC,GAAG4O,MAAM;IAAE3O,CAAC,EAAEmD,MAAM,CAACnD,CAAC,GAAG8V,SAAS,CAAC9V,CAAC,GAAG2O;EAAO,CAAC;EAC/F,MAAMsH,GAAG,GAAGT,YAAY,CAAC;IACrBvS,MAAM,EAAE8S,YAAY;IACpB1C,cAAc;IACdlQ,MAAM,EAAE6S;EACZ,CAAC,CAAC;EACF,MAAME,WAAW,GAAGD,GAAG,CAAClW,CAAC,KAAK,CAAC,GAAG,GAAG,GAAG,GAAG;EAC3C,MAAMoW,OAAO,GAAGF,GAAG,CAACC,WAAW,CAAC;EAChC,IAAIE,MAAM,GAAG,EAAE;EACf,IAAIzD,OAAO,EAAEC,OAAO;EACpB,MAAMyD,eAAe,GAAG;IAAEtW,CAAC,EAAE,CAAC;IAAEC,CAAC,EAAE;EAAE,CAAC;EACtC,MAAMsW,eAAe,GAAG;IAAEvW,CAAC,EAAE,CAAC;IAAEC,CAAC,EAAE;EAAE,CAAC;EACtC,MAAM,IAAKuW,cAAc,EAAEC,cAAc,CAAC,GAAG/C,aAAa,CAAC;IACvDtB,OAAO,EAAElP,MAAM,CAAClD,CAAC;IACjBqS,OAAO,EAAEnP,MAAM,CAACjD,CAAC;IACjBqS,OAAO,EAAElP,MAAM,CAACpD,CAAC;IACjBuS,OAAO,EAAEnP,MAAM,CAACnD;EACpB,CAAC,CAAC;EACF;EACA,IAAI6V,SAAS,CAACK,WAAW,CAAC,GAAGJ,SAAS,CAACI,WAAW,CAAC,KAAK,CAAC,CAAC,EAAE;IACxD,IAAIA,WAAW,KAAK,GAAG,EAAE;MACrB;MACAvD,OAAO,GAAGgD,MAAM,CAAC5V,CAAC,IAAKgW,YAAY,CAAChW,CAAC,GAAG,CAACiW,YAAY,CAACjW,CAAC,GAAGgW,YAAY,CAAChW,CAAC,IAAI6V,YAAa;MACzFhD,OAAO,GAAG+C,MAAM,CAAC3V,CAAC,IAAI,CAAC+V,YAAY,CAAC/V,CAAC,GAAGgW,YAAY,CAAChW,CAAC,IAAI,CAAC;IAC/D,CAAC,MACI;MACD;MACA2S,OAAO,GAAGgD,MAAM,CAAC5V,CAAC,IAAI,CAACgW,YAAY,CAAChW,CAAC,GAAGiW,YAAY,CAACjW,CAAC,IAAI,CAAC;MAC3D6S,OAAO,GAAG+C,MAAM,CAAC3V,CAAC,IAAK+V,YAAY,CAAC/V,CAAC,GAAG,CAACgW,YAAY,CAAChW,CAAC,GAAG+V,YAAY,CAAC/V,CAAC,IAAI4V,YAAa;IAC7F;IACA;AACR;AACA;AACA;AACA;IACQ,MAAMa,aAAa,GAAG,CAClB;MAAE1W,CAAC,EAAE4S,OAAO;MAAE3S,CAAC,EAAE+V,YAAY,CAAC/V;IAAE,CAAC,EACjC;MAAED,CAAC,EAAE4S,OAAO;MAAE3S,CAAC,EAAEgW,YAAY,CAAChW;IAAE,CAAC,CACpC;IACD;AACR;AACA;AACA;AACA;IACQ,MAAM0W,eAAe,GAAG,CACpB;MAAE3W,CAAC,EAAEgW,YAAY,CAAChW,CAAC;MAAEC,CAAC,EAAE4S;IAAQ,CAAC,EACjC;MAAE7S,CAAC,EAAEiW,YAAY,CAACjW,CAAC;MAAEC,CAAC,EAAE4S;IAAQ,CAAC,CACpC;IACD,IAAIiD,SAAS,CAACK,WAAW,CAAC,KAAKC,OAAO,EAAE;MACpCC,MAAM,GAAGF,WAAW,KAAK,GAAG,GAAGO,aAAa,GAAGC,eAAe;IAClE,CAAC,MACI;MACDN,MAAM,GAAGF,WAAW,KAAK,GAAG,GAAGQ,eAAe,GAAGD,aAAa;IAClE;EACJ,CAAC,MACI;IACD;IACA,MAAME,YAAY,GAAG,CAAC;MAAE5W,CAAC,EAAEgW,YAAY,CAAChW,CAAC;MAAEC,CAAC,EAAEgW,YAAY,CAAChW;IAAE,CAAC,CAAC;IAC/D,MAAM4W,YAAY,GAAG,CAAC;MAAE7W,CAAC,EAAEiW,YAAY,CAACjW,CAAC;MAAEC,CAAC,EAAE+V,YAAY,CAAC/V;IAAE,CAAC,CAAC;IAC/D;IACA,IAAIkW,WAAW,KAAK,GAAG,EAAE;MACrBE,MAAM,GAAGP,SAAS,CAAC9V,CAAC,KAAKoW,OAAO,GAAGS,YAAY,GAAGD,YAAY;IAClE,CAAC,MACI;MACDP,MAAM,GAAGP,SAAS,CAAC7V,CAAC,KAAKmW,OAAO,GAAGQ,YAAY,GAAGC,YAAY;IAClE;IACA,IAAIvD,cAAc,KAAKC,cAAc,EAAE;MACnC,MAAMtR,IAAI,GAAG8I,IAAI,CAACQ,GAAG,CAACrI,MAAM,CAACiT,WAAW,CAAC,GAAG/S,MAAM,CAAC+S,WAAW,CAAC,CAAC;MAChE;MACA,IAAIlU,IAAI,IAAI2M,MAAM,EAAE;QAChB,MAAMkI,SAAS,GAAG/L,IAAI,CAACF,GAAG,CAAC+D,MAAM,GAAG,CAAC,EAAEA,MAAM,GAAG3M,IAAI,CAAC;QACrD,IAAI6T,SAAS,CAACK,WAAW,CAAC,KAAKC,OAAO,EAAE;UACpCE,eAAe,CAACH,WAAW,CAAC,GAAG,CAACH,YAAY,CAACG,WAAW,CAAC,GAAGjT,MAAM,CAACiT,WAAW,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,IAAIW,SAAS;QACzG,CAAC,MACI;UACDP,eAAe,CAACJ,WAAW,CAAC,GAAG,CAACF,YAAY,CAACE,WAAW,CAAC,GAAG/S,MAAM,CAAC+S,WAAW,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,IAAIW,SAAS;QACzG;MACJ;IACJ;IACA;IACA,IAAIxD,cAAc,KAAKC,cAAc,EAAE;MACnC,MAAMwD,mBAAmB,GAAGZ,WAAW,KAAK,GAAG,GAAG,GAAG,GAAG,GAAG;MAC3D,MAAMa,SAAS,GAAGlB,SAAS,CAACK,WAAW,CAAC,KAAKJ,SAAS,CAACgB,mBAAmB,CAAC;MAC3E,MAAME,kBAAkB,GAAGjB,YAAY,CAACe,mBAAmB,CAAC,GAAGd,YAAY,CAACc,mBAAmB,CAAC;MAChG,MAAMG,kBAAkB,GAAGlB,YAAY,CAACe,mBAAmB,CAAC,GAAGd,YAAY,CAACc,mBAAmB,CAAC;MAChG,MAAMI,gBAAgB,GAAIrB,SAAS,CAACK,WAAW,CAAC,KAAK,CAAC,KAAM,CAACa,SAAS,IAAIC,kBAAkB,IAAMD,SAAS,IAAIE,kBAAmB,CAAC,IAC9HpB,SAAS,CAACK,WAAW,CAAC,KAAK,CAAC,KAAM,CAACa,SAAS,IAAIE,kBAAkB,IAAMF,SAAS,IAAIC,kBAAmB,CAAE;MAC/G,IAAIE,gBAAgB,EAAE;QAClBd,MAAM,GAAGF,WAAW,KAAK,GAAG,GAAGS,YAAY,GAAGC,YAAY;MAC9D;IACJ;IACA,MAAMO,cAAc,GAAG;MAAEpX,CAAC,EAAEgW,YAAY,CAAChW,CAAC,GAAGsW,eAAe,CAACtW,CAAC;MAAEC,CAAC,EAAE+V,YAAY,CAAC/V,CAAC,GAAGqW,eAAe,CAACrW;IAAE,CAAC;IACvG,MAAMoX,cAAc,GAAG;MAAErX,CAAC,EAAEiW,YAAY,CAACjW,CAAC,GAAGuW,eAAe,CAACvW,CAAC;MAAEC,CAAC,EAAEgW,YAAY,CAAChW,CAAC,GAAGsW,eAAe,CAACtW;IAAE,CAAC;IACvG,MAAMqX,YAAY,GAAGvM,IAAI,CAACD,GAAG,CAACC,IAAI,CAACQ,GAAG,CAAC6L,cAAc,CAACpX,CAAC,GAAGqW,MAAM,CAAC,CAAC,CAAC,CAACrW,CAAC,CAAC,EAAE+K,IAAI,CAACQ,GAAG,CAAC8L,cAAc,CAACrX,CAAC,GAAGqW,MAAM,CAAC,CAAC,CAAC,CAACrW,CAAC,CAAC,CAAC;IACjH,MAAMuX,YAAY,GAAGxM,IAAI,CAACD,GAAG,CAACC,IAAI,CAACQ,GAAG,CAAC6L,cAAc,CAACnX,CAAC,GAAGoW,MAAM,CAAC,CAAC,CAAC,CAACpW,CAAC,CAAC,EAAE8K,IAAI,CAACQ,GAAG,CAAC8L,cAAc,CAACpX,CAAC,GAAGoW,MAAM,CAAC,CAAC,CAAC,CAACpW,CAAC,CAAC,CAAC;IACjH;IACA,IAAIqX,YAAY,IAAIC,YAAY,EAAE;MAC9B3E,OAAO,GAAG,CAACwE,cAAc,CAACpX,CAAC,GAAGqX,cAAc,CAACrX,CAAC,IAAI,CAAC;MACnD6S,OAAO,GAAGwD,MAAM,CAAC,CAAC,CAAC,CAACpW,CAAC;IACzB,CAAC,MACI;MACD2S,OAAO,GAAGyD,MAAM,CAAC,CAAC,CAAC,CAACrW,CAAC;MACrB6S,OAAO,GAAG,CAACuE,cAAc,CAACnX,CAAC,GAAGoX,cAAc,CAACpX,CAAC,IAAI,CAAC;IACvD;EACJ;EACA,MAAMuX,UAAU,GAAG,CACftU,MAAM,EACN;IAAElD,CAAC,EAAEgW,YAAY,CAAChW,CAAC,GAAGsW,eAAe,CAACtW,CAAC;IAAEC,CAAC,EAAE+V,YAAY,CAAC/V,CAAC,GAAGqW,eAAe,CAACrW;EAAE,CAAC,EAChF,GAAGoW,MAAM,EACT;IAAErW,CAAC,EAAEiW,YAAY,CAACjW,CAAC,GAAGuW,eAAe,CAACvW,CAAC;IAAEC,CAAC,EAAEgW,YAAY,CAAChW,CAAC,GAAGsW,eAAe,CAACtW;EAAE,CAAC,EAChFmD,MAAM,CACT;EACD,OAAO,CAACoU,UAAU,EAAE5E,OAAO,EAAEC,OAAO,EAAE2D,cAAc,EAAEC,cAAc,CAAC;AACzE;AACA,SAASgB,OAAOA,CAAChW,CAAC,EAAEC,CAAC,EAAE0R,CAAC,EAAEzR,IAAI,EAAE;EAC5B,MAAM+V,QAAQ,GAAG3M,IAAI,CAACF,GAAG,CAACc,QAAQ,CAAClK,CAAC,EAAEC,CAAC,CAAC,GAAG,CAAC,EAAEiK,QAAQ,CAACjK,CAAC,EAAE0R,CAAC,CAAC,GAAG,CAAC,EAAEzR,IAAI,CAAC;EACvE,MAAM;IAAE3B,CAAC;IAAEC;EAAE,CAAC,GAAGyB,CAAC;EAClB;EACA,IAAKD,CAAC,CAACzB,CAAC,KAAKA,CAAC,IAAIA,CAAC,KAAKoT,CAAC,CAACpT,CAAC,IAAMyB,CAAC,CAACxB,CAAC,KAAKA,CAAC,IAAIA,CAAC,KAAKmT,CAAC,CAACnT,CAAE,EAAE;IACtD,OAAO,IAAID,CAAC,IAAIC,CAAC,EAAE;EACvB;EACA;EACA,IAAIwB,CAAC,CAACxB,CAAC,KAAKA,CAAC,EAAE;IACX,MAAM0X,IAAI,GAAGlW,CAAC,CAACzB,CAAC,GAAGoT,CAAC,CAACpT,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC;IAC/B,MAAM4X,IAAI,GAAGnW,CAAC,CAACxB,CAAC,GAAGmT,CAAC,CAACnT,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;IAC/B,OAAO,KAAKD,CAAC,GAAG0X,QAAQ,GAAGC,IAAI,IAAI1X,CAAC,KAAKD,CAAC,IAAIC,CAAC,IAAID,CAAC,IAAIC,CAAC,GAAGyX,QAAQ,GAAGE,IAAI,EAAE;EACjF;EACA,MAAMD,IAAI,GAAGlW,CAAC,CAACzB,CAAC,GAAGoT,CAAC,CAACpT,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;EAC/B,MAAM4X,IAAI,GAAGnW,CAAC,CAACxB,CAAC,GAAGmT,CAAC,CAACnT,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC;EAC/B,OAAO,KAAKD,CAAC,IAAIC,CAAC,GAAGyX,QAAQ,GAAGE,IAAI,KAAK5X,CAAC,IAAIC,CAAC,IAAID,CAAC,GAAG0X,QAAQ,GAAGC,IAAI,IAAI1X,CAAC,EAAE;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS4X,iBAAiBA,CAAC;EAAEzF,OAAO;EAAEC,OAAO;EAAEiB,cAAc,GAAGpS,QAAQ,CAACK,MAAM;EAAE+Q,OAAO;EAAEC,OAAO;EAAEgB,cAAc,GAAGrS,QAAQ,CAACI,GAAG;EAAEwW,YAAY,GAAG,CAAC;EAAElF,OAAO;EAAEC,OAAO;EAAEjE,MAAM,GAAG,EAAE;EAAEiH,YAAY,GAAG;AAAK,CAAC,EAAE;EACtM,MAAM,CAACQ,MAAM,EAAE7C,MAAM,EAAEC,MAAM,EAAE1P,OAAO,EAAEC,OAAO,CAAC,GAAG2R,SAAS,CAAC;IACzDzS,MAAM,EAAE;MAAElD,CAAC,EAAEoS,OAAO;MAAEnS,CAAC,EAAEoS;IAAQ,CAAC;IAClCiB,cAAc;IACdlQ,MAAM,EAAE;MAAEpD,CAAC,EAAEsS,OAAO;MAAErS,CAAC,EAAEsS;IAAQ,CAAC;IAClCgB,cAAc;IACdqC,MAAM,EAAE;MAAE5V,CAAC,EAAE4S,OAAO;MAAE3S,CAAC,EAAE4S;IAAQ,CAAC;IAClCjE,MAAM;IACNiH;EACJ,CAAC,CAAC;EACF,MAAMkC,IAAI,GAAG1B,MAAM,CAAC1R,MAAM,CAAC,CAAC6K,GAAG,EAAEnB,CAAC,EAAE2J,CAAC,KAAK;IACtC,IAAIC,OAAO,GAAG,EAAE;IAChB,IAAID,CAAC,GAAG,CAAC,IAAIA,CAAC,GAAG3B,MAAM,CAAChU,MAAM,GAAG,CAAC,EAAE;MAChC4V,OAAO,GAAGR,OAAO,CAACpB,MAAM,CAAC2B,CAAC,GAAG,CAAC,CAAC,EAAE3J,CAAC,EAAEgI,MAAM,CAAC2B,CAAC,GAAG,CAAC,CAAC,EAAEF,YAAY,CAAC;IACpE,CAAC,MACI;MACDG,OAAO,GAAG,GAAGD,CAAC,KAAK,CAAC,GAAG,GAAG,GAAG,GAAG,GAAG3J,CAAC,CAACrO,CAAC,IAAIqO,CAAC,CAACpO,CAAC,EAAE;IACnD;IACAuP,GAAG,IAAIyI,OAAO;IACd,OAAOzI,GAAG;EACd,CAAC,EAAE,EAAE,CAAC;EACN,OAAO,CAACuI,IAAI,EAAEvE,MAAM,EAAEC,MAAM,EAAE1P,OAAO,EAAEC,OAAO,CAAC;AACnD;AAEA,SAASkU,iBAAiBA,CAACtV,IAAI,EAAE;EAC7B,OAAQA,IAAI,IACR,CAAC,EAAEA,IAAI,CAACoE,SAAS,CAACC,YAAY,IAAIrE,IAAI,CAACiP,OAAO,EAAExP,MAAM,CAAC,IACvD,CAAC,EAAEO,IAAI,CAACyD,QAAQ,CAAC1C,KAAK,IAAIf,IAAI,CAACe,KAAK,IAAIf,IAAI,CAAC4D,YAAY,CAAC;AAClE;AACA,SAAS2R,eAAeA,CAAChU,MAAM,EAAE;EAC7B,MAAM;IAAE2P,UAAU;IAAEC;EAAW,CAAC,GAAG5P,MAAM;EACzC,IAAI,CAAC+T,iBAAiB,CAACpE,UAAU,CAAC,IAAI,CAACoE,iBAAiB,CAACnE,UAAU,CAAC,EAAE;IAClE,OAAO,IAAI;EACf;EACA,MAAMqE,kBAAkB,GAAGtE,UAAU,CAAC9M,SAAS,CAACC,YAAY,IAAIoR,cAAc,CAACvE,UAAU,CAACjC,OAAO,CAAC;EAClG,MAAMyG,kBAAkB,GAAGvE,UAAU,CAAC/M,SAAS,CAACC,YAAY,IAAIoR,cAAc,CAACtE,UAAU,CAAClC,OAAO,CAAC;EAClG,MAAM/S,YAAY,GAAGyZ,WAAW,CAACH,kBAAkB,EAAElV,MAAM,IAAI,EAAE,EAAEiB,MAAM,CAACrF,YAAY,CAAC;EACvF,MAAMC,YAAY,GAAGwZ,WAAW;EAChC;EACApU,MAAM,CAACqU,cAAc,KAAKtY,cAAc,CAACuY,MAAM,GACzCH,kBAAkB,EAAElV,MAAM,IAAI,EAAE,GAChC,CAACkV,kBAAkB,EAAElV,MAAM,IAAI,EAAE,EAAE2R,MAAM,CAACuD,kBAAkB,EAAEpV,MAAM,IAAI,EAAE,CAAC,EAAEiB,MAAM,CAACpF,YAAY,CAAC;EACvG,IAAI,CAACD,YAAY,IAAI,CAACC,YAAY,EAAE;IAChCoF,MAAM,CAAC6E,OAAO,GAAG,KAAK,EAAEhL,aAAa,CAAC,UAAU,CAAC,CAAC,CAACc,YAAY,GAAG,QAAQ,GAAG,QAAQ,EAAE;MACnFL,EAAE,EAAE0F,MAAM,CAAC1F,EAAE;MACbK,YAAY,EAAEqF,MAAM,CAACrF,YAAY;MACjCC,YAAY,EAAEoF,MAAM,CAACpF;IACzB,CAAC,CAAC,CAAC;IACH,OAAO,IAAI;EACf;EACA,MAAMuU,cAAc,GAAGxU,YAAY,EAAEmF,QAAQ,IAAI/C,QAAQ,CAACK,MAAM;EAChE,MAAMgS,cAAc,GAAGxU,YAAY,EAAEkF,QAAQ,IAAI/C,QAAQ,CAACI,GAAG;EAC7D,MAAM4B,MAAM,GAAGwV,iBAAiB,CAAC5E,UAAU,EAAEhV,YAAY,EAAEwU,cAAc,CAAC;EAC1E,MAAMlQ,MAAM,GAAGsV,iBAAiB,CAAC3E,UAAU,EAAEhV,YAAY,EAAEwU,cAAc,CAAC;EAC1E,OAAO;IACHnB,OAAO,EAAElP,MAAM,CAAClD,CAAC;IACjBqS,OAAO,EAAEnP,MAAM,CAACjD,CAAC;IACjBqS,OAAO,EAAElP,MAAM,CAACpD,CAAC;IACjBuS,OAAO,EAAEnP,MAAM,CAACnD,CAAC;IACjBqT,cAAc;IACdC;EACJ,CAAC;AACL;AACA,SAAS8E,cAAcA,CAACxG,OAAO,EAAE;EAC7B,IAAI,CAACA,OAAO,EAAE;IACV,OAAO,IAAI;EACf;EACA,MAAM3O,MAAM,GAAG,EAAE;EACjB,MAAME,MAAM,GAAG,EAAE;EACjB,KAAK,MAAM4O,MAAM,IAAIH,OAAO,EAAE;IAC1BG,MAAM,CAACrO,KAAK,GAAGqO,MAAM,CAACrO,KAAK,IAAI,CAAC;IAChCqO,MAAM,CAACpO,MAAM,GAAGoO,MAAM,CAACpO,MAAM,IAAI,CAAC;IAClC,IAAIoO,MAAM,CAACrT,IAAI,KAAK,QAAQ,EAAE;MAC1BuE,MAAM,CAACd,IAAI,CAAC4P,MAAM,CAAC;IACvB,CAAC,MACI,IAAIA,MAAM,CAACrT,IAAI,KAAK,QAAQ,EAAE;MAC/ByE,MAAM,CAAChB,IAAI,CAAC4P,MAAM,CAAC;IACvB;EACJ;EACA,OAAO;IACH9O,MAAM;IACNE;EACJ,CAAC;AACL;AACA,SAASsV,iBAAiBA,CAAC9V,IAAI,EAAEoP,MAAM,EAAE2G,gBAAgB,GAAGzX,QAAQ,CAACE,IAAI,EAAEwU,MAAM,GAAG,KAAK,EAAE;EACvF,MAAM5V,CAAC,GAAG,CAACgS,MAAM,EAAEhS,CAAC,IAAI,CAAC,IAAI4C,IAAI,CAACoE,SAAS,CAACqC,gBAAgB,CAACrJ,CAAC;EAC9D,MAAMC,CAAC,GAAG,CAAC+R,MAAM,EAAE/R,CAAC,IAAI,CAAC,IAAI2C,IAAI,CAACoE,SAAS,CAACqC,gBAAgB,CAACpJ,CAAC;EAC9D,MAAM;IAAE0D,KAAK;IAAEC;EAAO,CAAC,GAAGoO,MAAM,IAAInO,iBAAiB,CAACjB,IAAI,CAAC;EAC3D,IAAIgT,MAAM,EAAE;IACR,OAAO;MAAE5V,CAAC,EAAEA,CAAC,GAAG2D,KAAK,GAAG,CAAC;MAAE1D,CAAC,EAAEA,CAAC,GAAG2D,MAAM,GAAG;IAAE,CAAC;EAClD;EACA,MAAMK,QAAQ,GAAG+N,MAAM,EAAE/N,QAAQ,IAAI0U,gBAAgB;EACrD,QAAQ1U,QAAQ;IACZ,KAAK/C,QAAQ,CAACI,GAAG;MACb,OAAO;QAAEtB,CAAC,EAAEA,CAAC,GAAG2D,KAAK,GAAG,CAAC;QAAE1D;MAAE,CAAC;IAClC,KAAKiB,QAAQ,CAACG,KAAK;MACf,OAAO;QAAErB,CAAC,EAAEA,CAAC,GAAG2D,KAAK;QAAE1D,CAAC,EAAEA,CAAC,GAAG2D,MAAM,GAAG;MAAE,CAAC;IAC9C,KAAK1C,QAAQ,CAACK,MAAM;MAChB,OAAO;QAAEvB,CAAC,EAAEA,CAAC,GAAG2D,KAAK,GAAG,CAAC;QAAE1D,CAAC,EAAEA,CAAC,GAAG2D;MAAO,CAAC;IAC9C,KAAK1C,QAAQ,CAACE,IAAI;MACd,OAAO;QAAEpB,CAAC;QAAEC,CAAC,EAAEA,CAAC,GAAG2D,MAAM,GAAG;MAAE,CAAC;EACvC;AACJ;AACA,SAAS2U,WAAWA,CAAClQ,MAAM,EAAEuQ,QAAQ,EAAE;EACnC,IAAI,CAACvQ,MAAM,EAAE;IACT,OAAO,IAAI;EACf;EACA;EACA,OAAO,CAAC,CAACuQ,QAAQ,GAAGvQ,MAAM,CAAC,CAAC,CAAC,GAAGA,MAAM,CAAC+B,IAAI,CAAEyO,CAAC,IAAKA,CAAC,CAACpa,EAAE,KAAKma,QAAQ,CAAC,KAAK,IAAI;AAClF;AAEA,SAASE,WAAWA,CAACC,MAAM,EAAEta,EAAE,EAAE;EAC7B,IAAI,CAACsa,MAAM,EAAE;IACT,OAAO,EAAE;EACb;EACA,IAAI,OAAOA,MAAM,KAAK,QAAQ,EAAE;IAC5B,OAAOA,MAAM;EACjB;EACA,MAAMC,QAAQ,GAAGva,EAAE,GAAG,GAAGA,EAAE,IAAI,GAAG,EAAE;EACpC,OAAO,GAAGua,QAAQ,GAAGC,MAAM,CAACpX,IAAI,CAACkX,MAAM,CAAC,CACnCG,IAAI,CAAC,CAAC,CACNvR,GAAG,CAAE/F,GAAG,IAAK,GAAGA,GAAG,IAAImX,MAAM,CAACnX,GAAG,CAAC,EAAE,CAAC,CACrCuX,IAAI,CAAC,GAAG,CAAC,EAAE;AACpB;AACA,SAASC,eAAeA,CAACtW,KAAK,EAAE;EAAErE,EAAE;EAAE4a,YAAY;EAAEC,kBAAkB;EAAEC;AAAkB,CAAC,EAAE;EACzF,MAAMC,GAAG,GAAG,IAAIxW,GAAG,CAAC,CAAC;EACrB,OAAOF,KAAK,CACP6B,MAAM,CAAC,CAAC8U,OAAO,EAAExW,IAAI,KAAK;IAC3B,CAACA,IAAI,CAACyW,WAAW,IAAIJ,kBAAkB,EAAErW,IAAI,CAAC0W,SAAS,IAAIJ,gBAAgB,CAAC,CAACrX,OAAO,CAAE6W,MAAM,IAAK;MAC7F,IAAIA,MAAM,IAAI,OAAOA,MAAM,KAAK,QAAQ,EAAE;QACtC,MAAMa,QAAQ,GAAGd,WAAW,CAACC,MAAM,EAAEta,EAAE,CAAC;QACxC,IAAI,CAAC+a,GAAG,CAAC1X,GAAG,CAAC8X,QAAQ,CAAC,EAAE;UACpBH,OAAO,CAACrX,IAAI,CAAC;YAAE3D,EAAE,EAAEmb,QAAQ;YAAEC,KAAK,EAAEd,MAAM,CAACc,KAAK,IAAIR,YAAY;YAAE,GAAGN;UAAO,CAAC,CAAC;UAC9ES,GAAG,CAACrW,GAAG,CAACyW,QAAQ,CAAC;QACrB;MACJ;IACJ,CAAC,CAAC;IACF,OAAOH,OAAO;EAClB,CAAC,EAAE,EAAE,CAAC,CACDP,IAAI,CAAC,CAACzX,CAAC,EAAEC,CAAC,KAAKD,CAAC,CAAChD,EAAE,CAACqb,aAAa,CAACpY,CAAC,CAACjD,EAAE,CAAC,CAAC;AACjD;AAEA,SAASsb,uBAAuBA,CAACC,QAAQ,EAAE1R,QAAQ,EAAErE,QAAQ,EAAE2K,MAAM,EAAEqL,KAAK,EAAE;EAC1E,IAAIC,eAAe,GAAG,GAAG;EACzB,IAAID,KAAK,KAAK,OAAO,EAAE;IACnBC,eAAe,GAAG,CAAC;EACvB,CAAC,MACI,IAAID,KAAK,KAAK,KAAK,EAAE;IACtBC,eAAe,GAAG,CAAC;EACvB;EACA;AACJ;AACA;AACA;EACI,IAAIzO,GAAG,GAAG,CACN,CAACuO,QAAQ,CAACha,CAAC,GAAGga,QAAQ,CAACrW,KAAK,GAAGuW,eAAe,IAAI5R,QAAQ,CAAC3K,IAAI,GAAG2K,QAAQ,CAACtI,CAAC,EAC5Ega,QAAQ,CAAC/Z,CAAC,GAAGqI,QAAQ,CAAC3K,IAAI,GAAG2K,QAAQ,CAACrI,CAAC,GAAG2O,MAAM,CACnD;EACD;EACA,IAAIuL,KAAK,GAAG,CAAC,CAAC,GAAG,GAAGD,eAAe,EAAE,CAAC,GAAG,CAAC;EAC1C,QAAQjW,QAAQ;IACZ,KAAK/C,QAAQ,CAACG,KAAK;MACfoK,GAAG,GAAG,CACF,CAACuO,QAAQ,CAACha,CAAC,GAAGga,QAAQ,CAACrW,KAAK,IAAI2E,QAAQ,CAAC3K,IAAI,GAAG2K,QAAQ,CAACtI,CAAC,GAAG4O,MAAM,EACnE,CAACoL,QAAQ,CAAC/Z,CAAC,GAAG+Z,QAAQ,CAACpW,MAAM,GAAGsW,eAAe,IAAI5R,QAAQ,CAAC3K,IAAI,GAAG2K,QAAQ,CAACrI,CAAC,CAChF;MACDka,KAAK,GAAG,CAAC,CAAC,EAAE,CAAC,GAAG,GAAGD,eAAe,CAAC;MACnC;IACJ,KAAKhZ,QAAQ,CAACK,MAAM;MAChBkK,GAAG,CAAC,CAAC,CAAC,GAAG,CAACuO,QAAQ,CAAC/Z,CAAC,GAAG+Z,QAAQ,CAACpW,MAAM,IAAI0E,QAAQ,CAAC3K,IAAI,GAAG2K,QAAQ,CAACrI,CAAC,GAAG2O,MAAM;MAC7EuL,KAAK,CAAC,CAAC,CAAC,GAAG,CAAC;MACZ;IACJ,KAAKjZ,QAAQ,CAACE,IAAI;MACdqK,GAAG,GAAG,CACFuO,QAAQ,CAACha,CAAC,GAAGsI,QAAQ,CAAC3K,IAAI,GAAG2K,QAAQ,CAACtI,CAAC,GAAG4O,MAAM,EAChD,CAACoL,QAAQ,CAAC/Z,CAAC,GAAG+Z,QAAQ,CAACpW,MAAM,GAAGsW,eAAe,IAAI5R,QAAQ,CAAC3K,IAAI,GAAG2K,QAAQ,CAACrI,CAAC,CAChF;MACDka,KAAK,GAAG,CAAC,CAAC,GAAG,EAAE,CAAC,GAAG,GAAGD,eAAe,CAAC;MACtC;EACR;EACA,OAAO,aAAazO,GAAG,CAAC,CAAC,CAAC,OAAOA,GAAG,CAAC,CAAC,CAAC,iBAAiB0O,KAAK,CAAC,CAAC,CAAC,MAAMA,KAAK,CAAC,CAAC,CAAC,IAAI;AACtF;AAEA,MAAMC,cAAc,GAAG;EACnB1W,UAAU,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC;EAClBqF,UAAU,EAAEvJ,cAAc;EAC1B6a,oBAAoB,EAAE,IAAI;EAC1BC,QAAQ,EAAE,CAAC;AACf,CAAC;AACD,MAAMC,4BAA4B,GAAG;EACjC,GAAGH,cAAc;EACjBI,aAAa,EAAE;AACnB,CAAC;AACD,SAASC,YAAYA,CAACC,IAAI,EAAEC,QAAQ,EAAE;EAClC,MAAMC,MAAM,GAAG;IAAE,GAAGF;EAAK,CAAC;EAC1B,KAAK,MAAM9Y,GAAG,IAAI+Y,QAAQ,EAAE;IACxB,IAAIA,QAAQ,CAAC/Y,GAAG,CAAC,KAAKoD,SAAS,EAAE;MAC7B;MACA4V,MAAM,CAAChZ,GAAG,CAAC,GAAG+Y,QAAQ,CAAC/Y,GAAG,CAAC;IAC/B;EACJ;EACA,OAAOgZ,MAAM;AACjB;AACA,SAASC,uBAAuBA,CAACtW,UAAU,EAAEuW,YAAY,EAAEvT,OAAO,EAAE;EAChE,MAAMwT,QAAQ,GAAGN,YAAY,CAACL,cAAc,EAAE7S,OAAO,CAAC;EACtD,KAAK,MAAM3E,IAAI,IAAI2B,UAAU,CAAC6B,MAAM,CAAC,CAAC,EAAE;IACpC,IAAIxD,IAAI,CAACsG,QAAQ,EAAE;MACf8R,eAAe,CAACpY,IAAI,EAAE2B,UAAU,EAAEuW,YAAY,EAAEC,QAAQ,CAAC;IAC7D,CAAC,MACI;MACD,MAAME,kBAAkB,GAAGxX,yBAAyB,CAACb,IAAI,EAAEmY,QAAQ,CAACrX,UAAU,CAAC;MAC/E,MAAM4F,MAAM,GAAGI,kBAAkB,CAAC9G,IAAI,CAAC0G,MAAM,CAAC,GAAG1G,IAAI,CAAC0G,MAAM,GAAGyR,QAAQ,CAAChS,UAAU;MAClF,MAAMmS,eAAe,GAAGvR,aAAa,CAACsR,kBAAkB,EAAE3R,MAAM,EAAEzF,iBAAiB,CAACjB,IAAI,CAAC,CAAC;MAC1FA,IAAI,CAACoE,SAAS,CAACqC,gBAAgB,GAAG6R,eAAe;IACrD;EACJ;AACJ;AACA,SAASC,cAAcA,CAACtY,KAAK,EAAE0B,UAAU,EAAEuW,YAAY,EAAEvT,OAAO,EAAE;EAC9D,MAAMwT,QAAQ,GAAGN,YAAY,CAACF,4BAA4B,EAAEhT,OAAO,CAAC;EACpE,IAAI6T,gBAAgB,GAAGvY,KAAK,CAACR,MAAM,GAAG,CAAC;EACvC,MAAMgZ,SAAS,GAAG,IAAI5T,GAAG,CAAClD,UAAU,CAAC;EACrC,MAAM+W,aAAa,GAAGP,QAAQ,EAAEV,oBAAoB,GAAG,IAAI,GAAG,CAAC;EAC/D9V,UAAU,CAACgX,KAAK,CAAC,CAAC;EAClBT,YAAY,CAACS,KAAK,CAAC,CAAC;EACpB,KAAK,MAAMC,QAAQ,IAAI3Y,KAAK,EAAE;IAC1B,IAAI4Y,YAAY,GAAGJ,SAAS,CAACpW,GAAG,CAACuW,QAAQ,CAAC/c,EAAE,CAAC;IAC7C,IAAIsc,QAAQ,CAACP,aAAa,IAAIgB,QAAQ,KAAKC,YAAY,EAAEzU,SAAS,CAACwU,QAAQ,EAAE;MACzEjX,UAAU,CAACsD,GAAG,CAAC2T,QAAQ,CAAC/c,EAAE,EAAEgd,YAAY,CAAC;IAC7C,CAAC,MACI;MACD,MAAMR,kBAAkB,GAAGxX,yBAAyB,CAAC+X,QAAQ,EAAET,QAAQ,CAACrX,UAAU,CAAC;MACnF,MAAM4F,MAAM,GAAGI,kBAAkB,CAAC8R,QAAQ,CAAClS,MAAM,CAAC,GAAGkS,QAAQ,CAAClS,MAAM,GAAGyR,QAAQ,CAAChS,UAAU;MAC1F,MAAMmS,eAAe,GAAGvR,aAAa,CAACsR,kBAAkB,EAAE3R,MAAM,EAAEzF,iBAAiB,CAAC2X,QAAQ,CAAC,CAAC;MAC9FC,YAAY,GAAG;QACX,GAAGV,QAAQ,CAACT,QAAQ;QACpB,GAAGkB,QAAQ;QACXnV,QAAQ,EAAE;UACN1C,KAAK,EAAE6X,QAAQ,CAACnV,QAAQ,EAAE1C,KAAK;UAC/BC,MAAM,EAAE4X,QAAQ,CAACnV,QAAQ,EAAEzC;QAC/B,CAAC;QACDoD,SAAS,EAAE;UACPqC,gBAAgB,EAAE6R,eAAe;UACjC;UACAjU,YAAY,EAAE,CAACuU,QAAQ,CAACnV,QAAQ,GAAGrB,SAAS,GAAGyW,YAAY,EAAEzU,SAAS,CAACC,YAAY;UACnFoN,CAAC,EAAEqH,UAAU,CAACF,QAAQ,EAAEF,aAAa,CAAC;UACtCE;QACJ;MACJ,CAAC;MACDjX,UAAU,CAACsD,GAAG,CAAC2T,QAAQ,CAAC/c,EAAE,EAAEgd,YAAY,CAAC;IAC7C;IACA,IAAI,CAACA,YAAY,CAACpV,QAAQ,KAAKrB,SAAS,IACpCyW,YAAY,CAACpV,QAAQ,CAAC1C,KAAK,KAAKqB,SAAS,IACzCyW,YAAY,CAACpV,QAAQ,CAACzC,MAAM,KAAKoB,SAAS,KAC1C,CAACyW,YAAY,CAAClV,MAAM,EAAE;MACtB6U,gBAAgB,GAAG,KAAK;IAC5B;IACA,IAAII,QAAQ,CAACtS,QAAQ,EAAE;MACnB8R,eAAe,CAACS,YAAY,EAAElX,UAAU,EAAEuW,YAAY,EAAEvT,OAAO,CAAC;IACpE;EACJ;EACA,OAAO6T,gBAAgB;AAC3B;AACA,SAASO,kBAAkBA,CAAC/Y,IAAI,EAAEkY,YAAY,EAAE;EAC5C,IAAI,CAAClY,IAAI,CAACsG,QAAQ,EAAE;IAChB;EACJ;EACA,MAAM0S,UAAU,GAAGd,YAAY,CAAC7V,GAAG,CAACrC,IAAI,CAACsG,QAAQ,CAAC;EAClD,IAAI0S,UAAU,EAAE;IACZA,UAAU,CAAC/T,GAAG,CAACjF,IAAI,CAACnE,EAAE,EAAEmE,IAAI,CAAC;EACjC,CAAC,MACI;IACDkY,YAAY,CAACjT,GAAG,CAACjF,IAAI,CAACsG,QAAQ,EAAE,IAAIzB,GAAG,CAAC,CAAC,CAAC7E,IAAI,CAACnE,EAAE,EAAEmE,IAAI,CAAC,CAAC,CAAC,CAAC;EAC/D;AACJ;AACA;AACA;AACA;AACA,SAASoY,eAAeA,CAACpY,IAAI,EAAE2B,UAAU,EAAEuW,YAAY,EAAEvT,OAAO,EAAE;EAC9D,MAAM;IAAE8S,oBAAoB;IAAE3W,UAAU;IAAEqF;EAAW,CAAC,GAAG0R,YAAY,CAACL,cAAc,EAAE7S,OAAO,CAAC;EAC9F,MAAM2B,QAAQ,GAAGtG,IAAI,CAACsG,QAAQ;EAC9B,MAAMD,UAAU,GAAG1E,UAAU,CAACU,GAAG,CAACiE,QAAQ,CAAC;EAC3C,IAAI,CAACD,UAAU,EAAE;IACbzE,OAAO,CAACC,IAAI,CAAC,eAAeyE,QAAQ,sGAAsG,CAAC;IAC3I;EACJ;EACAyS,kBAAkB,CAAC/Y,IAAI,EAAEkY,YAAY,CAAC;EACtC,MAAMQ,aAAa,GAAGjB,oBAAoB,GAAG,IAAI,GAAG,CAAC;EACrD,MAAM;IAAEra,CAAC;IAAEC,CAAC;IAAEoU;EAAE,CAAC,GAAGwH,iBAAiB,CAACjZ,IAAI,EAAEqG,UAAU,EAAEvF,UAAU,EAAEqF,UAAU,EAAEuS,aAAa,CAAC;EAC9F,MAAM;IAAEjS;EAAiB,CAAC,GAAGzG,IAAI,CAACoE,SAAS;EAC3C,MAAM8U,eAAe,GAAG9b,CAAC,KAAKqJ,gBAAgB,CAACrJ,CAAC,IAAIC,CAAC,KAAKoJ,gBAAgB,CAACpJ,CAAC;EAC5E,IAAI6b,eAAe,IAAIzH,CAAC,KAAKzR,IAAI,CAACoE,SAAS,CAACqN,CAAC,EAAE;IAC3C;IACA9P,UAAU,CAACsD,GAAG,CAACjF,IAAI,CAACnE,EAAE,EAAE;MACpB,GAAGmE,IAAI;MACPoE,SAAS,EAAE;QACP,GAAGpE,IAAI,CAACoE,SAAS;QACjBqC,gBAAgB,EAAEyS,eAAe,GAAG;UAAE9b,CAAC;UAAEC;QAAE,CAAC,GAAGoJ,gBAAgB;QAC/DgL;MACJ;IACJ,CAAC,CAAC;EACN;AACJ;AACA,SAASqH,UAAUA,CAAC9Y,IAAI,EAAE0Y,aAAa,EAAE;EACrC,OAAO,CAAC3O,SAAS,CAAC/J,IAAI,CAACqR,MAAM,CAAC,GAAGrR,IAAI,CAACqR,MAAM,GAAG,CAAC,KAAKrR,IAAI,CAACoR,QAAQ,GAAGsH,aAAa,GAAG,CAAC,CAAC;AAC3F;AACA,SAASO,iBAAiBA,CAACE,SAAS,EAAE9S,UAAU,EAAEvF,UAAU,EAAEqF,UAAU,EAAEuS,aAAa,EAAE;EACrF,MAAM;IAAEtb,CAAC,EAAEmJ,OAAO;IAAElJ,CAAC,EAAEmJ;EAAQ,CAAC,GAAGH,UAAU,CAACjC,SAAS,CAACqC,gBAAgB;EACxE,MAAM8B,eAAe,GAAGtH,iBAAiB,CAACkY,SAAS,CAAC;EACpD,MAAMd,kBAAkB,GAAGxX,yBAAyB,CAACsY,SAAS,EAAErY,UAAU,CAAC;EAC3E,MAAMwX,eAAe,GAAGxR,kBAAkB,CAACqS,SAAS,CAACzS,MAAM,CAAC,GACtDK,aAAa,CAACsR,kBAAkB,EAAEc,SAAS,CAACzS,MAAM,EAAE6B,eAAe,CAAC,GACpE8P,kBAAkB;EACxB,IAAIe,gBAAgB,GAAGrS,aAAa,CAAC;IAAE3J,CAAC,EAAEmJ,OAAO,GAAG+R,eAAe,CAAClb,CAAC;IAAEC,CAAC,EAAEmJ,OAAO,GAAG8R,eAAe,CAACjb;EAAE,CAAC,EAAE8I,UAAU,EAAEoC,eAAe,CAAC;EACrI,IAAI4Q,SAAS,CAACzS,MAAM,KAAK,QAAQ,EAAE;IAC/B0S,gBAAgB,GAAG/Q,qBAAqB,CAAC+Q,gBAAgB,EAAE7Q,eAAe,EAAElC,UAAU,CAAC;EAC3F;EACA,MAAMgT,MAAM,GAAGP,UAAU,CAACK,SAAS,EAAET,aAAa,CAAC;EACnD,MAAMY,OAAO,GAAGjT,UAAU,CAACjC,SAAS,CAACqN,CAAC,IAAI,CAAC;EAC3C,OAAO;IACHrU,CAAC,EAAEgc,gBAAgB,CAAChc,CAAC;IACrBC,CAAC,EAAE+b,gBAAgB,CAAC/b,CAAC;IACrBoU,CAAC,EAAE6H,OAAO,IAAID,MAAM,GAAGC,OAAO,GAAG,CAAC,GAAGD;EACzC,CAAC;AACL;AACA,SAASE,kBAAkBA,CAACC,QAAQ,EAAE7X,UAAU,EAAEuW,YAAY,EAAEpX,UAAU,GAAG,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE;EACjF,MAAM2Y,OAAO,GAAG,EAAE;EAClB,MAAMC,gBAAgB,GAAG,IAAI7U,GAAG,CAAC,CAAC;EAClC;EACA,KAAK,MAAM8U,KAAK,IAAIH,QAAQ,EAAE;IAC1B,MAAMhR,MAAM,GAAG7G,UAAU,CAACU,GAAG,CAACsX,KAAK,CAACrT,QAAQ,CAAC;IAC7C,IAAI,CAACkC,MAAM,EAAE;MACT;IACJ;IACA,MAAMoR,UAAU,GAAGF,gBAAgB,CAACrX,GAAG,CAACsX,KAAK,CAACrT,QAAQ,CAAC,EAAEuT,YAAY,IAAI7V,UAAU,CAACwE,MAAM,CAAC;IAC3F,MAAMqR,YAAY,GAAGxQ,gBAAgB,CAACuQ,UAAU,EAAED,KAAK,CAAC5W,IAAI,CAAC;IAC7D2W,gBAAgB,CAACzU,GAAG,CAAC0U,KAAK,CAACrT,QAAQ,EAAE;MAAEuT,YAAY;MAAErR;IAAO,CAAC,CAAC;EAClE;EACA,IAAIkR,gBAAgB,CAAC3a,IAAI,GAAG,CAAC,EAAE;IAC3B2a,gBAAgB,CAACpa,OAAO,CAAC,CAAC;MAAEua,YAAY;MAAErR;IAAO,CAAC,EAAElC,QAAQ,KAAK;MAC7D;MACA,MAAMG,gBAAgB,GAAG+B,MAAM,CAACpE,SAAS,CAACqC,gBAAgB;MAC1D,MAAM2B,UAAU,GAAGnH,iBAAiB,CAACuH,MAAM,CAAC;MAC5C,MAAMtH,MAAM,GAAGsH,MAAM,CAACtH,MAAM,IAAIJ,UAAU;MAC1C;MACA,MAAMgZ,OAAO,GAAGD,YAAY,CAACzc,CAAC,GAAGqJ,gBAAgB,CAACrJ,CAAC,GAAG+K,IAAI,CAACmC,KAAK,CAACnC,IAAI,CAACQ,GAAG,CAAClC,gBAAgB,CAACrJ,CAAC,GAAGyc,YAAY,CAACzc,CAAC,CAAC,CAAC,GAAG,CAAC;MACnH,MAAM2c,OAAO,GAAGF,YAAY,CAACxc,CAAC,GAAGoJ,gBAAgB,CAACpJ,CAAC,GAAG8K,IAAI,CAACmC,KAAK,CAACnC,IAAI,CAACQ,GAAG,CAAClC,gBAAgB,CAACpJ,CAAC,GAAGwc,YAAY,CAACxc,CAAC,CAAC,CAAC,GAAG,CAAC;MACnH,MAAM2c,QAAQ,GAAG7R,IAAI,CAACD,GAAG,CAACE,UAAU,CAACrH,KAAK,EAAEoH,IAAI,CAACmC,KAAK,CAACuP,YAAY,CAAC9Y,KAAK,CAAC,CAAC;MAC3E,MAAMkZ,SAAS,GAAG9R,IAAI,CAACD,GAAG,CAACE,UAAU,CAACpH,MAAM,EAAEmH,IAAI,CAACmC,KAAK,CAACuP,YAAY,CAAC7Y,MAAM,CAAC,CAAC;MAC9E,MAAMkZ,WAAW,GAAG,CAACF,QAAQ,GAAG5R,UAAU,CAACrH,KAAK,IAAIG,MAAM,CAAC,CAAC,CAAC;MAC7D,MAAMiZ,YAAY,GAAG,CAACF,SAAS,GAAG7R,UAAU,CAACpH,MAAM,IAAIE,MAAM,CAAC,CAAC,CAAC;MAChE;MACA,IAAI4Y,OAAO,GAAG,CAAC,IAAIC,OAAO,GAAG,CAAC,IAAIG,WAAW,IAAIC,YAAY,EAAE;QAC3DV,OAAO,CAACja,IAAI,CAAC;UACT3D,EAAE,EAAEyK,QAAQ;UACZvK,IAAI,EAAE,UAAU;UAChBsF,QAAQ,EAAE;YACNjE,CAAC,EAAEoL,MAAM,CAACnH,QAAQ,CAACjE,CAAC,GAAG0c,OAAO,GAAGI,WAAW;YAC5C7c,CAAC,EAAEmL,MAAM,CAACnH,QAAQ,CAAChE,CAAC,GAAG0c,OAAO,GAAGI;UACrC;QACJ,CAAC,CAAC;QACF;AAChB;AACA;AACA;QACgBjC,YAAY,CAAC7V,GAAG,CAACiE,QAAQ,CAAC,EAAEhH,OAAO,CAAE6Z,SAAS,IAAK;UAC/C,IAAI,CAACK,QAAQ,CAACzH,IAAI,CAAE4H,KAAK,IAAKA,KAAK,CAAC9d,EAAE,KAAKsd,SAAS,CAACtd,EAAE,CAAC,EAAE;YACtD4d,OAAO,CAACja,IAAI,CAAC;cACT3D,EAAE,EAAEsd,SAAS,CAACtd,EAAE;cAChBE,IAAI,EAAE,UAAU;cAChBsF,QAAQ,EAAE;gBACNjE,CAAC,EAAE+b,SAAS,CAAC9X,QAAQ,CAACjE,CAAC,GAAG0c,OAAO;gBACjCzc,CAAC,EAAE8b,SAAS,CAAC9X,QAAQ,CAAChE,CAAC,GAAG0c;cAC9B;YACJ,CAAC,CAAC;UACN;QACJ,CAAC,CAAC;MACN;MACA;MACA,IAAI3R,UAAU,CAACrH,KAAK,GAAG8Y,YAAY,CAAC9Y,KAAK,IAAIqH,UAAU,CAACpH,MAAM,GAAG6Y,YAAY,CAAC7Y,MAAM,IAAI8Y,OAAO,IAAIC,OAAO,EAAE;QACxGN,OAAO,CAACja,IAAI,CAAC;UACT3D,EAAE,EAAEyK,QAAQ;UACZvK,IAAI,EAAE,YAAY;UAClBqe,aAAa,EAAE,IAAI;UACnBhS,UAAU,EAAE;YACRrH,KAAK,EAAEiZ,QAAQ,IAAIF,OAAO,GAAG5Y,MAAM,CAAC,CAAC,CAAC,GAAG4Y,OAAO,GAAGI,WAAW,GAAG,CAAC,CAAC;YACnElZ,MAAM,EAAEiZ,SAAS,IAAIF,OAAO,GAAG7Y,MAAM,CAAC,CAAC,CAAC,GAAG6Y,OAAO,GAAGI,YAAY,GAAG,CAAC;UACzE;QACJ,CAAC,CAAC;MACN;IACJ,CAAC,CAAC;EACN;EACA,OAAOV,OAAO;AAClB;AACA,SAASY,mBAAmBA,CAACC,OAAO,EAAE3Y,UAAU,EAAEuW,YAAY,EAAEqC,OAAO,EAAEzZ,UAAU,EAAEqF,UAAU,EAAE;EAC7F,MAAMqU,YAAY,GAAGD,OAAO,EAAEE,aAAa,CAAC,mBAAmB,CAAC;EAChE,IAAIC,gBAAgB,GAAG,KAAK;EAC5B,IAAI,CAACF,YAAY,EAAE;IACf,OAAO;MAAEf,OAAO,EAAE,EAAE;MAAEiB;IAAiB,CAAC;EAC5C;EACA,MAAMjB,OAAO,GAAG,EAAE;EAClB,MAAMkB,KAAK,GAAG9M,MAAM,CAAC+M,gBAAgB,CAACJ,YAAY,CAAC;EACnD,MAAM;IAAEK,GAAG,EAAE9f;EAAK,CAAC,GAAG,IAAI8S,MAAM,CAACiN,iBAAiB,CAACH,KAAK,CAACzN,SAAS,CAAC;EACnE;EACA,MAAM6N,oBAAoB,GAAG,EAAE;EAC/B,KAAK,MAAMC,MAAM,IAAIV,OAAO,CAAC9W,MAAM,CAAC,CAAC,EAAE;IACnC,MAAMxD,IAAI,GAAG2B,UAAU,CAACU,GAAG,CAAC2Y,MAAM,CAACnf,EAAE,CAAC;IACtC,IAAI,CAACmE,IAAI,EAAE;MACP;IACJ;IACA,IAAIA,IAAI,CAAC2D,MAAM,EAAE;MACbhC,UAAU,CAACsD,GAAG,CAACjF,IAAI,CAACnE,EAAE,EAAE;QACpB,GAAGmE,IAAI;QACPoE,SAAS,EAAE;UACP,GAAGpE,IAAI,CAACoE,SAAS;UACjBC,YAAY,EAAEjC;QAClB;MACJ,CAAC,CAAC;MACFsY,gBAAgB,GAAG,IAAI;MACvB;IACJ;IACA,MAAMtS,UAAU,GAAGoF,aAAa,CAACwN,MAAM,CAACjM,WAAW,CAAC;IACpD,MAAMkM,gBAAgB,GAAGjb,IAAI,CAACyD,QAAQ,CAAC1C,KAAK,KAAKqH,UAAU,CAACrH,KAAK,IAAIf,IAAI,CAACyD,QAAQ,CAACzC,MAAM,KAAKoH,UAAU,CAACpH,MAAM;IAC/G,MAAMka,QAAQ,GAAG,CAAC,EAAE9S,UAAU,CAACrH,KAAK,IAChCqH,UAAU,CAACpH,MAAM,KAChBia,gBAAgB,IAAI,CAACjb,IAAI,CAACoE,SAAS,CAACC,YAAY,IAAI2W,MAAM,CAACG,KAAK,CAAC,CAAC;IACvE,IAAID,QAAQ,EAAE;MACV,MAAMlM,UAAU,GAAGgM,MAAM,CAACjM,WAAW,CAACM,qBAAqB,CAAC,CAAC;MAC7D,MAAM3I,MAAM,GAAGI,kBAAkB,CAAC9G,IAAI,CAAC0G,MAAM,CAAC,GAAG1G,IAAI,CAAC0G,MAAM,GAAGP,UAAU;MACzE,IAAI;QAAEM;MAAiB,CAAC,GAAGzG,IAAI,CAACoE,SAAS;MACzC,IAAIpE,IAAI,CAACsG,QAAQ,IAAItG,IAAI,CAAC0G,MAAM,KAAK,QAAQ,EAAE;QAC3CD,gBAAgB,GAAG4B,qBAAqB,CAAC5B,gBAAgB,EAAE2B,UAAU,EAAEzG,UAAU,CAACU,GAAG,CAACrC,IAAI,CAACsG,QAAQ,CAAC,CAAC;MACzG,CAAC,MACI,IAAII,MAAM,EAAE;QACbD,gBAAgB,GAAGM,aAAa,CAACN,gBAAgB,EAAEC,MAAM,EAAE0B,UAAU,CAAC;MAC1E;MACA,MAAMgT,OAAO,GAAG;QACZ,GAAGpb,IAAI;QACPyD,QAAQ,EAAE2E,UAAU;QACpBhE,SAAS,EAAE;UACP,GAAGpE,IAAI,CAACoE,SAAS;UACjBqC,gBAAgB;UAChBpC,YAAY,EAAE;YACV/D,MAAM,EAAEwO,eAAe,CAAC,QAAQ,EAAEkM,MAAM,CAACjM,WAAW,EAAEC,UAAU,EAAEjU,IAAI,EAAEiF,IAAI,CAACnE,EAAE,CAAC;YAChF2E,MAAM,EAAEsO,eAAe,CAAC,QAAQ,EAAEkM,MAAM,CAACjM,WAAW,EAAEC,UAAU,EAAEjU,IAAI,EAAEiF,IAAI,CAACnE,EAAE;UACnF;QACJ;MACJ,CAAC;MACD8F,UAAU,CAACsD,GAAG,CAACjF,IAAI,CAACnE,EAAE,EAAEuf,OAAO,CAAC;MAChC,IAAIpb,IAAI,CAACsG,QAAQ,EAAE;QACf8R,eAAe,CAACgD,OAAO,EAAEzZ,UAAU,EAAEuW,YAAY,EAAE;UAAEpX;QAAW,CAAC,CAAC;MACtE;MACA4Z,gBAAgB,GAAG,IAAI;MACvB,IAAIO,gBAAgB,EAAE;QAClBxB,OAAO,CAACja,IAAI,CAAC;UACT3D,EAAE,EAAEmE,IAAI,CAACnE,EAAE;UACXE,IAAI,EAAE,YAAY;UAClBqM;QACJ,CAAC,CAAC;QACF,IAAIpI,IAAI,CAAC2G,YAAY,IAAI3G,IAAI,CAACsG,QAAQ,EAAE;UACpCyU,oBAAoB,CAACvb,IAAI,CAAC;YACtB3D,EAAE,EAAEmE,IAAI,CAACnE,EAAE;YACXyK,QAAQ,EAAEtG,IAAI,CAACsG,QAAQ;YACvBvD,IAAI,EAAEiB,UAAU,CAACoX,OAAO,EAAEta,UAAU;UACxC,CAAC,CAAC;QACN;MACJ;IACJ;EACJ;EACA,IAAIia,oBAAoB,CAACtb,MAAM,GAAG,CAAC,EAAE;IACjC,MAAM4b,mBAAmB,GAAG9B,kBAAkB,CAACwB,oBAAoB,EAAEpZ,UAAU,EAAEuW,YAAY,EAAEpX,UAAU,CAAC;IAC1G2Y,OAAO,CAACja,IAAI,CAAC,GAAG6b,mBAAmB,CAAC;EACxC;EACA,OAAO;IAAE5B,OAAO;IAAEiB;EAAiB,CAAC;AACxC;AACA,eAAeY,KAAKA,CAAC;EAAEC,KAAK;EAAEpW,OAAO;EAAE+H,SAAS;EAAEsO,eAAe;EAAEza,KAAK;EAAEC;AAAQ,CAAC,EAAE;EACjF,IAAI,CAACmE,OAAO,IAAK,CAACoW,KAAK,CAACne,CAAC,IAAI,CAACme,KAAK,CAACle,CAAE,EAAE;IACpC,OAAOiI,OAAO,CAACC,OAAO,CAAC,KAAK,CAAC;EACjC;EACA,MAAMkW,YAAY,GAAG,MAAMtW,OAAO,CAACuW,sBAAsB,CAAC;IACtDte,CAAC,EAAE8P,SAAS,CAAC,CAAC,CAAC,GAAGqO,KAAK,CAACne,CAAC;IACzBC,CAAC,EAAE6P,SAAS,CAAC,CAAC,CAAC,GAAGqO,KAAK,CAACle,CAAC;IACzBtC,IAAI,EAAEmS,SAAS,CAAC,CAAC;EACrB,CAAC,EAAE,CACC,CAAC,CAAC,EAAE,CAAC,CAAC,EACN,CAACnM,KAAK,EAAEC,MAAM,CAAC,CAClB,EAAEwa,eAAe,CAAC;EACnB,MAAMG,gBAAgB,GAAG,CAAC,CAACF,YAAY,KAClCA,YAAY,CAACre,CAAC,KAAK8P,SAAS,CAAC,CAAC,CAAC,IAAIuO,YAAY,CAACpe,CAAC,KAAK6P,SAAS,CAAC,CAAC,CAAC,IAAIuO,YAAY,CAACG,CAAC,KAAK1O,SAAS,CAAC,CAAC,CAAC,CAAC;EAC3G,OAAO5H,OAAO,CAACC,OAAO,CAACoW,gBAAgB,CAAC;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASE,qBAAqBA,CAAC9f,IAAI,EAAEwD,UAAU,EAAEuc,aAAa,EAAEC,gBAAgB,EAAE9V,MAAM,EAAE+P,QAAQ,EAAE;EAChG;AACJ;AACA;AACA;AACA;EACI,IAAIhX,GAAG,GAAGiH,MAAM;EAChB,MAAM+V,OAAO,GAAGD,gBAAgB,CAAC1Z,GAAG,CAACrD,GAAG,CAAC,IAAI,IAAI6F,GAAG,CAAC,CAAC;EACtDkX,gBAAgB,CAAC9W,GAAG,CAACjG,GAAG,EAAEgd,OAAO,CAAC/W,GAAG,CAAC6W,aAAa,EAAEvc,UAAU,CAAC,CAAC;EACjEP,GAAG,GAAG,GAAGiH,MAAM,IAAIlK,IAAI,EAAE;EACzB,MAAMkgB,OAAO,GAAGF,gBAAgB,CAAC1Z,GAAG,CAACrD,GAAG,CAAC,IAAI,IAAI6F,GAAG,CAAC,CAAC;EACtDkX,gBAAgB,CAAC9W,GAAG,CAACjG,GAAG,EAAEid,OAAO,CAAChX,GAAG,CAAC6W,aAAa,EAAEvc,UAAU,CAAC,CAAC;EACjE,IAAIyW,QAAQ,EAAE;IACVhX,GAAG,GAAG,GAAGiH,MAAM,IAAIlK,IAAI,IAAIia,QAAQ,EAAE;IACrC,MAAMkG,SAAS,GAAGH,gBAAgB,CAAC1Z,GAAG,CAACrD,GAAG,CAAC,IAAI,IAAI6F,GAAG,CAAC,CAAC;IACxDkX,gBAAgB,CAAC9W,GAAG,CAACjG,GAAG,EAAEkd,SAAS,CAACjX,GAAG,CAAC6W,aAAa,EAAEvc,UAAU,CAAC,CAAC;EACvE;AACJ;AACA,SAAS4c,sBAAsBA,CAACJ,gBAAgB,EAAEK,UAAU,EAAElc,KAAK,EAAE;EACjE6b,gBAAgB,CAACpD,KAAK,CAAC,CAAC;EACxByD,UAAU,CAACzD,KAAK,CAAC,CAAC;EAClB,KAAK,MAAMtY,IAAI,IAAIH,KAAK,EAAE;IACtB,MAAM;MAAEI,MAAM,EAAE4Q,UAAU;MAAE1Q,MAAM,EAAE2Q,UAAU;MAAEjV,YAAY,GAAG,IAAI;MAAEC,YAAY,GAAG;IAAK,CAAC,GAAGkE,IAAI;IACjG,MAAMd,UAAU,GAAG;MAAE8c,MAAM,EAAEhc,IAAI,CAACxE,EAAE;MAAEyE,MAAM,EAAE4Q,UAAU;MAAE1Q,MAAM,EAAE2Q,UAAU;MAAEjV,YAAY;MAAEC;IAAa,CAAC;IAC1G,MAAMmgB,SAAS,GAAG,GAAGpL,UAAU,IAAIhV,YAAY,KAAKiV,UAAU,IAAIhV,YAAY,EAAE;IAChF,MAAMogB,SAAS,GAAG,GAAGpL,UAAU,IAAIhV,YAAY,KAAK+U,UAAU,IAAIhV,YAAY,EAAE;IAChF2f,qBAAqB,CAAC,QAAQ,EAAEtc,UAAU,EAAEgd,SAAS,EAAER,gBAAgB,EAAE7K,UAAU,EAAEhV,YAAY,CAAC;IAClG2f,qBAAqB,CAAC,QAAQ,EAAEtc,UAAU,EAAE+c,SAAS,EAAEP,gBAAgB,EAAE5K,UAAU,EAAEhV,YAAY,CAAC;IAClGigB,UAAU,CAACnX,GAAG,CAAC5E,IAAI,CAACxE,EAAE,EAAEwE,IAAI,CAAC;EACjC;AACJ;AAEA,SAASmc,eAAeA,CAAC3d,CAAC,EAAEC,CAAC,EAAE;EAC3B,IAAID,CAAC,KAAK,IAAI,IAAIC,CAAC,KAAK,IAAI,EAAE;IAC1B,OAAO,KAAK;EAChB;EACA,MAAM2d,EAAE,GAAGtN,KAAK,CAACuN,OAAO,CAAC7d,CAAC,CAAC,GAAGA,CAAC,GAAG,CAACA,CAAC,CAAC;EACrC,MAAM8d,EAAE,GAAGxN,KAAK,CAACuN,OAAO,CAAC5d,CAAC,CAAC,GAAGA,CAAC,GAAG,CAACA,CAAC,CAAC;EACrC,IAAI2d,EAAE,CAAChd,MAAM,KAAKkd,EAAE,CAACld,MAAM,EAAE;IACzB,OAAO,KAAK;EAChB;EACA,KAAK,IAAI2V,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGqH,EAAE,CAAChd,MAAM,EAAE2V,CAAC,EAAE,EAAE;IAChC,IAAIqH,EAAE,CAACrH,CAAC,CAAC,CAACvZ,EAAE,KAAK8gB,EAAE,CAACvH,CAAC,CAAC,CAACvZ,EAAE,IAAI4gB,EAAE,CAACrH,CAAC,CAAC,CAACrZ,IAAI,KAAK4gB,EAAE,CAACvH,CAAC,CAAC,CAACrZ,IAAI,IAAI,CAACsa,MAAM,CAACuG,EAAE,CAACH,EAAE,CAACrH,CAAC,CAAC,CAACyH,IAAI,EAAEF,EAAE,CAACvH,CAAC,CAAC,CAACyH,IAAI,CAAC,EAAE;MAC1F,OAAO,KAAK;IAChB;EACJ;EACA,OAAO,IAAI;AACf;AAEA,SAASC,gBAAgBA,CAAC9c,IAAI,EAAE2B,UAAU,EAAE;EACxC,IAAI,CAAC3B,IAAI,CAACsG,QAAQ,EAAE;IAChB,OAAO,KAAK;EAChB;EACA,MAAMD,UAAU,GAAG1E,UAAU,CAACU,GAAG,CAACrC,IAAI,CAACsG,QAAQ,CAAC;EAChD,IAAI,CAACD,UAAU,EAAE;IACb,OAAO,KAAK;EAChB;EACA,IAAIA,UAAU,CAAC+K,QAAQ,EAAE;IACrB,OAAO,IAAI;EACf;EACA,OAAO0L,gBAAgB,CAACzW,UAAU,EAAE1E,UAAU,CAAC;AACnD;AACA,SAASob,WAAWA,CAACvc,MAAM,EAAEwc,QAAQ,EAAEzC,OAAO,EAAE;EAC5C,IAAI0C,OAAO,GAAGzc,MAAM;EACpB,GAAG;IACC,IAAIyc,OAAO,EAAEC,OAAO,GAAGF,QAAQ,CAAC,EAC5B,OAAO,IAAI;IACf,IAAIC,OAAO,KAAK1C,OAAO,EACnB,OAAO,KAAK;IAChB0C,OAAO,GAAGA,OAAO,EAAEE,aAAa;EACpC,CAAC,QAAQF,OAAO;EAChB,OAAO,KAAK;AAChB;AACA;AACA,SAASG,YAAYA,CAACzb,UAAU,EAAE0b,cAAc,EAAEC,QAAQ,EAAErX,MAAM,EAAE;EAChE,MAAMsX,SAAS,GAAG,IAAI1Y,GAAG,CAAC,CAAC;EAC3B,KAAK,MAAM,CAAChJ,EAAE,EAAEmE,IAAI,CAAC,IAAI2B,UAAU,EAAE;IACjC,IAAI,CAAC3B,IAAI,CAACoR,QAAQ,IAAIpR,IAAI,CAACnE,EAAE,KAAKoK,MAAM,MACnC,CAACjG,IAAI,CAACsG,QAAQ,IAAI,CAACwW,gBAAgB,CAAC9c,IAAI,EAAE2B,UAAU,CAAC,CAAC,KACtD3B,IAAI,CAACwd,SAAS,IAAKH,cAAc,IAAI,OAAOrd,IAAI,CAACwd,SAAS,KAAK,WAAY,CAAC,EAAE;MAC/E,MAAM3E,YAAY,GAAGlX,UAAU,CAACU,GAAG,CAACxG,EAAE,CAAC;MACvC,IAAIgd,YAAY,EAAE;QACd0E,SAAS,CAACtY,GAAG,CAACpJ,EAAE,EAAE;UACdA,EAAE;UACFwF,QAAQ,EAAEwX,YAAY,CAACxX,QAAQ,IAAI;YAAEjE,CAAC,EAAE,CAAC;YAAEC,CAAC,EAAE;UAAE,CAAC;UACjD0L,QAAQ,EAAE;YACN3L,CAAC,EAAEkgB,QAAQ,CAAClgB,CAAC,GAAGyb,YAAY,CAACzU,SAAS,CAACqC,gBAAgB,CAACrJ,CAAC;YACzDC,CAAC,EAAEigB,QAAQ,CAACjgB,CAAC,GAAGwb,YAAY,CAACzU,SAAS,CAACqC,gBAAgB,CAACpJ;UAC5D,CAAC;UACDqJ,MAAM,EAAEmS,YAAY,CAACnS,MAAM;UAC3BJ,QAAQ,EAAEuS,YAAY,CAACvS,QAAQ;UAC/BpF,MAAM,EAAE2X,YAAY,CAAC3X,MAAM;UAC3ByF,YAAY,EAAEkS,YAAY,CAAClS,YAAY;UACvCvC,SAAS,EAAE;YACPqC,gBAAgB,EAAEoS,YAAY,CAACzU,SAAS,CAACqC,gBAAgB,IAAI;cAAErJ,CAAC,EAAE,CAAC;cAAEC,CAAC,EAAE;YAAE;UAC9E,CAAC;UACDoG,QAAQ,EAAE;YACN1C,KAAK,EAAE8X,YAAY,CAACpV,QAAQ,CAAC1C,KAAK,IAAI,CAAC;YACvCC,MAAM,EAAE6X,YAAY,CAACpV,QAAQ,CAACzC,MAAM,IAAI;UAC5C;QACJ,CAAC,CAAC;MACN;IACJ;EACJ;EACA,OAAOuc,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,SAASE,qBAAqBA,CAAC;EAAExX,MAAM;EAAEsX,SAAS;EAAE5b,UAAU;EAAE4C,QAAQ,GAAG;AAAM,CAAC,EAAE;EAChF,MAAMmZ,kBAAkB,GAAG,EAAE;EAC7B,KAAK,MAAM,CAAC7hB,EAAE,EAAE8hB,QAAQ,CAAC,IAAIJ,SAAS,EAAE;IACpC,MAAMvd,IAAI,GAAG2B,UAAU,CAACU,GAAG,CAACxG,EAAE,CAAC,EAAEuI,SAAS,CAACwU,QAAQ;IACnD,IAAI5Y,IAAI,EAAE;MACN0d,kBAAkB,CAACle,IAAI,CAAC;QACpB,GAAGQ,IAAI;QACPqB,QAAQ,EAAEsc,QAAQ,CAACtc,QAAQ;QAC3BkD;MACJ,CAAC,CAAC;IACN;EACJ;EACA,IAAI,CAAC0B,MAAM,EAAE;IACT,OAAO,CAACyX,kBAAkB,CAAC,CAAC,CAAC,EAAEA,kBAAkB,CAAC;EACtD;EACA,MAAM1d,IAAI,GAAG2B,UAAU,CAACU,GAAG,CAAC4D,MAAM,CAAC,EAAE7B,SAAS,CAACwU,QAAQ;EACvD,OAAO,CACH,CAAC5Y,IAAI,GACC0d,kBAAkB,CAAC,CAAC,CAAC,GACrB;IACE,GAAG1d,IAAI;IACPqB,QAAQ,EAAEkc,SAAS,CAAClb,GAAG,CAAC4D,MAAM,CAAC,EAAE5E,QAAQ,IAAIrB,IAAI,CAACqB,QAAQ;IAC1DkD;EACJ,CAAC,EACLmZ,kBAAkB,CACrB;AACL;AACA;AACA;AACA;AACA;AACA,SAASE,mBAAmBA,CAAC;EAAEL,SAAS;EAAElT,QAAQ;EAAEjN,CAAC;EAAEC;AAAG,CAAC,EAAE;EACzD,MAAMwgB,WAAW,GAAGN,SAAS,CAAC/Z,MAAM,CAAC,CAAC,CAACsa,IAAI,CAAC,CAAC,CAACpV,KAAK;EACnD,IAAI,CAACmV,WAAW,EAAE;IACd,OAAO,IAAI;EACf;EACA,MAAME,MAAM,GAAG;IACX3gB,CAAC,EAAEA,CAAC,GAAGygB,WAAW,CAAC9U,QAAQ,CAAC3L,CAAC;IAC7BC,CAAC,EAAEA,CAAC,GAAGwgB,WAAW,CAAC9U,QAAQ,CAAC1L;EAChC,CAAC;EACD,MAAM2gB,aAAa,GAAG5T,YAAY,CAAC2T,MAAM,EAAE1T,QAAQ,CAAC;EACpD,OAAO;IACHjN,CAAC,EAAE4gB,aAAa,CAAC5gB,CAAC,GAAG2gB,MAAM,CAAC3gB,CAAC;IAC7BC,CAAC,EAAE2gB,aAAa,CAAC3gB,CAAC,GAAG0gB,MAAM,CAAC1gB;EAChC,CAAC;AACL;;AAEA;AACA,SAAS4gB,MAAMA,CAAC;EAAEC,eAAe;EAAEC,aAAa;EAAEC,WAAW;EAAEC,MAAM;EAAEC;AAAY,CAAC,EAAE;EAClF,IAAIC,OAAO,GAAG;IAAEnhB,CAAC,EAAE,IAAI;IAAEC,CAAC,EAAE;EAAK,CAAC;EAClC,IAAImhB,SAAS,GAAG,CAAC;EACjB,IAAIjB,SAAS,GAAG,IAAI1Y,GAAG,CAAC,CAAC;EACzB,IAAI4Z,cAAc,GAAG,KAAK;EAC1B,IAAIC,aAAa,GAAG;IAAEthB,CAAC,EAAE,CAAC;IAAEC,CAAC,EAAE;EAAE,CAAC;EAClC,IAAI8P,eAAe,GAAG,IAAI;EAC1B,IAAIwR,WAAW,GAAG,KAAK;EACvB,IAAIC,WAAW,GAAG,IAAI;EACtB,IAAIC,SAAS,GAAG,KAAK,CAAC,CAAC;EACvB,IAAIC,oBAAoB,GAAG,KAAK;EAChC;EACA,IAAIC,SAAS,GAAG,IAAI;EACpB;EACA,SAAS/D,MAAMA,CAAC;IAAEgE,eAAe;IAAEC,cAAc;IAAE1E,OAAO;IAAE2E,YAAY;IAAEjZ,MAAM;IAAEkZ,iBAAiB,GAAG;EAAG,CAAC,EAAE;IACxGP,WAAW,GAAG/jB,MAAM,CAAC0f,OAAO,CAAC;IAC7B,SAAS6E,WAAWA,CAAC;MAAEhiB,CAAC;MAAEC;IAAE,CAAC,EAAE;MAC3B,MAAM;QAAEsE,UAAU;QAAEwE,UAAU;QAAEkE,QAAQ;QAAEE,UAAU;QAAEzJ,UAAU;QAAEue,UAAU;QAAEC,eAAe;QAAElZ,OAAO;QAAEmZ;MAAqB,CAAC,GAAGpB,aAAa,CAAC,CAAC;MAChJI,OAAO,GAAG;QAAEnhB,CAAC;QAAEC;MAAE,CAAC;MAClB,IAAImiB,SAAS,GAAG,KAAK;MACrB,MAAMC,WAAW,GAAGlC,SAAS,CAACxe,IAAI,GAAG,CAAC;MACtC,MAAM2gB,QAAQ,GAAGD,WAAW,IAAItZ,UAAU,GAAGiD,SAAS,CAACvG,sBAAsB,CAAC0a,SAAS,CAAC,CAAC,GAAG,IAAI;MAChG,MAAMoC,mBAAmB,GAAGF,WAAW,IAAIlV,UAAU,GAC/CqT,mBAAmB,CAAC;QAClBL,SAAS;QACTlT,QAAQ;QACRjN,CAAC;QACDC;MACJ,CAAC,CAAC,GACA,IAAI;MACV,KAAK,MAAM,CAACxB,EAAE,EAAE8hB,QAAQ,CAAC,IAAIJ,SAAS,EAAE;QACpC;AAChB;AACA;QACgB,IAAI,CAAC5b,UAAU,CAACzC,GAAG,CAACrD,EAAE,CAAC,EAAE;UACrB;QACJ;QACA,IAAIqK,YAAY,GAAG;UAAE9I,CAAC,EAAEA,CAAC,GAAGugB,QAAQ,CAAC5U,QAAQ,CAAC3L,CAAC;UAAEC,CAAC,EAAEA,CAAC,GAAGsgB,QAAQ,CAAC5U,QAAQ,CAAC1L;QAAE,CAAC;QAC7E,IAAIkN,UAAU,EAAE;UACZrE,YAAY,GAAGyZ,mBAAmB,GAC5B;YACEviB,CAAC,EAAE+K,IAAI,CAACmC,KAAK,CAACpE,YAAY,CAAC9I,CAAC,GAAGuiB,mBAAmB,CAACviB,CAAC,CAAC;YACrDC,CAAC,EAAE8K,IAAI,CAACmC,KAAK,CAACpE,YAAY,CAAC7I,CAAC,GAAGsiB,mBAAmB,CAACtiB,CAAC;UACxD,CAAC,GACC+M,YAAY,CAAClE,YAAY,EAAEmE,QAAQ,CAAC;QAC9C;QACA,IAAIuV,kBAAkB,GAAG,IAAI;QAC7B,IAAIH,WAAW,IAAItZ,UAAU,IAAI,CAACwX,QAAQ,CAACjX,MAAM,IAAIgZ,QAAQ,EAAE;UAC3D,MAAM;YAAEjZ;UAAiB,CAAC,GAAGkX,QAAQ,CAACvZ,SAAS;UAC/C,MAAMkM,EAAE,GAAG7J,gBAAgB,CAACrJ,CAAC,GAAGsiB,QAAQ,CAACtiB,CAAC,GAAG+I,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;UAC7D,MAAM3D,EAAE,GAAGiE,gBAAgB,CAACrJ,CAAC,GAAGugB,QAAQ,CAACla,QAAQ,CAAC1C,KAAK,GAAG2e,QAAQ,CAACld,EAAE,GAAG2D,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;UACxF,MAAMoK,EAAE,GAAG9J,gBAAgB,CAACpJ,CAAC,GAAGqiB,QAAQ,CAACriB,CAAC,GAAG8I,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;UAC7D,MAAM1D,EAAE,GAAGgE,gBAAgB,CAACpJ,CAAC,GAAGsgB,QAAQ,CAACla,QAAQ,CAACzC,MAAM,GAAG0e,QAAQ,CAACjd,EAAE,GAAG0D,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;UACzFyZ,kBAAkB,GAAG,CACjB,CAACtP,EAAE,EAAEC,EAAE,CAAC,EACR,CAAC/N,EAAE,EAAEC,EAAE,CAAC,CACX;QACL;QACA,MAAM;UAAEpB,QAAQ;UAAEoF;QAAiB,CAAC,GAAGT,qBAAqB,CAAC;UACzDC,MAAM,EAAEpK,EAAE;UACVqK,YAAY;UACZvE,UAAU;UACVwE,UAAU,EAAEyZ,kBAAkB,GAAGA,kBAAkB,GAAGzZ,UAAU;UAChErF,UAAU;UACVsF;QACJ,CAAC,CAAC;QACF;QACAoZ,SAAS,GAAGA,SAAS,IAAI7B,QAAQ,CAACtc,QAAQ,CAACjE,CAAC,KAAKiE,QAAQ,CAACjE,CAAC,IAAIugB,QAAQ,CAACtc,QAAQ,CAAChE,CAAC,KAAKgE,QAAQ,CAAChE,CAAC;QACjGsgB,QAAQ,CAACtc,QAAQ,GAAGA,QAAQ;QAC5Bsc,QAAQ,CAACvZ,SAAS,CAACqC,gBAAgB,GAAGA,gBAAgB;MAC1D;MACAqY,oBAAoB,GAAGA,oBAAoB,IAAIU,SAAS;MACxD,IAAI,CAACA,SAAS,EAAE;QACZ;MACJ;MACAD,mBAAmB,CAAChC,SAAS,EAAE,IAAI,CAAC;MACpC,IAAIwB,SAAS,KAAKV,MAAM,IAAIgB,UAAU,IAAK,CAACpZ,MAAM,IAAIqZ,eAAgB,CAAC,EAAE;QACrE,MAAM,CAACnd,WAAW,EAAE0d,YAAY,CAAC,GAAGpC,qBAAqB,CAAC;UACtDxX,MAAM;UACNsX,SAAS;UACT5b;QACJ,CAAC,CAAC;QACF0c,MAAM,GAAGU,SAAS,EAAExB,SAAS,EAAEpb,WAAW,EAAE0d,YAAY,CAAC;QACzDR,UAAU,GAAGN,SAAS,EAAE5c,WAAW,EAAE0d,YAAY,CAAC;QAClD,IAAI,CAAC5Z,MAAM,EAAE;UACTqZ,eAAe,GAAGP,SAAS,EAAEc,YAAY,CAAC;QAC9C;MACJ;IACJ;IACA,eAAeC,OAAOA,CAAA,EAAG;MACrB,IAAI,CAAC3S,eAAe,EAAE;QAClB;MACJ;MACA,MAAM;QAAED,SAAS;QAAEoO,KAAK;QAAEyE,YAAY;QAAEC;MAAkB,CAAC,GAAG7B,aAAa,CAAC,CAAC;MAC7E,IAAI,CAAC6B,iBAAiB,EAAE;QACpBvB,cAAc,GAAG,KAAK;QACtBwB,oBAAoB,CAACzB,SAAS,CAAC;QAC/B;MACJ;MACA,MAAM,CAACxV,SAAS,EAAEC,SAAS,CAAC,GAAGL,WAAW,CAAC8V,aAAa,EAAEvR,eAAe,EAAE4S,YAAY,CAAC;MACxF,IAAI/W,SAAS,KAAK,CAAC,IAAIC,SAAS,KAAK,CAAC,EAAE;QACpCsV,OAAO,CAACnhB,CAAC,GAAG,CAACmhB,OAAO,CAACnhB,CAAC,IAAI,CAAC,IAAI4L,SAAS,GAAGkE,SAAS,CAAC,CAAC,CAAC;QACvDqR,OAAO,CAAClhB,CAAC,GAAG,CAACkhB,OAAO,CAAClhB,CAAC,IAAI,CAAC,IAAI4L,SAAS,GAAGiE,SAAS,CAAC,CAAC,CAAC;QACvD,IAAI,MAAMoO,KAAK,CAAC;UAAEle,CAAC,EAAE4L,SAAS;UAAE3L,CAAC,EAAE4L;QAAU,CAAC,CAAC,EAAE;UAC7CmW,WAAW,CAACb,OAAO,CAAC;QACxB;MACJ;MACAC,SAAS,GAAG0B,qBAAqB,CAACJ,OAAO,CAAC;IAC9C;IACA,SAASK,SAASA,CAAClT,KAAK,EAAE;MACtB,MAAM;QAAEtL,UAAU;QAAEye,oBAAoB;QAAE/C,cAAc;QAAEnQ,SAAS;QAAE7C,QAAQ;QAAEE,UAAU;QAAE8V,iBAAiB;QAAEC,eAAe;QAAEC,oBAAoB;QAAEC;MAAuB,CAAC,GAAGrC,aAAa,CAAC,CAAC;MAC/LQ,WAAW,GAAG,IAAI;MAClB,IAAI,CAAC,CAAC0B,iBAAiB,IAAI,CAACnB,YAAY,KAAK,CAACkB,oBAAoB,IAAIna,MAAM,EAAE;QAC1E,IAAI,CAACtE,UAAU,CAACU,GAAG,CAAC4D,MAAM,CAAC,EAAEmL,QAAQ,EAAE;UACnC;UACAoP,qBAAqB,CAAC,CAAC;QAC3B;MACJ;MACA,IAAItB,YAAY,IAAImB,iBAAiB,IAAIpa,MAAM,EAAE;QAC7CiY,eAAe,GAAGjY,MAAM,CAAC;MAC7B;MACA,MAAMoH,UAAU,GAAGL,kBAAkB,CAACC,KAAK,CAACwT,WAAW,EAAE;QAAEvT,SAAS;QAAE7C,QAAQ;QAAEE,UAAU;QAAE4C;MAAgB,CAAC,CAAC;MAC9GoR,OAAO,GAAGlR,UAAU;MACpBkQ,SAAS,GAAGH,YAAY,CAACzb,UAAU,EAAE0b,cAAc,EAAEhQ,UAAU,EAAEpH,MAAM,CAAC;MACxE,IAAIsX,SAAS,CAACxe,IAAI,GAAG,CAAC,KAAKqf,WAAW,IAAIkC,eAAe,IAAK,CAACra,MAAM,IAAIsa,oBAAqB,CAAC,EAAE;QAC7F,MAAM,CAACpe,WAAW,EAAE0d,YAAY,CAAC,GAAGpC,qBAAqB,CAAC;UACtDxX,MAAM;UACNsX,SAAS;UACT5b;QACJ,CAAC,CAAC;QACFyc,WAAW,GAAGnR,KAAK,CAACwT,WAAW,EAAElD,SAAS,EAAEpb,WAAW,EAAE0d,YAAY,CAAC;QACtES,eAAe,GAAGrT,KAAK,CAACwT,WAAW,EAAEte,WAAW,EAAE0d,YAAY,CAAC;QAC/D,IAAI,CAAC5Z,MAAM,EAAE;UACTsa,oBAAoB,GAAGtT,KAAK,CAACwT,WAAW,EAAEZ,YAAY,CAAC;QAC3D;MACJ;IACJ;IACA,MAAMa,cAAc,GAAG9lB,IAAI,CAAC,CAAC,CACxB+lB,aAAa,CAACxB,iBAAiB,CAAC,CAChCyB,EAAE,CAAC,OAAO,EAAG3T,KAAK,IAAK;MACxB,MAAM;QAAEsN,OAAO;QAAEsG,iBAAiB;QAAE3T,SAAS;QAAE7C,QAAQ;QAAEE;MAAW,CAAC,GAAG4T,aAAa,CAAC,CAAC;MACvFhR,eAAe,GAAGoN,OAAO,EAAElL,qBAAqB,CAAC,CAAC,IAAI,IAAI;MAC1DwP,SAAS,GAAG,KAAK;MACjBC,oBAAoB,GAAG,KAAK;MAC5BC,SAAS,GAAG9R,KAAK,CAACwT,WAAW;MAC7B,IAAII,iBAAiB,KAAK,CAAC,EAAE;QACzBV,SAAS,CAAClT,KAAK,CAAC;MACpB;MACA,MAAMI,UAAU,GAAGL,kBAAkB,CAACC,KAAK,CAACwT,WAAW,EAAE;QAAEvT,SAAS;QAAE7C,QAAQ;QAAEE,UAAU;QAAE4C;MAAgB,CAAC,CAAC;MAC9GoR,OAAO,GAAGlR,UAAU;MACpBqR,aAAa,GAAGtR,gBAAgB,CAACH,KAAK,CAACwT,WAAW,EAAEtT,eAAe,CAAC;IACxE,CAAC,CAAC,CACGyT,EAAE,CAAC,MAAM,EAAG3T,KAAK,IAAK;MACvB,MAAM;QAAE+S,iBAAiB;QAAE9S,SAAS;QAAE7C,QAAQ;QAAEE,UAAU;QAAEsW,iBAAiB;QAAElf;MAAW,CAAC,GAAGwc,aAAa,CAAC,CAAC;MAC7G,MAAM9Q,UAAU,GAAGL,kBAAkB,CAACC,KAAK,CAACwT,WAAW,EAAE;QAAEvT,SAAS;QAAE7C,QAAQ;QAAEE,UAAU;QAAE4C;MAAgB,CAAC,CAAC;MAC9G4R,SAAS,GAAG9R,KAAK,CAACwT,WAAW;MAC7B,IAAKxT,KAAK,CAACwT,WAAW,CAAC1kB,IAAI,KAAK,WAAW,IAAIkR,KAAK,CAACwT,WAAW,CAAC9R,OAAO,CAAClP,MAAM,GAAG,CAAC;MAC/E;MACCwG,MAAM,IAAI,CAACtE,UAAU,CAACzC,GAAG,CAAC+G,MAAM,CAAE,EAAE;QACrC4Y,SAAS,GAAG,IAAI;MACpB;MACA,IAAIA,SAAS,EAAE;QACX;MACJ;MACA,IAAI,CAACJ,cAAc,IAAIuB,iBAAiB,IAAIrB,WAAW,EAAE;QACrDF,cAAc,GAAG,IAAI;QACrBqB,OAAO,CAAC,CAAC;MACb;MACA,IAAI,CAACnB,WAAW,EAAE;QACd,MAAMvhB,CAAC,GAAGiQ,UAAU,CAACC,QAAQ,IAAIiR,OAAO,CAACnhB,CAAC,IAAI,CAAC,CAAC;QAChD,MAAMC,CAAC,GAAGgQ,UAAU,CAACE,QAAQ,IAAIgR,OAAO,CAAClhB,CAAC,IAAI,CAAC,CAAC;QAChD,MAAM0L,QAAQ,GAAGZ,IAAI,CAACiI,IAAI,CAAChT,CAAC,GAAGA,CAAC,GAAGC,CAAC,GAAGA,CAAC,CAAC;QACzC,IAAI0L,QAAQ,GAAG8X,iBAAiB,EAAE;UAC9BV,SAAS,CAAClT,KAAK,CAAC;QACpB;MACJ;MACA;MACA,IAAI,CAACsR,OAAO,CAACnhB,CAAC,KAAKiQ,UAAU,CAACC,QAAQ,IAAIiR,OAAO,CAAClhB,CAAC,KAAKgQ,UAAU,CAACE,QAAQ,KAAKgQ,SAAS,IAAIoB,WAAW,EAAE;QACtGD,aAAa,GAAGtR,gBAAgB,CAACH,KAAK,CAACwT,WAAW,EAAEtT,eAAe,CAAC;QACpEiS,WAAW,CAAC/R,UAAU,CAAC;MAC3B;IACJ,CAAC,CAAC,CACGuT,EAAE,CAAC,KAAK,EAAG3T,KAAK,IAAK;MACtB,IAAI,CAAC0R,WAAW,IAAIE,SAAS,EAAE;QAC3B;MACJ;MACAJ,cAAc,GAAG,KAAK;MACtBE,WAAW,GAAG,KAAK;MACnBsB,oBAAoB,CAACzB,SAAS,CAAC;MAC/B,IAAIjB,SAAS,CAACxe,IAAI,GAAG,CAAC,EAAE;QACpB,MAAM;UAAE4C,UAAU;UAAE4d,mBAAmB;UAAEuB,cAAc;UAAEC;QAAoB,CAAC,GAAG5C,aAAa,CAAC,CAAC;QAChG,IAAIW,oBAAoB,EAAE;UACtBS,mBAAmB,CAAChC,SAAS,EAAE,KAAK,CAAC;UACrCuB,oBAAoB,GAAG,KAAK;QAChC;QACA,IAAIR,UAAU,IAAIwC,cAAc,IAAK,CAAC7a,MAAM,IAAI8a,mBAAoB,EAAE;UAClE,MAAM,CAAC5e,WAAW,EAAE0d,YAAY,CAAC,GAAGpC,qBAAqB,CAAC;YACtDxX,MAAM;YACNsX,SAAS;YACT5b,UAAU;YACV4C,QAAQ,EAAE;UACd,CAAC,CAAC;UACF+Z,UAAU,GAAGrR,KAAK,CAACwT,WAAW,EAAElD,SAAS,EAAEpb,WAAW,EAAE0d,YAAY,CAAC;UACrEiB,cAAc,GAAG7T,KAAK,CAACwT,WAAW,EAAEte,WAAW,EAAE0d,YAAY,CAAC;UAC9D,IAAI,CAAC5Z,MAAM,EAAE;YACT8a,mBAAmB,GAAG9T,KAAK,CAACwT,WAAW,EAAEZ,YAAY,CAAC;UAC1D;QACJ;MACJ;IACJ,CAAC,CAAC,CACGpf,MAAM,CAAEwM,KAAK,IAAK;MACnB,MAAMzM,MAAM,GAAGyM,KAAK,CAACzM,MAAM;MAC3B,MAAMwgB,WAAW,GAAG,CAAC/T,KAAK,CAACgU,MAAM,KAC5B,CAACjC,eAAe,IAAI,CAACjC,WAAW,CAACvc,MAAM,EAAE,IAAIwe,eAAe,EAAE,EAAEzE,OAAO,CAAC,CAAC,KACzE,CAAC0E,cAAc,IAAIlC,WAAW,CAACvc,MAAM,EAAEye,cAAc,EAAE1E,OAAO,CAAC,CAAC;MACrE,OAAOyG,WAAW;IACtB,CAAC,CAAC;IACFpC,WAAW,CAACsC,IAAI,CAACR,cAAc,CAAC;EACpC;EACA,SAASS,OAAOA,CAAA,EAAG;IACfvC,WAAW,EAAEgC,EAAE,CAAC,OAAO,EAAE,IAAI,CAAC;EAClC;EACA,OAAO;IACH5F,MAAM;IACNmG;EACJ,CAAC;AACL;AAEA,SAASC,sBAAsBA,CAAC/f,QAAQ,EAAEM,UAAU,EAAEoH,QAAQ,EAAE;EAC5D,MAAM9I,KAAK,GAAG,EAAE;EAChB,MAAM8C,IAAI,GAAG;IACT3F,CAAC,EAAEiE,QAAQ,CAACjE,CAAC,GAAG2L,QAAQ;IACxB1L,CAAC,EAAEgE,QAAQ,CAAChE,CAAC,GAAG0L,QAAQ;IACxBhI,KAAK,EAAEgI,QAAQ,GAAG,CAAC;IACnB/H,MAAM,EAAE+H,QAAQ,GAAG;EACvB,CAAC;EACD,KAAK,MAAM/I,IAAI,IAAI2B,UAAU,CAAC6B,MAAM,CAAC,CAAC,EAAE;IACpC,IAAIO,kBAAkB,CAAChB,IAAI,EAAEiB,UAAU,CAAChE,IAAI,CAAC,CAAC,GAAG,CAAC,EAAE;MAChDC,KAAK,CAACT,IAAI,CAACQ,IAAI,CAAC;IACpB;EACJ;EACA,OAAOC,KAAK;AAChB;AACA;AACA;AACA;AACA;AACA,MAAMohB,mBAAmB,GAAG,GAAG;AAC/B,SAASC,gBAAgBA,CAACjgB,QAAQ,EAAEkgB,gBAAgB,EAAE5f,UAAU,EAAE9D,UAAU,EAAE;EAC1E,IAAI2jB,cAAc,GAAG,EAAE;EACvB,IAAIC,WAAW,GAAG9e,QAAQ;EAC1B,MAAM+e,UAAU,GAAGN,sBAAsB,CAAC/f,QAAQ,EAAEM,UAAU,EAAE4f,gBAAgB,GAAGF,mBAAmB,CAAC;EACvG,KAAK,MAAMrhB,IAAI,IAAI0hB,UAAU,EAAE;IAC3B,MAAMC,UAAU,GAAG,CAAC,IAAI3hB,IAAI,CAACoE,SAAS,CAACC,YAAY,EAAE/D,MAAM,IAAI,EAAE,CAAC,EAAE,IAAIN,IAAI,CAACoE,SAAS,CAACC,YAAY,EAAE7D,MAAM,IAAI,EAAE,CAAC,CAAC;IACnH,KAAK,MAAM4O,MAAM,IAAIuS,UAAU,EAAE;MAC7B;MACA,IAAI9jB,UAAU,CAACoI,MAAM,KAAKmJ,MAAM,CAACnJ,MAAM,IAAIpI,UAAU,CAAC9B,IAAI,KAAKqT,MAAM,CAACrT,IAAI,IAAI8B,UAAU,CAAChC,EAAE,KAAKuT,MAAM,CAACvT,EAAE,EAAE;QACvG;MACJ;MACA;MACA,MAAM;QAAEuB,CAAC;QAAEC;MAAE,CAAC,GAAGyY,iBAAiB,CAAC9V,IAAI,EAAEoP,MAAM,EAAEA,MAAM,CAAC/N,QAAQ,EAAE,IAAI,CAAC;MACvE,MAAM0H,QAAQ,GAAGZ,IAAI,CAACiI,IAAI,CAACjI,IAAI,CAAC2K,GAAG,CAAC1V,CAAC,GAAGiE,QAAQ,CAACjE,CAAC,EAAE,CAAC,CAAC,GAAG+K,IAAI,CAAC2K,GAAG,CAACzV,CAAC,GAAGgE,QAAQ,CAAChE,CAAC,EAAE,CAAC,CAAC,CAAC;MACrF,IAAI0L,QAAQ,GAAGwY,gBAAgB,EAAE;QAC7B;MACJ;MACA,IAAIxY,QAAQ,GAAG0Y,WAAW,EAAE;QACxBD,cAAc,GAAG,CAAC;UAAE,GAAGpS,MAAM;UAAEhS,CAAC;UAAEC;QAAE,CAAC,CAAC;QACtCokB,WAAW,GAAG1Y,QAAQ;MAC1B,CAAC,MACI,IAAIA,QAAQ,KAAK0Y,WAAW,EAAE;QAC/B;QACAD,cAAc,CAAChiB,IAAI,CAAC;UAAE,GAAG4P,MAAM;UAAEhS,CAAC;UAAEC;QAAE,CAAC,CAAC;MAC5C;IACJ;EACJ;EACA,IAAI,CAACmkB,cAAc,CAAC/hB,MAAM,EAAE;IACxB,OAAO,IAAI;EACf;EACA;EACA,IAAI+hB,cAAc,CAAC/hB,MAAM,GAAG,CAAC,EAAE;IAC3B,MAAMmiB,kBAAkB,GAAG/jB,UAAU,CAAC9B,IAAI,KAAK,QAAQ,GAAG,QAAQ,GAAG,QAAQ;IAC7E,OAAOylB,cAAc,CAACha,IAAI,CAAE4H,MAAM,IAAKA,MAAM,CAACrT,IAAI,KAAK6lB,kBAAkB,CAAC,IAAIJ,cAAc,CAAC,CAAC,CAAC;EACnG;EACA,OAAOA,cAAc,CAAC,CAAC,CAAC;AAC5B;AACA,SAASK,SAASA,CAAC5b,MAAM,EAAEhK,UAAU,EAAE+Z,QAAQ,EAAErU,UAAU,EAAEiU,cAAc,EAAEkM,oBAAoB,GAAG,KAAK,EAAE;EACvG,MAAM9hB,IAAI,GAAG2B,UAAU,CAACU,GAAG,CAAC4D,MAAM,CAAC;EACnC,IAAI,CAACjG,IAAI,EAAE;IACP,OAAO,IAAI;EACf;EACA,MAAMiP,OAAO,GAAG2G,cAAc,KAAK,QAAQ,GACrC5V,IAAI,CAACoE,SAAS,CAACC,YAAY,GAAGpI,UAAU,CAAC,GACzC,CAAC,IAAI+D,IAAI,CAACoE,SAAS,CAACC,YAAY,EAAE/D,MAAM,IAAI,EAAE,CAAC,EAAE,IAAIN,IAAI,CAACoE,SAAS,CAACC,YAAY,EAAE7D,MAAM,IAAI,EAAE,CAAC,CAAC;EACtG,MAAM4O,MAAM,GAAG,CAAC4G,QAAQ,GAAG/G,OAAO,EAAEzH,IAAI,CAAEua,CAAC,IAAKA,CAAC,CAAClmB,EAAE,KAAKma,QAAQ,CAAC,GAAG/G,OAAO,GAAG,CAAC,CAAC,KAAK,IAAI;EAC1F,OAAOG,MAAM,IAAI0S,oBAAoB,GAC/B;IAAE,GAAG1S,MAAM;IAAE,GAAG0G,iBAAiB,CAAC9V,IAAI,EAAEoP,MAAM,EAAEA,MAAM,CAAC/N,QAAQ,EAAE,IAAI;EAAE,CAAC,GACxE+N,MAAM;AAChB;AACA,SAAS4S,aAAaA,CAACC,eAAe,EAAEC,aAAa,EAAE;EACnD,IAAID,eAAe,EAAE;IACjB,OAAOA,eAAe;EAC1B,CAAC,MACI,IAAIC,aAAa,EAAEC,SAAS,CAACC,QAAQ,CAAC,QAAQ,CAAC,EAAE;IAClD,OAAO,QAAQ;EACnB,CAAC,MACI,IAAIF,aAAa,EAAEC,SAAS,CAACC,QAAQ,CAAC,QAAQ,CAAC,EAAE;IAClD,OAAO,QAAQ;EACnB;EACA,OAAO,IAAI;AACf;AACA,SAASC,iBAAiBA,CAACC,wBAAwB,EAAEC,aAAa,EAAE;EAChE,IAAI5kB,OAAO,GAAG,IAAI;EAClB,IAAI4kB,aAAa,EAAE;IACf5kB,OAAO,GAAG,IAAI;EAClB,CAAC,MACI,IAAI2kB,wBAAwB,IAAI,CAACC,aAAa,EAAE;IACjD5kB,OAAO,GAAG,KAAK;EACnB;EACA,OAAOA,OAAO;AAClB;AAEA,MAAM6kB,WAAW,GAAGA,CAAA,KAAM,IAAI;AAC9B,SAASC,aAAaA,CAACxV,KAAK,EAAE;EAAE2I,cAAc;EAAE2L,gBAAgB;EAAEvL,QAAQ;EAAE/P,MAAM;EAAEgc,eAAe;EAAES,QAAQ;EAAEnI,OAAO;EAAE5Y,UAAU;EAAElF,GAAG;EAAEkmB,gBAAgB;EAAEC,MAAM;EAAEtH,KAAK;EAAEuH,gBAAgB;EAAEC,cAAc;EAAEC,SAAS;EAAEC,YAAY;EAAEC,iBAAiB,GAAGT,WAAW;EAAEU,cAAc;EAAEC,gBAAgB;EAAEC,YAAY;EAAEC,aAAa;EAAEtD,YAAY;EAAEuD,aAAa,GAAG,CAAC;EAAEpB;AAAe,CAAC,EAAE;EACpX;EACA,MAAMqB,GAAG,GAAG5V,iBAAiB,CAACV,KAAK,CAACzM,MAAM,CAAC;EAC3C,IAAIge,SAAS,GAAG,CAAC;EACjB,IAAIgF,aAAa;EACjB,MAAM;IAAEpmB,CAAC;IAAEC;EAAE,CAAC,GAAG+P,gBAAgB,CAACH,KAAK,CAAC;EACxC,MAAMhR,UAAU,GAAG+lB,aAAa,CAACC,eAAe,EAAEC,aAAa,CAAC;EAChE,MAAM/U,eAAe,GAAGoN,OAAO,EAAElL,qBAAqB,CAAC,CAAC;EACxD,IAAIoU,iBAAiB,GAAG,KAAK;EAC7B,IAAI,CAACtW,eAAe,IAAI,CAAClR,UAAU,EAAE;IACjC;EACJ;EACA,MAAMynB,kBAAkB,GAAG7B,SAAS,CAAC5b,MAAM,EAAEhK,UAAU,EAAE+Z,QAAQ,EAAErU,UAAU,EAAEiU,cAAc,CAAC;EAC9F,IAAI,CAAC8N,kBAAkB,EAAE;IACrB;EACJ;EACA,IAAIriB,QAAQ,GAAG+L,gBAAgB,CAACH,KAAK,EAAEE,eAAe,CAAC;EACvD,IAAIsR,cAAc,GAAG,KAAK;EAC1B,IAAIlf,UAAU,GAAG,IAAI;EACrB,IAAI5B,OAAO,GAAG,KAAK;EACnB,IAAIgmB,mBAAmB,GAAG,IAAI;EAC9B;EACA,SAAS7D,OAAOA,CAAA,EAAG;IACf,IAAI,CAAC6C,gBAAgB,IAAI,CAACxV,eAAe,EAAE;MACvC;IACJ;IACA,MAAM,CAAC/P,CAAC,EAAEC,CAAC,CAAC,GAAGuL,WAAW,CAACvH,QAAQ,EAAE8L,eAAe,EAAE4S,YAAY,CAAC;IACnEzE,KAAK,CAAC;MAAEle,CAAC;MAAEC;IAAE,CAAC,CAAC;IACfmhB,SAAS,GAAG0B,qBAAqB,CAACJ,OAAO,CAAC;EAC9C;EACA;EACA,MAAMjiB,UAAU,GAAG;IACf,GAAG6lB,kBAAkB;IACrBzd,MAAM;IACNlK,IAAI,EAAEE,UAAU;IAChBoF,QAAQ,EAAEqiB,kBAAkB,CAACriB;EACjC,CAAC;EACD,MAAMuiB,gBAAgB,GAAGjiB,UAAU,CAACU,GAAG,CAAC4D,MAAM,CAAC;EAC/C,MAAMrI,IAAI,GAAGkY,iBAAiB,CAAC8N,gBAAgB,EAAE/lB,UAAU,EAAES,QAAQ,CAACE,IAAI,EAAE,IAAI,CAAC;EACjF,IAAIqlB,kBAAkB,GAAG;IACrBnmB,UAAU,EAAE,IAAI;IAChBC,OAAO,EAAE,IAAI;IACbC,IAAI;IACJC,UAAU;IACVC,YAAY,EAAED,UAAU,CAACwD,QAAQ;IACjCtD,QAAQ,EAAE6lB,gBAAgB;IAC1B5lB,EAAE,EAAEqD,QAAQ;IACZpD,QAAQ,EAAE,IAAI;IACdC,UAAU,EAAEK,gBAAgB,CAACV,UAAU,CAACwD,QAAQ,CAAC;IACjDlD,MAAM,EAAE;EACZ,CAAC;EACD,SAAS2lB,eAAeA,CAAA,EAAG;IACvBL,iBAAiB,GAAG,IAAI;IACxBN,gBAAgB,CAACU,kBAAkB,CAAC;IACpCf,cAAc,GAAG7V,KAAK,EAAE;MAAEhH,MAAM;MAAE+P,QAAQ;MAAE/Z;IAAW,CAAC,CAAC;EAC7D;EACA,IAAIqnB,aAAa,KAAK,CAAC,EAAE;IACrBQ,eAAe,CAAC,CAAC;EACrB;EACA,SAASC,aAAaA,CAAC9W,KAAK,EAAE;IAC1B,IAAI,CAACwW,iBAAiB,EAAE;MACpB,MAAM;QAAErmB,CAAC,EAAEqR,IAAI;QAAEpR,CAAC,EAAEuR;MAAK,CAAC,GAAGxB,gBAAgB,CAACH,KAAK,CAAC;MACpD,MAAM+W,EAAE,GAAGvV,IAAI,GAAGrR,CAAC;MACnB,MAAM6mB,EAAE,GAAGrV,IAAI,GAAGvR,CAAC;MACnB,MAAM6mB,qBAAqB,GAAGF,EAAE,GAAGA,EAAE,GAAGC,EAAE,GAAGA,EAAE,GAAGX,aAAa,GAAGA,aAAa;MAC/E,IAAI,CAACY,qBAAqB,EAAE;QACxB;MACJ;MACAJ,eAAe,CAAC,CAAC;IACrB;IACA,IAAI,CAACT,aAAa,CAAC,CAAC,IAAI,CAACxlB,UAAU,EAAE;MACjCsmB,WAAW,CAAClX,KAAK,CAAC;MAClB;IACJ;IACA,MAAMC,SAAS,GAAGkW,YAAY,CAAC,CAAC;IAChC/hB,QAAQ,GAAG+L,gBAAgB,CAACH,KAAK,EAAEE,eAAe,CAAC;IACnDqW,aAAa,GAAGlC,gBAAgB,CAAChe,oBAAoB,CAACjC,QAAQ,EAAE6L,SAAS,EAAE,KAAK,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAEqU,gBAAgB,EAAE5f,UAAU,EAAE9D,UAAU,CAAC;IACpI,IAAI,CAAC4gB,cAAc,EAAE;MACjBqB,OAAO,CAAC,CAAC;MACTrB,cAAc,GAAG,IAAI;IACzB;IACA,MAAMzG,MAAM,GAAGoM,aAAa,CAACnX,KAAK,EAAE;MAChCmC,MAAM,EAAEoU,aAAa;MACrB5N,cAAc;MACdyO,UAAU,EAAEpe,MAAM;MAClBqe,YAAY,EAAEtO,QAAQ;MACtBuO,QAAQ,EAAE7B,QAAQ,GAAG,QAAQ,GAAG,QAAQ;MACxCO,iBAAiB;MACjBM,GAAG;MACH9mB,GAAG;MACHmmB,MAAM;MACNjhB;IACJ,CAAC,CAAC;IACFgiB,mBAAmB,GAAG3L,MAAM,CAACkK,aAAa;IAC1C3iB,UAAU,GAAGyY,MAAM,CAACzY,UAAU;IAC9B5B,OAAO,GAAG0kB,iBAAiB,CAAC,CAAC,CAACmB,aAAa,EAAExL,MAAM,CAACra,OAAO,CAAC;IAC5D,MAAM2U,aAAa,GAAG;MAClB;MACA,GAAGuR,kBAAkB;MACrBlmB,OAAO;MACPK,EAAE,EAAEga,MAAM,CAAC/Z,QAAQ,IAAIN,OAAO,GACxB6M,oBAAoB,CAAC;QAAEpN,CAAC,EAAE4a,MAAM,CAAC/Z,QAAQ,CAACb,CAAC;QAAEC,CAAC,EAAE2a,MAAM,CAAC/Z,QAAQ,CAACZ;MAAE,CAAC,EAAE6P,SAAS,CAAC,GAC/E7L,QAAQ;MACdpD,QAAQ,EAAE+Z,MAAM,CAAC/Z,QAAQ;MACzBC,UAAU,EAAEP,OAAO,IAAIqa,MAAM,CAAC/Z,QAAQ,GAAG+Z,MAAM,CAAC/Z,QAAQ,CAACoD,QAAQ,GAAG9C,gBAAgB,CAACV,UAAU,CAACwD,QAAQ,CAAC;MACzGlD,MAAM,EAAE6Z,MAAM,CAAC/Z,QAAQ,GAAG0D,UAAU,CAACU,GAAG,CAAC2V,MAAM,CAAC/Z,QAAQ,CAACgI,MAAM,CAAC,GAAG;IACvE,CAAC;IACD;AACR;AACA;AACA;IACQ,IAAItI,OAAO,IACP6lB,aAAa,IACbK,kBAAkB,CAAC5lB,QAAQ,IAC3BqU,aAAa,CAACrU,QAAQ,IACtB4lB,kBAAkB,CAAC5lB,QAAQ,CAAClC,IAAI,KAAKuW,aAAa,CAACrU,QAAQ,CAAClC,IAAI,IAChE8nB,kBAAkB,CAAC5lB,QAAQ,CAACgI,MAAM,KAAKqM,aAAa,CAACrU,QAAQ,CAACgI,MAAM,IACpE4d,kBAAkB,CAAC5lB,QAAQ,CAACpC,EAAE,KAAKyW,aAAa,CAACrU,QAAQ,CAACpC,EAAE,IAC5DgoB,kBAAkB,CAAC7lB,EAAE,CAACZ,CAAC,KAAKkV,aAAa,CAACtU,EAAE,CAACZ,CAAC,IAC9CymB,kBAAkB,CAAC7lB,EAAE,CAACX,CAAC,KAAKiV,aAAa,CAACtU,EAAE,CAACX,CAAC,EAAE;MAChD;IACJ;IACA8lB,gBAAgB,CAAC7Q,aAAa,CAAC;IAC/BuR,kBAAkB,GAAGvR,aAAa;EACtC;EACA,SAAS6R,WAAWA,CAAClX,KAAK,EAAE;IACxB,IAAIwW,iBAAiB,EAAE;MACnB,IAAI,CAACD,aAAa,IAAIG,mBAAmB,KAAKpkB,UAAU,IAAI5B,OAAO,EAAE;QACjEolB,SAAS,GAAGxjB,UAAU,CAAC;MAC3B;MACA;AACZ;AACA;AACA;MACY;MACA,MAAM;QAAE7B,UAAU;QAAE,GAAG8mB;MAAgB,CAAC,GAAGX,kBAAkB;MAC7D,MAAMY,oBAAoB,GAAG;QACzB,GAAGD,eAAe;QAClBtmB,UAAU,EAAE2lB,kBAAkB,CAAC5lB,QAAQ,GAAG4lB,kBAAkB,CAAC3lB,UAAU,GAAG;MAC9E,CAAC;MACD8kB,YAAY,GAAG/V,KAAK,EAAEwX,oBAAoB,CAAC;MAC3C,IAAIxC,eAAe,EAAE;QACjBiB,cAAc,GAAGjW,KAAK,EAAEwX,oBAAoB,CAAC;MACjD;IACJ;IACA5B,gBAAgB,CAAC,CAAC;IAClB5C,oBAAoB,CAACzB,SAAS,CAAC;IAC/BC,cAAc,GAAG,KAAK;IACtB9gB,OAAO,GAAG,KAAK;IACf4B,UAAU,GAAG,IAAI;IACjBokB,mBAAmB,GAAG,IAAI;IAC1BJ,GAAG,CAACmB,mBAAmB,CAAC,WAAW,EAAEX,aAAa,CAAC;IACnDR,GAAG,CAACmB,mBAAmB,CAAC,SAAS,EAAEP,WAAW,CAAC;IAC/CZ,GAAG,CAACmB,mBAAmB,CAAC,WAAW,EAAEX,aAAa,CAAC;IACnDR,GAAG,CAACmB,mBAAmB,CAAC,UAAU,EAAEP,WAAW,CAAC;EACpD;EACAZ,GAAG,CAACoB,gBAAgB,CAAC,WAAW,EAAEZ,aAAa,CAAC;EAChDR,GAAG,CAACoB,gBAAgB,CAAC,SAAS,EAAER,WAAW,CAAC;EAC5CZ,GAAG,CAACoB,gBAAgB,CAAC,WAAW,EAAEZ,aAAa,CAAC;EAChDR,GAAG,CAACoB,gBAAgB,CAAC,UAAU,EAAER,WAAW,CAAC;AACjD;AACA;AACA,SAASC,aAAaA,CAACnX,KAAK,EAAE;EAAEmC,MAAM;EAAEwG,cAAc;EAAEyO,UAAU;EAAEC,YAAY;EAAEC,QAAQ;EAAEhB,GAAG;EAAE9mB,GAAG;EAAEmmB,MAAM;EAAEK,iBAAiB,GAAGT,WAAW;EAAE7gB;AAAY,CAAC,EAAE;EAC1J,MAAM+gB,QAAQ,GAAG6B,QAAQ,KAAK,QAAQ;EACtC,MAAMrC,aAAa,GAAG9S,MAAM,GACtBmU,GAAG,CAAC9I,aAAa,CAAC,IAAIhe,GAAG,0BAA0BmmB,MAAM,IAAIxT,MAAM,EAAEnJ,MAAM,IAAImJ,MAAM,EAAEvT,EAAE,IAAIuT,MAAM,EAAErT,IAAI,IAAI,CAAC,GAC9G,IAAI;EACV,MAAM;IAAEqB,CAAC;IAAEC;EAAE,CAAC,GAAG+P,gBAAgB,CAACH,KAAK,CAAC;EACxC,MAAM2X,WAAW,GAAGrB,GAAG,CAACsB,gBAAgB,CAACznB,CAAC,EAAEC,CAAC,CAAC;EAC9C;AACJ;AACA;AACA;EACI,MAAMynB,aAAa,GAAGF,WAAW,EAAEzC,SAAS,CAACC,QAAQ,CAAC,GAAG3lB,GAAG,eAAe,CAAC,GAAGmoB,WAAW,GAAG1C,aAAa;EAC1G,MAAMlK,MAAM,GAAG;IACXkK,aAAa,EAAE4C,aAAa;IAC5BnnB,OAAO,EAAE,KAAK;IACd4B,UAAU,EAAE,IAAI;IAChBtB,QAAQ,EAAE;EACd,CAAC;EACD,IAAI6mB,aAAa,EAAE;IACf,MAAM7oB,UAAU,GAAG+lB,aAAa,CAAC5f,SAAS,EAAE0iB,aAAa,CAAC;IAC1D,MAAMC,YAAY,GAAGD,aAAa,CAACxV,YAAY,CAAC,aAAa,CAAC;IAC9D,MAAM0G,QAAQ,GAAG8O,aAAa,CAACxV,YAAY,CAAC,eAAe,CAAC;IAC5D,MAAM0V,WAAW,GAAGF,aAAa,CAAC3C,SAAS,CAACC,QAAQ,CAAC,aAAa,CAAC;IACnE,MAAM6C,cAAc,GAAGH,aAAa,CAAC3C,SAAS,CAACC,QAAQ,CAAC,gBAAgB,CAAC;IACzE,IAAI,CAAC2C,YAAY,IAAI,CAAC9oB,UAAU,EAAE;MAC9B,OAAO+b,MAAM;IACjB;IACA,MAAMzY,UAAU,GAAG;MACfe,MAAM,EAAEoiB,QAAQ,GAAGqC,YAAY,GAAGV,UAAU;MAC5CnoB,YAAY,EAAEwmB,QAAQ,GAAG1M,QAAQ,GAAGsO,YAAY;MAChD9jB,MAAM,EAAEkiB,QAAQ,GAAG2B,UAAU,GAAGU,YAAY;MAC5C5oB,YAAY,EAAEumB,QAAQ,GAAG4B,YAAY,GAAGtO;IAC5C,CAAC;IACDgC,MAAM,CAACzY,UAAU,GAAGA,UAAU;IAC9B,MAAM2lB,aAAa,GAAGF,WAAW,IAAIC,cAAc;IACnD;IACA,MAAMtnB,OAAO,GAAGunB,aAAa,KACxBtP,cAAc,KAAKtY,cAAc,CAACuY,MAAM,GAClC6M,QAAQ,IAAIzmB,UAAU,KAAK,QAAQ,IAAM,CAACymB,QAAQ,IAAIzmB,UAAU,KAAK,QAAS,GAC/E8oB,YAAY,KAAKV,UAAU,IAAIrO,QAAQ,KAAKsO,YAAY,CAAC;IACnEtM,MAAM,CAACra,OAAO,GAAGA,OAAO,IAAIslB,iBAAiB,CAAC1jB,UAAU,CAAC;IACzDyY,MAAM,CAAC/Z,QAAQ,GAAG4jB,SAAS,CAACkD,YAAY,EAAE9oB,UAAU,EAAE+Z,QAAQ,EAAErU,UAAU,EAAEiU,cAAc,EAAE,IAAI,CAAC;EACrG;EACA,OAAOoC,MAAM;AACjB;AACA,MAAMmN,QAAQ,GAAG;EACb1C,aAAa;EACb9kB,OAAO,EAAEymB;AACb,CAAC;AAED,SAASgB,SAASA,CAAC;EAAE7K,OAAO;EAAEpV,OAAO;EAAEie,YAAY;EAAEiC;AAAa,CAAC,EAAE;EACjE,MAAMC,SAAS,GAAGzqB,MAAM,CAAC0f,OAAO,CAAC;EACjC,SAASS,MAAMA,CAAC;IAAEQ,eAAe;IAAEza,KAAK;IAAEC,MAAM;IAAEukB,QAAQ,GAAG,CAAC;IAAEC,QAAQ,GAAG,IAAI;IAAEC,QAAQ,GAAG,IAAI;IAAEC,UAAU,GAAG;EAAO,CAAC,EAAE;IACrH;IACA,MAAMC,WAAW,GAAI1Y,KAAK,IAAK;MAC3B,IAAIA,KAAK,CAACwT,WAAW,CAAC1kB,IAAI,KAAK,OAAO,IAAI,CAACoJ,OAAO,EAAE;QAChD;MACJ;MACA,MAAM+H,SAAS,GAAGkW,YAAY,CAAC,CAAC;MAChC,MAAMwC,MAAM,GAAG3Y,KAAK,CAACwT,WAAW,CAACoF,OAAO,IAAI5Z,OAAO,CAAC,CAAC,GAAG,EAAE,GAAG,CAAC;MAC9D,MAAM6Z,UAAU,GAAG,CAAC7Y,KAAK,CAACwT,WAAW,CAACsF,MAAM,IACvC9Y,KAAK,CAACwT,WAAW,CAACuF,SAAS,KAAK,CAAC,GAAG,IAAI,GAAG/Y,KAAK,CAACwT,WAAW,CAACuF,SAAS,GAAG,CAAC,GAAG,KAAK,CAAC,GACpFT,QAAQ;MACZ,MAAMU,QAAQ,GAAG/Y,SAAS,CAAC,CAAC,CAAC,GAAG/E,IAAI,CAAC2K,GAAG,CAAC,CAAC,EAAEgT,UAAU,GAAGF,MAAM,CAAC;MAChEzgB,OAAO,CAAC+gB,OAAO,CAACD,QAAQ,CAAC;IAC7B,CAAC;IACD,IAAIE,QAAQ,GAAG,CAAC,CAAC,EAAE,CAAC,CAAC;IACrB;IACA,MAAMC,eAAe,GAAInZ,KAAK,IAAK;MAC/B,IAAIA,KAAK,CAACwT,WAAW,CAAC1kB,IAAI,KAAK,WAAW,IAAIkR,KAAK,CAACwT,WAAW,CAAC1kB,IAAI,KAAK,YAAY,EAAE;QACnFoqB,QAAQ,GAAG,CACPlZ,KAAK,CAACwT,WAAW,CAAC/R,OAAO,IAAIzB,KAAK,CAACwT,WAAW,CAAC9R,OAAO,CAAC,CAAC,CAAC,CAACD,OAAO,EACjEzB,KAAK,CAACwT,WAAW,CAAC5R,OAAO,IAAI5B,KAAK,CAACwT,WAAW,CAAC9R,OAAO,CAAC,CAAC,CAAC,CAACE,OAAO,CACpE;MACL;IACJ,CAAC;IACD;IACA,MAAMwX,UAAU,GAAIpZ,KAAK,IAAK;MAC1B,MAAMC,SAAS,GAAGkW,YAAY,CAAC,CAAC;MAChC,IAAKnW,KAAK,CAACwT,WAAW,CAAC1kB,IAAI,KAAK,WAAW,IAAIkR,KAAK,CAACwT,WAAW,CAAC1kB,IAAI,KAAK,WAAW,IAAK,CAACoJ,OAAO,EAAE;QAChG;MACJ;MACA,MAAMmhB,UAAU,GAAG,CACfrZ,KAAK,CAACwT,WAAW,CAAC/R,OAAO,IAAIzB,KAAK,CAACwT,WAAW,CAAC9R,OAAO,CAAC,CAAC,CAAC,CAACD,OAAO,EACjEzB,KAAK,CAACwT,WAAW,CAAC5R,OAAO,IAAI5B,KAAK,CAACwT,WAAW,CAAC9R,OAAO,CAAC,CAAC,CAAC,CAACE,OAAO,CACpE;MACD,MAAM0X,QAAQ,GAAG,CAACD,UAAU,CAAC,CAAC,CAAC,GAAGH,QAAQ,CAAC,CAAC,CAAC,EAAEG,UAAU,CAAC,CAAC,CAAC,GAAGH,QAAQ,CAAC,CAAC,CAAC,CAAC;MAC3EA,QAAQ,GAAGG,UAAU;MACrB,MAAME,SAAS,GAAGnB,YAAY,CAAC,CAAC,GAAGld,IAAI,CAACD,GAAG,CAACgF,SAAS,CAAC,CAAC,CAAC,EAAE/E,IAAI,CAACse,GAAG,CAACvZ,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC,IAAIwY,UAAU,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC;MACzG,MAAMrkB,QAAQ,GAAG;QACbjE,CAAC,EAAE8P,SAAS,CAAC,CAAC,CAAC,GAAGqZ,QAAQ,CAAC,CAAC,CAAC,GAAGC,SAAS;QACzCnpB,CAAC,EAAE6P,SAAS,CAAC,CAAC,CAAC,GAAGqZ,QAAQ,CAAC,CAAC,CAAC,GAAGC;MACpC,CAAC;MACD,MAAM9f,MAAM,GAAG,CACX,CAAC,CAAC,EAAE,CAAC,CAAC,EACN,CAAC3F,KAAK,EAAEC,MAAM,CAAC,CAClB;MACDmE,OAAO,CAACuW,sBAAsB,CAAC;QAC3Bte,CAAC,EAAEiE,QAAQ,CAACjE,CAAC;QACbC,CAAC,EAAEgE,QAAQ,CAAChE,CAAC;QACbtC,IAAI,EAAEmS,SAAS,CAAC,CAAC;MACrB,CAAC,EAAExG,MAAM,EAAE8U,eAAe,CAAC;IAC/B,CAAC;IACD,MAAMkL,iBAAiB,GAAG3rB,IAAI,CAAC,CAAC,CAC3B6lB,EAAE,CAAC,OAAO,EAAEwF,eAAe;IAC5B;IACA;IAAA,CACCxF,EAAE,CAAC,MAAM,EAAE4E,QAAQ,GAAGa,UAAU,GAAG,IAAI;IACxC;IACA;IAAA,CACCzF,EAAE,CAAC,YAAY,EAAE6E,QAAQ,GAAGE,WAAW,GAAG,IAAI,CAAC;IACpDL,SAAS,CAACpE,IAAI,CAACwF,iBAAiB,EAAE,CAAC,CAAC,CAAC;EACzC;EACA,SAASvF,OAAOA,CAAA,EAAG;IACfmE,SAAS,CAAC1E,EAAE,CAAC,MAAM,EAAE,IAAI,CAAC;EAC9B;EACA,OAAO;IACH5F,MAAM;IACNmG,OAAO;IACPrmB;EACJ,CAAC;AACL;;AAEA;AACA,MAAM6rB,WAAW,GAAGA,CAACC,YAAY,EAAEC,aAAa,KAAKD,YAAY,CAACxpB,CAAC,KAAKypB,aAAa,CAACzpB,CAAC,IAAIwpB,YAAY,CAACvpB,CAAC,KAAKwpB,aAAa,CAACxpB,CAAC,IAAIupB,YAAY,CAAC7rB,IAAI,KAAK8rB,aAAa,CAACjL,CAAC;AACtK,MAAMkL,mBAAmB,GAAI5Z,SAAS,KAAM;EACxC9P,CAAC,EAAE8P,SAAS,CAAC9P,CAAC;EACdC,CAAC,EAAE6P,SAAS,CAAC7P,CAAC;EACdtC,IAAI,EAAEmS,SAAS,CAAC0O;AACpB,CAAC,CAAC;AACF,MAAMmL,mBAAmB,GAAGA,CAAC;EAAE3pB,CAAC;EAAEC,CAAC;EAAEtC;AAAK,CAAC,KAAKC,YAAY,CAACgsB,SAAS,CAAC5pB,CAAC,EAAEC,CAAC,CAAC,CAAC4pB,KAAK,CAAClsB,IAAI,CAAC;AACxF,MAAMmsB,kBAAkB,GAAGA,CAACja,KAAK,EAAEka,SAAS,KAAKla,KAAK,CAACzM,MAAM,CAAC8N,OAAO,CAAC,IAAI6Y,SAAS,EAAE,CAAC;AACtF,MAAMC,eAAe,GAAGA,CAACC,SAAS,EAAEC,UAAU,KAAKA,UAAU,KAAK,CAAC,IAAInY,KAAK,CAACuN,OAAO,CAAC2K,SAAS,CAAC,IAAIA,SAAS,CAAClZ,QAAQ,CAAC,CAAC,CAAC;AACxH;AACA,MAAMoZ,WAAW,GAAIC,CAAC,IAAK,CAAC,CAACA,CAAC,IAAI,CAAC,KAAK,CAAC,GAAGA,CAAC,GAAGA,CAAC,GAAGA,CAAC,GAAG,CAACA,CAAC,IAAI,CAAC,IAAIA,CAAC,GAAGA,CAAC,GAAG,CAAC,IAAI,CAAC;AACjF,MAAMC,eAAe,GAAGA,CAACnC,SAAS,EAAExf,QAAQ,GAAG,CAAC,EAAEC,IAAI,GAAGwhB,WAAW,EAAEG,KAAK,GAAGA,CAAA,KAAM,CAAE,CAAC,KAAK;EACxF,MAAMC,WAAW,GAAG,OAAO7hB,QAAQ,KAAK,QAAQ,IAAIA,QAAQ,GAAG,CAAC;EAChE,IAAI,CAAC6hB,WAAW,EAAE;IACdD,KAAK,CAAC,CAAC;EACX;EACA,OAAOC,WAAW,GAAGrC,SAAS,CAACsC,UAAU,CAAC,CAAC,CAAC9hB,QAAQ,CAACA,QAAQ,CAAC,CAACC,IAAI,CAACA,IAAI,CAAC,CAAC6a,EAAE,CAAC,KAAK,EAAE8G,KAAK,CAAC,GAAGpC,SAAS;AAC1G,CAAC;AACD,MAAMuC,UAAU,GAAI5a,KAAK,IAAK;EAC1B,MAAM2Y,MAAM,GAAG3Y,KAAK,CAAC4Y,OAAO,IAAI5Z,OAAO,CAAC,CAAC,GAAG,EAAE,GAAG,CAAC;EAClD,OAAO,CAACgB,KAAK,CAAC8Y,MAAM,IAAI9Y,KAAK,CAAC+Y,SAAS,KAAK,CAAC,GAAG,IAAI,GAAG/Y,KAAK,CAAC+Y,SAAS,GAAG,CAAC,GAAG,KAAK,CAAC,GAAGJ,MAAM;AAChG,CAAC;AAED,SAASkC,wBAAwBA,CAAC;EAAEC,aAAa;EAAEC,gBAAgB;EAAEpJ,WAAW;EAAEqJ,MAAM;EAAEC,eAAe;EAAEC,gBAAgB;EAAEC,WAAW;EAAEC,cAAc;EAAEC,SAAS;EAAEC;AAAc,CAAC,EAAE;EAClL,OAAQtb,KAAK,IAAK;IACd,IAAIia,kBAAkB,CAACja,KAAK,EAAE+a,gBAAgB,CAAC,EAAE;MAC7C,OAAO,KAAK;IAChB;IACA/a,KAAK,CAACub,cAAc,CAAC,CAAC;IACtBvb,KAAK,CAACwb,wBAAwB,CAAC,CAAC;IAChC,MAAMC,WAAW,GAAG9J,WAAW,CAAC+J,QAAQ,CAAC,QAAQ,CAAC,CAAC/M,CAAC,IAAI,CAAC;IACzD;IACA,IAAI3O,KAAK,CAAC4Y,OAAO,IAAIuC,WAAW,EAAE;MAC9B,MAAMQ,KAAK,GAAG9tB,OAAO,CAACmS,KAAK,CAAC;MAC5B,MAAM6Y,UAAU,GAAG+B,UAAU,CAAC5a,KAAK,CAAC;MACpC,MAAMlS,IAAI,GAAG2tB,WAAW,GAAGvgB,IAAI,CAAC2K,GAAG,CAAC,CAAC,EAAEgT,UAAU,CAAC;MAClD;MACAmC,MAAM,CAAC/B,OAAO,CAACtH,WAAW,EAAE7jB,IAAI,EAAE6tB,KAAK,EAAE3b,KAAK,CAAC;MAC/C;IACJ;IACA;AACR;AACA;AACA;IACQ,MAAM4b,cAAc,GAAG5b,KAAK,CAAC+Y,SAAS,KAAK,CAAC,GAAG,EAAE,GAAG,CAAC;IACrD,IAAI8C,MAAM,GAAGZ,eAAe,KAAK3qB,eAAe,CAACwrB,QAAQ,GAAG,CAAC,GAAG9b,KAAK,CAAC6b,MAAM,GAAGD,cAAc;IAC7F,IAAI9C,MAAM,GAAGmC,eAAe,KAAK3qB,eAAe,CAACyrB,UAAU,GAAG,CAAC,GAAG/b,KAAK,CAAC8Y,MAAM,GAAG8C,cAAc;IAC/F;IACA,IAAI,CAAC5c,OAAO,CAAC,CAAC,IAAIgB,KAAK,CAACgc,QAAQ,IAAIf,eAAe,KAAK3qB,eAAe,CAACwrB,QAAQ,EAAE;MAC9ED,MAAM,GAAG7b,KAAK,CAAC8Y,MAAM,GAAG8C,cAAc;MACtC9C,MAAM,GAAG,CAAC;IACd;IACAkC,MAAM,CAACiB,WAAW,CAACtK,WAAW,EAAE,EAAEkK,MAAM,GAAGJ,WAAW,CAAC,GAAGP,gBAAgB,EAAE,EAAEpC,MAAM,GAAG2C,WAAW,CAAC,GAAGP,gBAAgB;IACtH;IACA;MAAEgB,QAAQ,EAAE;IAAK,CAAC,CAAC;IACnB,MAAM1N,YAAY,GAAGqL,mBAAmB,CAAClI,WAAW,CAAC+J,QAAQ,CAAC,QAAQ,CAAC,CAAC;IACxES,YAAY,CAACrB,aAAa,CAACsB,gBAAgB,CAAC;IAC5C;AACR;AACA;AACA;AACA;IACQ,IAAI,CAACtB,aAAa,CAACuB,cAAc,EAAE;MAC/BvB,aAAa,CAACuB,cAAc,GAAG,IAAI;MACnCjB,cAAc,GAAGpb,KAAK,EAAEwO,YAAY,CAAC;IACzC;IACA,IAAIsM,aAAa,CAACuB,cAAc,EAAE;MAC9BhB,SAAS,GAAGrb,KAAK,EAAEwO,YAAY,CAAC;MAChCsM,aAAa,CAACsB,gBAAgB,GAAGE,UAAU,CAAC,MAAM;QAC9ChB,YAAY,GAAGtb,KAAK,EAAEwO,YAAY,CAAC;QACnCsM,aAAa,CAACuB,cAAc,GAAG,KAAK;MACxC,CAAC,EAAE,GAAG,CAAC;IACX;EACJ,CAAC;AACL;AACA,SAASE,yBAAyBA,CAAC;EAAExB,gBAAgB;EAAEyB,gBAAgB;EAAEC;AAAc,CAAC,EAAE;EACtF,OAAO,UAAUzc,KAAK,EAAEgJ,CAAC,EAAE;IACvB,MAAM0T,OAAO,GAAG1c,KAAK,CAAClR,IAAI,KAAK,OAAO;IACtC;IACA,MAAM6tB,WAAW,GAAG,CAACH,gBAAgB,IAAIE,OAAO,IAAI,CAAC1c,KAAK,CAAC4Y,OAAO;IAClE,MAAMgE,eAAe,GAAG3C,kBAAkB,CAACja,KAAK,EAAE+a,gBAAgB,CAAC;IACnE;IACA,IAAI/a,KAAK,CAAC4Y,OAAO,IAAI8D,OAAO,IAAIE,eAAe,EAAE;MAC7C5c,KAAK,CAACub,cAAc,CAAC,CAAC;IAC1B;IACA,IAAIoB,WAAW,IAAIC,eAAe,EAAE;MAChC,OAAO,IAAI;IACf;IACA5c,KAAK,CAACub,cAAc,CAAC,CAAC;IACtBkB,aAAa,CAACxI,IAAI,CAAC,IAAI,EAAEjU,KAAK,EAAEgJ,CAAC,CAAC;EACtC,CAAC;AACL;AACA,SAAS6T,yBAAyBA,CAAC;EAAE/B,aAAa;EAAEgC,gBAAgB;EAAE1B;AAAe,CAAC,EAAE;EACpF,OAAQpb,KAAK,IAAK;IACd,IAAIA,KAAK,CAACwT,WAAW,EAAE0I,QAAQ,EAAE;MAC7B;IACJ;IACA,MAAMzjB,QAAQ,GAAGohB,mBAAmB,CAAC7Z,KAAK,CAACC,SAAS,CAAC;IACrD;IACA6a,aAAa,CAACiC,WAAW,GAAG/c,KAAK,CAACwT,WAAW,EAAEQ,MAAM,IAAI,CAAC;IAC1D8G,aAAa,CAACkC,kBAAkB,GAAG,IAAI;IACvClC,aAAa,CAACnB,YAAY,GAAGlhB,QAAQ;IACrC,IAAIuH,KAAK,CAACwT,WAAW,EAAE1kB,IAAI,KAAK,WAAW,EAAE;MACzCguB,gBAAgB,CAAC,IAAI,CAAC;IAC1B;IACA,IAAI1B,cAAc,EAAE;MAChBA,cAAc,GAAGpb,KAAK,CAACwT,WAAW,EAAE/a,QAAQ,CAAC;IACjD;EACJ,CAAC;AACL;AACA,SAASwkB,oBAAoBA,CAAC;EAAEnC,aAAa;EAAEV,SAAS;EAAE8C,iBAAiB;EAAEC,iBAAiB;EAAE9B;AAAW,CAAC,EAAE;EAC1G,OAAQrb,KAAK,IAAK;IACd8a,aAAa,CAACsC,oBAAoB,GAAG,CAAC,EAAEF,iBAAiB,IAAI/C,eAAe,CAACC,SAAS,EAAEU,aAAa,CAACiC,WAAW,IAAI,CAAC,CAAC,CAAC;IACxH,IAAI,CAAC/c,KAAK,CAACwT,WAAW,EAAE6J,IAAI,EAAE;MAC1BF,iBAAiB,CAAC,CAACnd,KAAK,CAACC,SAAS,CAAC9P,CAAC,EAAE6P,KAAK,CAACC,SAAS,CAAC7P,CAAC,EAAE4P,KAAK,CAACC,SAAS,CAAC0O,CAAC,CAAC,CAAC;IAChF;IACA,IAAI0M,SAAS,IAAI,CAACrb,KAAK,CAACwT,WAAW,EAAE0I,QAAQ,EAAE;MAC3Cb,SAAS,GAAGrb,KAAK,CAACwT,WAAW,EAAEqG,mBAAmB,CAAC7Z,KAAK,CAACC,SAAS,CAAC,CAAC;IACxE;EACJ,CAAC;AACL;AACA,SAASqd,uBAAuBA,CAAC;EAAExC,aAAa;EAAEV,SAAS;EAAEmD,WAAW;EAAET,gBAAgB;EAAExB,YAAY;EAAE4B;AAAmB,CAAC,EAAE;EAC5H,OAAQld,KAAK,IAAK;IACd,IAAIA,KAAK,CAACwT,WAAW,EAAE0I,QAAQ,EAAE;MAC7B;IACJ;IACApB,aAAa,CAACkC,kBAAkB,GAAG,KAAK;IACxC,IAAIE,iBAAiB,IACjB/C,eAAe,CAACC,SAAS,EAAEU,aAAa,CAACiC,WAAW,IAAI,CAAC,CAAC,IAC1D,CAACjC,aAAa,CAACsC,oBAAoB,IACnCpd,KAAK,CAACwT,WAAW,EAAE;MACnB0J,iBAAiB,CAACld,KAAK,CAACwT,WAAW,CAAC;IACxC;IACAsH,aAAa,CAACsC,oBAAoB,GAAG,KAAK;IAC1CN,gBAAgB,CAAC,KAAK,CAAC;IACvB,IAAIxB,YAAY,IAAI5B,WAAW,CAACoB,aAAa,CAACnB,YAAY,EAAE3Z,KAAK,CAACC,SAAS,CAAC,EAAE;MAC1E,MAAMxH,QAAQ,GAAGohB,mBAAmB,CAAC7Z,KAAK,CAACC,SAAS,CAAC;MACrD6a,aAAa,CAACnB,YAAY,GAAGlhB,QAAQ;MACrC0jB,YAAY,CAACrB,aAAa,CAAC0C,OAAO,CAAC;MACnC1C,aAAa,CAAC0C,OAAO,GAAGlB,UAAU,CAAC,MAAM;QACrChB,YAAY,GAAGtb,KAAK,CAACwT,WAAW,EAAE/a,QAAQ,CAAC;MAC/C,CAAC;MACD;MACA8kB,WAAW,GAAG,GAAG,GAAG,CAAC,CAAC;IAC1B;EACJ,CAAC;AACL;;AAEA;AACA,SAASE,YAAYA,CAAC;EAAEC,wBAAwB;EAAEC,YAAY;EAAExC,WAAW;EAAEf,SAAS;EAAEmD,WAAW;EAAEK,iBAAiB;EAAEC,mBAAmB;EAAE9C,gBAAgB;EAAE+C,cAAc;EAAEtuB;AAAK,CAAC,EAAE;EACnL,OAAQwQ,KAAK,IAAK;IACd,MAAM+d,UAAU,GAAGL,wBAAwB,IAAIC,YAAY;IAC3D,MAAMK,SAAS,GAAG7C,WAAW,IAAInb,KAAK,CAAC4Y,OAAO;IAC9C,IAAI5Y,KAAK,CAACgU,MAAM,KAAK,CAAC,IAClBhU,KAAK,CAAClR,IAAI,KAAK,WAAW,KACzBmrB,kBAAkB,CAACja,KAAK,EAAE,GAAGxQ,GAAG,aAAa,CAAC,IAAIyqB,kBAAkB,CAACja,KAAK,EAAE,GAAGxQ,GAAG,aAAa,CAAC,CAAC,EAAE;MACpG,OAAO,IAAI;IACf;IACA;IACA,IAAI,CAAC4qB,SAAS,IAAI,CAAC2D,UAAU,IAAI,CAACR,WAAW,IAAI,CAACK,iBAAiB,IAAI,CAACzC,WAAW,EAAE;MACjF,OAAO,KAAK;IAChB;IACA;IACA,IAAI0C,mBAAmB,EAAE;MACrB,OAAO,KAAK;IAChB;IACA;IACA,IAAI5D,kBAAkB,CAACja,KAAK,EAAE+a,gBAAgB,CAAC,IAAI/a,KAAK,CAAClR,IAAI,KAAK,OAAO,EAAE;MACvE,OAAO,KAAK;IAChB;IACA;IACA,IAAImrB,kBAAkB,CAACja,KAAK,EAAE8d,cAAc,CAAC,KACxC9d,KAAK,CAAClR,IAAI,KAAK,OAAO,IAAKyuB,WAAW,IAAIvd,KAAK,CAAClR,IAAI,KAAK,OAAO,IAAI,CAAC4uB,wBAAyB,CAAC,EAAE;MAClG,OAAO,KAAK;IAChB;IACA,IAAI,CAACvC,WAAW,IAAInb,KAAK,CAAC4Y,OAAO,IAAI5Y,KAAK,CAAClR,IAAI,KAAK,OAAO,EAAE;MACzD,OAAO,KAAK;IAChB;IACA,IAAI,CAACqsB,WAAW,IAAInb,KAAK,CAAClR,IAAI,KAAK,YAAY,IAAIkR,KAAK,CAAC0B,OAAO,EAAElP,MAAM,GAAG,CAAC,EAAE;MAC1EwN,KAAK,CAACub,cAAc,CAAC,CAAC,CAAC,CAAC;MACxB,OAAO,KAAK;IAChB;IACA;IACA,IAAI,CAACwC,UAAU,IAAI,CAACR,WAAW,IAAI,CAACS,SAAS,IAAIhe,KAAK,CAAClR,IAAI,KAAK,OAAO,EAAE;MACrE,OAAO,KAAK;IAChB;IACA;IACA,IAAI,CAACsrB,SAAS,KAAKpa,KAAK,CAAClR,IAAI,KAAK,WAAW,IAAIkR,KAAK,CAAClR,IAAI,KAAK,YAAY,CAAC,EAAE;MAC3E,OAAO,KAAK;IAChB;IACA;IACA,IAAIoT,KAAK,CAACuN,OAAO,CAAC2K,SAAS,CAAC,IAAI,CAACA,SAAS,CAAClZ,QAAQ,CAAClB,KAAK,CAACgU,MAAM,CAAC,IAAIhU,KAAK,CAAClR,IAAI,KAAK,WAAW,EAAE;MAC7F,OAAO,KAAK;IAChB;IACA;IACA,MAAMmvB,aAAa,GAAI/b,KAAK,CAACuN,OAAO,CAAC2K,SAAS,CAAC,IAAIA,SAAS,CAAClZ,QAAQ,CAAClB,KAAK,CAACgU,MAAM,CAAC,IAAK,CAAChU,KAAK,CAACgU,MAAM,IAAIhU,KAAK,CAACgU,MAAM,IAAI,CAAC;IAC1H;IACA,OAAO,CAAC,CAAChU,KAAK,CAAC4Y,OAAO,IAAI5Y,KAAK,CAAClR,IAAI,KAAK,OAAO,KAAKmvB,aAAa;EACtE,CAAC;AACL;AAEA,SAASC,SAASA,CAAC;EAAE5Q,OAAO;EAAEnV,OAAO;EAAEC,OAAO;EAAE+lB,iBAAiB;EAAE5P,eAAe;EAAE9V,QAAQ;EAAE4iB,SAAS;EAAED,cAAc;EAAEE,YAAY;EAAEwB;AAAkB,CAAC,EAAE;EACxJ,MAAMhC,aAAa,GAAG;IAClBkC,kBAAkB,EAAE,KAAK;IACzBI,oBAAoB,EAAE,KAAK;IAC3BzD,YAAY,EAAE;MAAExpB,CAAC,EAAE,CAAC;MAAEC,CAAC,EAAE,CAAC;MAAEtC,IAAI,EAAE;IAAE,CAAC;IACrCivB,WAAW,EAAE,CAAC;IACdS,OAAO,EAAEroB,SAAS;IAClBinB,gBAAgB,EAAEjnB,SAAS;IAC3BknB,cAAc,EAAE;EACpB,CAAC;EACD,MAAM+B,IAAI,GAAG9Q,OAAO,CAAClL,qBAAqB,CAAC,CAAC;EAC5C,MAAMic,cAAc,GAAGvwB,IAAI,CAAC,CAAC,CACxB4lB,aAAa,CAAC,CAAC5W,SAAS,CAACqhB,iBAAiB,CAAC,IAAIA,iBAAiB,GAAG,CAAC,GAAG,CAAC,GAAGA,iBAAiB,CAAC,CAC7FG,WAAW,CAAC,CAACnmB,OAAO,EAAEC,OAAO,CAAC,CAAC,CAC/BmW,eAAe,CAACA,eAAe,CAAC;EACrC,MAAMoD,WAAW,GAAG/jB,MAAM,CAAC0f,OAAO,CAAC,CAAC2G,IAAI,CAACoK,cAAc,CAAC;EACxD5P,sBAAsB,CAAC;IACnBte,CAAC,EAAEsI,QAAQ,CAACtI,CAAC;IACbC,CAAC,EAAEqI,QAAQ,CAACrI,CAAC;IACbtC,IAAI,EAAEgN,KAAK,CAACrC,QAAQ,CAAC3K,IAAI,EAAEqK,OAAO,EAAEC,OAAO;EAC/C,CAAC,EAAE,CACC,CAAC,CAAC,EAAE,CAAC,CAAC,EACN,CAACgmB,IAAI,CAACtqB,KAAK,EAAEsqB,IAAI,CAACrqB,MAAM,CAAC,CAC5B,EAAEwa,eAAe,CAAC;EACnB,MAAMkO,aAAa,GAAG9K,WAAW,CAACgC,EAAE,CAAC,YAAY,CAAC;EAClD,MAAM4K,qBAAqB,GAAG5M,WAAW,CAACgC,EAAE,CAAC,eAAe,CAAC;EAC7D0K,cAAc,CAACzD,UAAU,CAACA,UAAU,CAAC;EACrC,SAAS4D,YAAYA,CAACve,SAAS,EAAEvI,OAAO,EAAE;IACtC,IAAIia,WAAW,EAAE;MACb,OAAO,IAAItZ,OAAO,CAAEC,OAAO,IAAK;QAC5B+lB,cAAc,EAAEnwB,WAAW,CAACwJ,OAAO,EAAExJ,WAAW,KAAK,QAAQ,GAAGA,WAAW,GAAGD,eAAe,CAAC,CAACgS,SAAS,CAACua,eAAe,CAAC7I,WAAW,EAAEja,OAAO,EAAEmB,QAAQ,EAAEnB,OAAO,EAAEoB,IAAI,EAAE,MAAMR,OAAO,CAAC,IAAI,CAAC,CAAC,EAAE2H,SAAS,CAAC;MAC5M,CAAC,CAAC;IACN;IACA,OAAO5H,OAAO,CAACC,OAAO,CAAC,KAAK,CAAC;EACjC;EACA;EACA,SAASyV,MAAMA,CAAC;IAAEgN,gBAAgB;IAAE+C,cAAc;IAAEZ,iBAAiB;IAAEW,mBAAmB;IAAEN,WAAW;IAAEnD,SAAS;IAAEa,eAAe;IAAEC,gBAAgB;IAAEsB,gBAAgB;IAAErB,WAAW;IAAEwC,YAAY;IAAEC,iBAAiB;IAAEF,wBAAwB;IAAEluB,GAAG;IAAE2tB;EAAmB,CAAC,EAAE;IACxQ,IAAIU,mBAAmB,IAAI,CAAC/C,aAAa,CAACkC,kBAAkB,EAAE;MAC1D9I,OAAO,CAAC,CAAC;IACb;IACA,MAAMuK,aAAa,GAAGlB,WAAW,IAAI,CAACG,wBAAwB,IAAI,CAACG,mBAAmB;IACtF,MAAMa,YAAY,GAAGD,aAAa,GAC5B5D,wBAAwB,CAAC;MACvBC,aAAa;MACbC,gBAAgB;MAChBpJ,WAAW;MACXqJ,MAAM,EAAEqD,cAAc;MACtBpD,eAAe;MACfC,gBAAgB;MAChBC,WAAW;MACXC,cAAc;MACdC,SAAS;MACTC;IACJ,CAAC,CAAC,GACAiB,yBAAyB,CAAC;MACxBxB,gBAAgB;MAChByB,gBAAgB;MAChBC;IACJ,CAAC,CAAC;IACN9K,WAAW,CAACgC,EAAE,CAAC,YAAY,EAAE+K,YAAY,EAAE;MAAEC,OAAO,EAAE;IAAM,CAAC,CAAC;IAC9D,IAAI,CAACd,mBAAmB,EAAE;MACtB;MACA,MAAMe,YAAY,GAAG/B,yBAAyB,CAAC;QAC3C/B,aAAa;QACbgC,gBAAgB;QAChB1B;MACJ,CAAC,CAAC;MACFiD,cAAc,CAAC1K,EAAE,CAAC,OAAO,EAAEiL,YAAY,CAAC;MACxC;MACA,MAAMC,cAAc,GAAG5B,oBAAoB,CAAC;QACxCnC,aAAa;QACbV,SAAS;QACT8C,iBAAiB,EAAE,CAAC,CAACA,iBAAiB;QACtC7B,SAAS;QACT8B;MACJ,CAAC,CAAC;MACFkB,cAAc,CAAC1K,EAAE,CAAC,MAAM,EAAEkL,cAAc,CAAC;MACzC;MACA,MAAMC,iBAAiB,GAAGxB,uBAAuB,CAAC;QAC9CxC,aAAa;QACbV,SAAS;QACTmD,WAAW;QACXL,iBAAiB;QACjB5B,YAAY;QACZwB;MACJ,CAAC,CAAC;MACFuB,cAAc,CAAC1K,EAAE,CAAC,KAAK,EAAEmL,iBAAiB,CAAC;IAC/C;IACA,MAAMtrB,MAAM,GAAGiqB,YAAY,CAAC;MACxBC,wBAAwB;MACxBtD,SAAS;MACTuD,YAAY;MACZJ,WAAW;MACXK,iBAAiB;MACjBzC,WAAW;MACX0C,mBAAmB;MACnBC,cAAc;MACd/C,gBAAgB;MAChBvrB;IACJ,CAAC,CAAC;IACF6uB,cAAc,CAAC7qB,MAAM,CAACA,MAAM,CAAC;IAC7B;AACR;AACA;AACA;AACA;IACQ,IAAIoqB,iBAAiB,EAAE;MACnBjM,WAAW,CAACgC,EAAE,CAAC,eAAe,EAAE4K,qBAAqB,CAAC;IAC1D,CAAC,MACI;MACD5M,WAAW,CAACgC,EAAE,CAAC,eAAe,EAAE,IAAI,CAAC;IACzC;EACJ;EACA,SAASO,OAAOA,CAAA,EAAG;IACfmK,cAAc,CAAC1K,EAAE,CAAC,MAAM,EAAE,IAAI,CAAC;EACnC;EACA,eAAelF,sBAAsBA,CAAChW,QAAQ,EAAEgB,MAAM,EAAE8U,eAAe,EAAE;IACrE,MAAMwQ,aAAa,GAAGjF,mBAAmB,CAACrhB,QAAQ,CAAC;IACnD,MAAMumB,mBAAmB,GAAGX,cAAc,EAAEY,SAAS,CAAC,CAAC,CAACF,aAAa,EAAEtlB,MAAM,EAAE8U,eAAe,CAAC;IAC/F,IAAIyQ,mBAAmB,EAAE;MACrB,MAAMR,YAAY,CAACQ,mBAAmB,CAAC;IAC3C;IACA,OAAO,IAAI3mB,OAAO,CAAEC,OAAO,IAAKA,OAAO,CAAC0mB,mBAAmB,CAAC,CAAC;EACjE;EACA,eAAepmB,WAAWA,CAACH,QAAQ,EAAEf,OAAO,EAAE;IAC1C,MAAMqnB,aAAa,GAAGjF,mBAAmB,CAACrhB,QAAQ,CAAC;IACnD,MAAM+lB,YAAY,CAACO,aAAa,EAAErnB,OAAO,CAAC;IAC1C,OAAO,IAAIW,OAAO,CAAEC,OAAO,IAAKA,OAAO,CAACymB,aAAa,CAAC,CAAC;EAC3D;EACA,SAASG,YAAYA,CAACzmB,QAAQ,EAAE;IAC5B,IAAIkZ,WAAW,EAAE;MACb,MAAMoN,aAAa,GAAGjF,mBAAmB,CAACrhB,QAAQ,CAAC;MACnD,MAAM0mB,gBAAgB,GAAGxN,WAAW,CAAC+J,QAAQ,CAAC,QAAQ,CAAC;MACvD,IAAIyD,gBAAgB,CAACxQ,CAAC,KAAKlW,QAAQ,CAAC3K,IAAI,IACpCqxB,gBAAgB,CAAChvB,CAAC,KAAKsI,QAAQ,CAACtI,CAAC,IACjCgvB,gBAAgB,CAAC/uB,CAAC,KAAKqI,QAAQ,CAACrI,CAAC,EAAE;QACnC;QACA;QACAiuB,cAAc,EAAEpe,SAAS,CAAC0R,WAAW,EAAEoN,aAAa,EAAE,IAAI,EAAE;UAAE1B,IAAI,EAAE;QAAK,CAAC,CAAC;MAC/E;IACJ;EACJ;EACA,SAAS+B,WAAWA,CAAA,EAAG;IACnB,MAAMnf,SAAS,GAAG0R,WAAW,GAAG3jB,aAAa,CAAC2jB,WAAW,CAAC5e,IAAI,CAAC,CAAC,CAAC,GAAG;MAAE5C,CAAC,EAAE,CAAC;MAAEC,CAAC,EAAE,CAAC;MAAEue,CAAC,EAAE;IAAE,CAAC;IACxF,OAAO;MAAExe,CAAC,EAAE8P,SAAS,CAAC9P,CAAC;MAAEC,CAAC,EAAE6P,SAAS,CAAC7P,CAAC;MAAEtC,IAAI,EAAEmS,SAAS,CAAC0O;IAAE,CAAC;EAChE;EACA,SAASsK,OAAOA,CAACnrB,IAAI,EAAE4J,OAAO,EAAE;IAC5B,IAAIia,WAAW,EAAE;MACb,OAAO,IAAItZ,OAAO,CAAEC,OAAO,IAAK;QAC5B+lB,cAAc,EAAEnwB,WAAW,CAACwJ,OAAO,EAAExJ,WAAW,KAAK,QAAQ,GAAGA,WAAW,GAAGD,eAAe,CAAC,CAACgrB,OAAO,CAACuB,eAAe,CAAC7I,WAAW,EAAEja,OAAO,EAAEmB,QAAQ,EAAEnB,OAAO,EAAEoB,IAAI,EAAE,MAAMR,OAAO,CAAC,IAAI,CAAC,CAAC,EAAExK,IAAI,CAAC;MACrM,CAAC,CAAC;IACN;IACA,OAAOuK,OAAO,CAACC,OAAO,CAAC,KAAK,CAAC;EACjC;EACA,SAAS+mB,OAAOA,CAAC1G,MAAM,EAAEjhB,OAAO,EAAE;IAC9B,IAAIia,WAAW,EAAE;MACb,OAAO,IAAItZ,OAAO,CAAEC,OAAO,IAAK;QAC5B+lB,cAAc,EAAEnwB,WAAW,CAACwJ,OAAO,EAAExJ,WAAW,KAAK,QAAQ,GAAGA,WAAW,GAAGD,eAAe,CAAC,CAACoxB,OAAO,CAAC7E,eAAe,CAAC7I,WAAW,EAAEja,OAAO,EAAEmB,QAAQ,EAAEnB,OAAO,EAAEoB,IAAI,EAAE,MAAMR,OAAO,CAAC,IAAI,CAAC,CAAC,EAAEqgB,MAAM,CAAC;MACvM,CAAC,CAAC;IACN;IACA,OAAOtgB,OAAO,CAACC,OAAO,CAAC,KAAK,CAAC;EACjC;EACA,SAASgnB,cAAcA,CAAChB,WAAW,EAAE;IACjCD,cAAc,EAAEC,WAAW,CAACA,WAAW,CAAC;EAC5C;EACA,SAASiB,kBAAkBA,CAAChR,eAAe,EAAE;IACzC8P,cAAc,EAAE9P,eAAe,CAACA,eAAe,CAAC;EACpD;EACA,SAASiR,gBAAgBA,CAAC1jB,QAAQ,EAAE;IAChC,MAAM2jB,aAAa,GAAG,CAAC3iB,SAAS,CAAChB,QAAQ,CAAC,IAAIA,QAAQ,GAAG,CAAC,GAAG,CAAC,GAAGA,QAAQ;IACzEuiB,cAAc,EAAE3K,aAAa,CAAC+L,aAAa,CAAC;EAChD;EACA,OAAO;IACH1R,MAAM;IACNmG,OAAO;IACPtb,WAAW;IACX6V,sBAAsB;IACtB2Q,WAAW;IACXnG,OAAO;IACPoG,OAAO;IACPC,cAAc;IACdC,kBAAkB;IAClBL,YAAY;IACZM;EACJ,CAAC;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAIE,oBAAoB;AACxB,CAAC,UAAUA,oBAAoB,EAAE;EAC7BA,oBAAoB,CAAC,MAAM,CAAC,GAAG,MAAM;EACrCA,oBAAoB,CAAC,QAAQ,CAAC,GAAG,QAAQ;AAC7C,CAAC,EAAEA,oBAAoB,KAAKA,oBAAoB,GAAG,CAAC,CAAC,CAAC,CAAC;AACvD,MAAMC,2BAA2B,GAAG,CAAC,UAAU,EAAE,WAAW,EAAE,aAAa,EAAE,cAAc,CAAC;AAC5F,MAAMC,yBAAyB,GAAG,CAAC,KAAK,EAAE,OAAO,EAAE,QAAQ,EAAE,MAAM,CAAC;;AAEpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,kBAAkBA,CAAC;EAAE/rB,KAAK;EAAEgsB,SAAS;EAAE/rB,MAAM;EAAEgsB,UAAU;EAAEC,QAAQ;EAAEC;AAAU,CAAC,EAAE;EACvF,MAAMC,UAAU,GAAGpsB,KAAK,GAAGgsB,SAAS;EACpC,MAAMK,WAAW,GAAGpsB,MAAM,GAAGgsB,UAAU;EACvC,MAAM7vB,SAAS,GAAG,CAACgwB,UAAU,GAAG,CAAC,GAAG,CAAC,GAAGA,UAAU,GAAG,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,EAAEC,WAAW,GAAG,CAAC,GAAG,CAAC,GAAGA,WAAW,GAAG,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC;EAChH,IAAID,UAAU,IAAIF,QAAQ,EAAE;IACxB9vB,SAAS,CAAC,CAAC,CAAC,GAAGA,SAAS,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;EACpC;EACA,IAAIiwB,WAAW,IAAIF,QAAQ,EAAE;IACzB/vB,SAAS,CAAC,CAAC,CAAC,GAAGA,SAAS,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;EACpC;EACA,OAAOA,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,SAASkwB,mBAAmBA,CAACC,eAAe,EAAE;EAC1C,MAAMC,YAAY,GAAGD,eAAe,CAACnf,QAAQ,CAAC,OAAO,CAAC,IAAImf,eAAe,CAACnf,QAAQ,CAAC,MAAM,CAAC;EAC1F,MAAMqf,UAAU,GAAGF,eAAe,CAACnf,QAAQ,CAAC,QAAQ,CAAC,IAAImf,eAAe,CAACnf,QAAQ,CAAC,KAAK,CAAC;EACxF,MAAM8e,QAAQ,GAAGK,eAAe,CAACnf,QAAQ,CAAC,MAAM,CAAC;EACjD,MAAM+e,QAAQ,GAAGI,eAAe,CAACnf,QAAQ,CAAC,KAAK,CAAC;EAChD,OAAO;IACHof,YAAY;IACZC,UAAU;IACVP,QAAQ;IACRC;EACJ,CAAC;AACL;AACA,SAASO,mBAAmBA,CAACC,WAAW,EAAEC,UAAU,EAAE;EAClD,OAAOxlB,IAAI,CAACD,GAAG,CAAC,CAAC,EAAEylB,UAAU,GAAGD,WAAW,CAAC;AAChD;AACA,SAASE,mBAAmBA,CAACC,WAAW,EAAEC,UAAU,EAAE;EAClD,OAAO3lB,IAAI,CAACD,GAAG,CAAC,CAAC,EAAE2lB,WAAW,GAAGC,UAAU,CAAC;AAChD;AACA,SAASC,YAAYA,CAAChvB,IAAI,EAAEivB,OAAO,EAAEC,OAAO,EAAE;EAC1C,OAAO9lB,IAAI,CAACD,GAAG,CAAC,CAAC,EAAE8lB,OAAO,GAAGjvB,IAAI,EAAEA,IAAI,GAAGkvB,OAAO,CAAC;AACtD;AACA,SAASC,GAAGA,CAACrvB,CAAC,EAAEC,CAAC,EAAE;EACf,OAAOD,CAAC,GAAG,CAACC,CAAC,GAAGA,CAAC;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASqvB,wBAAwBA,CAACC,WAAW,EAAEC,gBAAgB,EAAEC,eAAe,EAAEC,UAAU,EAAEC,eAAe,EAAE1tB,UAAU,EAAE4F,MAAM,EAAE+nB,WAAW,EAAE;EAC5I,IAAI;IAAExB,QAAQ;IAAEC;EAAS,CAAC,GAAGmB,gBAAgB;EAC7C,MAAM;IAAEd,YAAY;IAAEC;EAAW,CAAC,GAAGa,gBAAgB;EACrD,MAAMK,UAAU,GAAGnB,YAAY,IAAIC,UAAU;EAC7C,MAAM;IAAElgB,QAAQ;IAAEC;EAAS,CAAC,GAAG+gB,eAAe;EAC9C,MAAM;IAAEK,QAAQ;IAAEC,QAAQ;IAAEC,SAAS;IAAEC;EAAU,CAAC,GAAGP,UAAU;EAC/D,MAAM;IAAEnxB,CAAC,EAAE2xB,MAAM;IAAE1xB,CAAC,EAAE2xB,MAAM;IAAEjuB,KAAK,EAAEkuB,UAAU;IAAEjuB,MAAM,EAAEkuB,WAAW;IAAEC;EAAY,CAAC,GAAGf,WAAW;EACjG,IAAIgB,KAAK,GAAGjnB,IAAI,CAACuC,KAAK,CAAC6iB,YAAY,GAAGjgB,QAAQ,GAAG8gB,WAAW,CAACiB,QAAQ,GAAG,CAAC,CAAC;EAC1E,IAAIC,KAAK,GAAGnnB,IAAI,CAACuC,KAAK,CAAC8iB,UAAU,GAAGjgB,QAAQ,GAAG6gB,WAAW,CAACmB,QAAQ,GAAG,CAAC,CAAC;EACxE,MAAMvV,QAAQ,GAAGiV,UAAU,IAAIhC,QAAQ,GAAG,CAACmC,KAAK,GAAGA,KAAK,CAAC;EACzD,MAAMnV,SAAS,GAAGiV,WAAW,IAAIhC,QAAQ,GAAG,CAACoC,KAAK,GAAGA,KAAK,CAAC;EAC3D,MAAME,aAAa,GAAG,CAAC1uB,UAAU,CAAC,CAAC,CAAC,GAAGmuB,UAAU;EACjD,MAAMQ,aAAa,GAAG,CAAC3uB,UAAU,CAAC,CAAC,CAAC,GAAGouB,WAAW;EAClD;EACA,IAAIQ,MAAM,GAAG3B,YAAY,CAAC/T,QAAQ,EAAE2U,QAAQ,EAAEC,QAAQ,CAAC;EACvD,IAAIe,MAAM,GAAG5B,YAAY,CAAC9T,SAAS,EAAE4U,SAAS,EAAEC,SAAS,CAAC;EAC1D;EACA,IAAIpoB,MAAM,EAAE;IACR,IAAIkpB,YAAY,GAAG,CAAC;IACpB,IAAIC,YAAY,GAAG,CAAC;IACpB,IAAI5C,QAAQ,IAAImC,KAAK,GAAG,CAAC,EAAE;MACvBQ,YAAY,GAAGnC,mBAAmB,CAACsB,MAAM,GAAGK,KAAK,GAAGI,aAAa,EAAE9oB,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;IACpF,CAAC,MACI,IAAI,CAACumB,QAAQ,IAAImC,KAAK,GAAG,CAAC,EAAE;MAC7BQ,YAAY,GAAGhC,mBAAmB,CAACmB,MAAM,GAAG/U,QAAQ,GAAGwV,aAAa,EAAE9oB,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;IACvF;IACA,IAAIwmB,QAAQ,IAAIoC,KAAK,GAAG,CAAC,EAAE;MACvBO,YAAY,GAAGpC,mBAAmB,CAACuB,MAAM,GAAGM,KAAK,GAAGG,aAAa,EAAE/oB,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;IACpF,CAAC,MACI,IAAI,CAACwmB,QAAQ,IAAIoC,KAAK,GAAG,CAAC,EAAE;MAC7BO,YAAY,GAAGjC,mBAAmB,CAACoB,MAAM,GAAG/U,SAAS,GAAGwV,aAAa,EAAE/oB,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;IACxF;IACAgpB,MAAM,GAAGvnB,IAAI,CAACD,GAAG,CAACwnB,MAAM,EAAEE,YAAY,CAAC;IACvCD,MAAM,GAAGxnB,IAAI,CAACD,GAAG,CAACynB,MAAM,EAAEE,YAAY,CAAC;EAC3C;EACA;EACA,IAAIpB,WAAW,EAAE;IACb,IAAImB,YAAY,GAAG,CAAC;IACpB,IAAIC,YAAY,GAAG,CAAC;IACpB,IAAI5C,QAAQ,IAAImC,KAAK,GAAG,CAAC,EAAE;MACvBQ,YAAY,GAAGhC,mBAAmB,CAACmB,MAAM,GAAGK,KAAK,EAAEX,WAAW,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;IACzE,CAAC,MACI,IAAI,CAACxB,QAAQ,IAAImC,KAAK,GAAG,CAAC,EAAE;MAC7BQ,YAAY,GAAGnC,mBAAmB,CAACsB,MAAM,GAAG/U,QAAQ,EAAEyU,WAAW,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;IAC5E;IACA,IAAIvB,QAAQ,IAAIoC,KAAK,GAAG,CAAC,EAAE;MACvBO,YAAY,GAAGjC,mBAAmB,CAACoB,MAAM,GAAGM,KAAK,EAAEb,WAAW,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;IACzE,CAAC,MACI,IAAI,CAACvB,QAAQ,IAAIoC,KAAK,GAAG,CAAC,EAAE;MAC7BO,YAAY,GAAGpC,mBAAmB,CAACuB,MAAM,GAAG/U,SAAS,EAAEwU,WAAW,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;IAC7E;IACAiB,MAAM,GAAGvnB,IAAI,CAACD,GAAG,CAACwnB,MAAM,EAAEE,YAAY,CAAC;IACvCD,MAAM,GAAGxnB,IAAI,CAACD,GAAG,CAACynB,MAAM,EAAEE,YAAY,CAAC;EAC3C;EACA;EACA,IAAIrB,eAAe,EAAE;IACjB,IAAIjB,YAAY,EAAE;MACd;MACA,MAAMuC,iBAAiB,GAAG/B,YAAY,CAAC/T,QAAQ,GAAGmV,WAAW,EAAEN,SAAS,EAAEC,SAAS,CAAC,GAAGK,WAAW;MAClGO,MAAM,GAAGvnB,IAAI,CAACD,GAAG,CAACwnB,MAAM,EAAEI,iBAAiB,CAAC;MAC5C;MACA,IAAIppB,MAAM,EAAE;QACR,IAAIqpB,iBAAiB,GAAG,CAAC;QACzB,IAAK,CAAC9C,QAAQ,IAAI,CAACC,QAAQ,IAAMD,QAAQ,IAAI,CAACC,QAAQ,IAAIwB,UAAW,EAAE;UACnEqB,iBAAiB,GACbnC,mBAAmB,CAACoB,MAAM,GAAGS,aAAa,GAAGzV,QAAQ,GAAGmV,WAAW,EAAEzoB,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAGyoB,WAAW;QACxG,CAAC,MACI;UACDY,iBAAiB,GACbtC,mBAAmB,CAACuB,MAAM,GAAGS,aAAa,GAAG,CAACxC,QAAQ,GAAGmC,KAAK,GAAG,CAACA,KAAK,IAAID,WAAW,EAAEzoB,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GACjGyoB,WAAW;QACvB;QACAO,MAAM,GAAGvnB,IAAI,CAACD,GAAG,CAACwnB,MAAM,EAAEK,iBAAiB,CAAC;MAChD;MACA;MACA,IAAItB,WAAW,EAAE;QACb,IAAIsB,iBAAiB,GAAG,CAAC;QACzB,IAAK,CAAC9C,QAAQ,IAAI,CAACC,QAAQ,IAAMD,QAAQ,IAAI,CAACC,QAAQ,IAAIwB,UAAW,EAAE;UACnEqB,iBAAiB,GAAGtC,mBAAmB,CAACuB,MAAM,GAAGhV,QAAQ,GAAGmV,WAAW,EAAEV,WAAW,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAGU,WAAW;QAC7G,CAAC,MACI;UACDY,iBAAiB,GACbnC,mBAAmB,CAACoB,MAAM,GAAG,CAAC/B,QAAQ,GAAGmC,KAAK,GAAG,CAACA,KAAK,IAAID,WAAW,EAAEV,WAAW,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAGU,WAAW;QAChH;QACAO,MAAM,GAAGvnB,IAAI,CAACD,GAAG,CAACwnB,MAAM,EAAEK,iBAAiB,CAAC;MAChD;IACJ;IACA;IACA,IAAIvC,UAAU,EAAE;MACZ,MAAMwC,gBAAgB,GAAGjC,YAAY,CAAC9T,SAAS,GAAGkV,WAAW,EAAER,QAAQ,EAAEC,QAAQ,CAAC,GAAGO,WAAW;MAChGQ,MAAM,GAAGxnB,IAAI,CAACD,GAAG,CAACynB,MAAM,EAAEK,gBAAgB,CAAC;MAC3C,IAAItpB,MAAM,EAAE;QACR,IAAIqpB,iBAAiB,GAAG,CAAC;QACzB,IAAK,CAAC9C,QAAQ,IAAI,CAACC,QAAQ,IAAMA,QAAQ,IAAI,CAACD,QAAQ,IAAIyB,UAAW,EAAE;UACnEqB,iBAAiB,GACbnC,mBAAmB,CAACmB,MAAM,GAAG9U,SAAS,GAAGkV,WAAW,GAAGK,aAAa,EAAE9oB,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAGyoB,WAAW;QACzG,CAAC,MACI;UACDY,iBAAiB,GACbtC,mBAAmB,CAACsB,MAAM,GAAG,CAAC7B,QAAQ,GAAGoC,KAAK,GAAG,CAACA,KAAK,IAAIH,WAAW,GAAGK,aAAa,EAAE9oB,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GACjGyoB,WAAW;QACvB;QACAQ,MAAM,GAAGxnB,IAAI,CAACD,GAAG,CAACynB,MAAM,EAAEI,iBAAiB,CAAC;MAChD;MACA,IAAItB,WAAW,EAAE;QACb,IAAIsB,iBAAiB,GAAG,CAAC;QACzB,IAAK,CAAC9C,QAAQ,IAAI,CAACC,QAAQ,IAAMA,QAAQ,IAAI,CAACD,QAAQ,IAAIyB,UAAW,EAAE;UACnEqB,iBAAiB,GAAGtC,mBAAmB,CAACsB,MAAM,GAAG9U,SAAS,GAAGkV,WAAW,EAAEV,WAAW,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAGU,WAAW;QAC9G,CAAC,MACI;UACDY,iBAAiB,GACbnC,mBAAmB,CAACmB,MAAM,GAAG,CAAC7B,QAAQ,GAAGoC,KAAK,GAAG,CAACA,KAAK,IAAIH,WAAW,EAAEV,WAAW,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAGU,WAAW;QAChH;QACAQ,MAAM,GAAGxnB,IAAI,CAACD,GAAG,CAACynB,MAAM,EAAEI,iBAAiB,CAAC;MAChD;IACJ;EACJ;EACAT,KAAK,GAAGA,KAAK,IAAIA,KAAK,GAAG,CAAC,GAAGK,MAAM,GAAG,CAACA,MAAM,CAAC;EAC9CP,KAAK,GAAGA,KAAK,IAAIA,KAAK,GAAG,CAAC,GAAGM,MAAM,GAAG,CAACA,MAAM,CAAC;EAC9C,IAAIlB,eAAe,EAAE;IACjB,IAAIE,UAAU,EAAE;MACZ,IAAI1U,QAAQ,GAAGC,SAAS,GAAGkV,WAAW,EAAE;QACpCG,KAAK,GAAG,CAACpB,GAAG,CAACjB,QAAQ,EAAEC,QAAQ,CAAC,GAAG,CAACkC,KAAK,GAAGA,KAAK,IAAID,WAAW;MACpE,CAAC,MACI;QACDC,KAAK,GAAG,CAAClB,GAAG,CAACjB,QAAQ,EAAEC,QAAQ,CAAC,GAAG,CAACoC,KAAK,GAAGA,KAAK,IAAIH,WAAW;MACpE;IACJ,CAAC,MACI;MACD,IAAI5B,YAAY,EAAE;QACd+B,KAAK,GAAGF,KAAK,GAAGD,WAAW;QAC3BjC,QAAQ,GAAGD,QAAQ;MACvB,CAAC,MACI;QACDmC,KAAK,GAAGE,KAAK,GAAGH,WAAW;QAC3BlC,QAAQ,GAAGC,QAAQ;MACvB;IACJ;EACJ;EACA,MAAM9vB,CAAC,GAAG6vB,QAAQ,GAAG8B,MAAM,GAAGK,KAAK,GAAGL,MAAM;EAC5C,MAAM1xB,CAAC,GAAG6vB,QAAQ,GAAG8B,MAAM,GAAGM,KAAK,GAAGN,MAAM;EAC5C,OAAO;IACHjuB,KAAK,EAAEkuB,UAAU,IAAIhC,QAAQ,GAAG,CAACmC,KAAK,GAAGA,KAAK,CAAC;IAC/CpuB,MAAM,EAAEkuB,WAAW,IAAIhC,QAAQ,GAAG,CAACoC,KAAK,GAAGA,KAAK,CAAC;IACjDlyB,CAAC,EAAE0D,UAAU,CAAC,CAAC,CAAC,GAAGsuB,KAAK,IAAI,CAACnC,QAAQ,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG7vB,CAAC;IACnDC,CAAC,EAAEyD,UAAU,CAAC,CAAC,CAAC,GAAGwuB,KAAK,IAAI,CAACpC,QAAQ,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG7vB;EACtD,CAAC;AACL;AAEA,MAAM4yB,cAAc,GAAG;EAAElvB,KAAK,EAAE,CAAC;EAAEC,MAAM,EAAE,CAAC;EAAE5D,CAAC,EAAE,CAAC;EAAEC,CAAC,EAAE;AAAE,CAAC;AAC1D,MAAM6yB,eAAe,GAAG;EACpB,GAAGD,cAAc;EACjBZ,QAAQ,EAAE,CAAC;EACXE,QAAQ,EAAE,CAAC;EACXJ,WAAW,EAAE;AACjB,CAAC;AACD,SAASgB,kBAAkBA,CAACnwB,IAAI,EAAE;EAC9B,OAAO,CACH,CAAC,CAAC,EAAE,CAAC,CAAC,EACN,CAACA,IAAI,CAACyD,QAAQ,CAAC1C,KAAK,EAAEf,IAAI,CAACyD,QAAQ,CAACzC,MAAM,CAAC,CAC9C;AACL;AACA,SAASovB,iBAAiBA,CAACzW,KAAK,EAAEnR,MAAM,EAAE1H,UAAU,EAAE;EAClD,MAAM1D,CAAC,GAAGoL,MAAM,CAACnH,QAAQ,CAACjE,CAAC,GAAGuc,KAAK,CAACtY,QAAQ,CAACjE,CAAC;EAC9C,MAAMC,CAAC,GAAGmL,MAAM,CAACnH,QAAQ,CAAChE,CAAC,GAAGsc,KAAK,CAACtY,QAAQ,CAAChE,CAAC;EAC9C,MAAM0D,KAAK,GAAG4Y,KAAK,CAAClW,QAAQ,CAAC1C,KAAK,IAAI,CAAC;EACvC,MAAMC,MAAM,GAAG2Y,KAAK,CAAClW,QAAQ,CAACzC,MAAM,IAAI,CAAC;EACzC,MAAMwuB,aAAa,GAAG1uB,UAAU,CAAC,CAAC,CAAC,GAAGC,KAAK;EAC3C,MAAM0uB,aAAa,GAAG3uB,UAAU,CAAC,CAAC,CAAC,GAAGE,MAAM;EAC5C,OAAO,CACH,CAAC5D,CAAC,GAAGoyB,aAAa,EAAEnyB,CAAC,GAAGoyB,aAAa,CAAC,EACtC,CAACryB,CAAC,GAAG2D,KAAK,GAAGyuB,aAAa,EAAEnyB,CAAC,GAAG2D,MAAM,GAAGyuB,aAAa,CAAC,CAC1D;AACL;AACA,SAASY,SAASA,CAAC;EAAE9V,OAAO;EAAEtU,MAAM;EAAEkY,aAAa;EAAEmS,QAAQ;EAAE5I;AAAM,CAAC,EAAE;EACpE,MAAMpC,SAAS,GAAGzqB,MAAM,CAAC0f,OAAO,CAAC;EACjC,SAASS,MAAMA,CAAC;IAAEsS,eAAe;IAAEiB,UAAU;IAAEC,eAAe;IAAE+B,eAAe;IAAEC,aAAa;IAAEC,QAAQ;IAAEC,WAAW;IAAEC;EAAc,CAAC,EAAE;IACpI,IAAIC,UAAU,GAAG;MAAE,GAAGX;IAAe,CAAC;IACtC,IAAI7B,WAAW,GAAG;MAAE,GAAG8B;IAAgB,CAAC;IACxC,MAAM7B,gBAAgB,GAAGhB,mBAAmB,CAACC,eAAe,CAAC;IAC7D,IAAIttB,IAAI,GAAGoC,SAAS;IACpB,IAAI+K,eAAe,GAAG,IAAI;IAC1B,IAAI6L,UAAU,GAAG,EAAE;IACnB,IAAI3S,UAAU,GAAGjE,SAAS,CAAC,CAAC;IAC5B,IAAIyuB,YAAY,GAAGzuB,SAAS;IAC5B,IAAIqsB,WAAW,GAAGrsB,SAAS;IAC3B,MAAM0uB,WAAW,GAAGl2B,IAAI,CAAC,CAAC,CACrBgmB,EAAE,CAAC,OAAO,EAAG3T,KAAK,IAAK;MACxB,MAAM;QAAEtL,UAAU;QAAEuL,SAAS;QAAE7C,QAAQ;QAAEE,UAAU;QAAEzJ,UAAU;QAAEiwB;MAAY,CAAC,GAAG5S,aAAa,CAAC,CAAC;MAChGne,IAAI,GAAG2B,UAAU,CAACU,GAAG,CAAC4D,MAAM,CAAC;MAC7B,IAAI,CAACjG,IAAI,EAAE;QACP;MACJ;MACAmN,eAAe,GAAG4jB,WAAW,EAAE1hB,qBAAqB,CAAC,CAAC,IAAI,IAAI;MAC9D,MAAM;QAAE/B,QAAQ;QAAEC;MAAS,CAAC,GAAGP,kBAAkB,CAACC,KAAK,CAACwT,WAAW,EAAE;QACjEvT,SAAS;QACT7C,QAAQ;QACRE,UAAU;QACV4C;MACJ,CAAC,CAAC;MACFyjB,UAAU,GAAG;QACT7vB,KAAK,EAAEf,IAAI,CAACyD,QAAQ,CAAC1C,KAAK,IAAI,CAAC;QAC/BC,MAAM,EAAEhB,IAAI,CAACyD,QAAQ,CAACzC,MAAM,IAAI,CAAC;QACjC5D,CAAC,EAAE4C,IAAI,CAACqB,QAAQ,CAACjE,CAAC,IAAI,CAAC;QACvBC,CAAC,EAAE2C,IAAI,CAACqB,QAAQ,CAAChE,CAAC,IAAI;MAC1B,CAAC;MACD+wB,WAAW,GAAG;QACV,GAAGwC,UAAU;QACbvB,QAAQ,EAAE/hB,QAAQ;QAClBiiB,QAAQ,EAAEhiB,QAAQ;QAClB4hB,WAAW,EAAEyB,UAAU,CAAC7vB,KAAK,GAAG6vB,UAAU,CAAC5vB;MAC/C,CAAC;MACDqF,UAAU,GAAGjE,SAAS;MACtB,IAAIpC,IAAI,CAACsG,QAAQ,KAAKtG,IAAI,CAAC0G,MAAM,KAAK,QAAQ,IAAI1G,IAAI,CAAC2G,YAAY,CAAC,EAAE;QAClEN,UAAU,GAAG1E,UAAU,CAACU,GAAG,CAACrC,IAAI,CAACsG,QAAQ,CAAC;QAC1CuqB,YAAY,GAAGxqB,UAAU,IAAIrG,IAAI,CAAC0G,MAAM,KAAK,QAAQ,GAAGypB,kBAAkB,CAAC9pB,UAAU,CAAC,GAAGjE,SAAS;MACtG;MACA;AACZ;AACA;AACA;MACY4W,UAAU,GAAG,EAAE;MACfyV,WAAW,GAAGrsB,SAAS;MACvB,KAAK,MAAM,CAAC4uB,OAAO,EAAErX,KAAK,CAAC,IAAIhY,UAAU,EAAE;QACvC,IAAIgY,KAAK,CAACrT,QAAQ,KAAKL,MAAM,EAAE;UAC3B+S,UAAU,CAACxZ,IAAI,CAAC;YACZ3D,EAAE,EAAEm1B,OAAO;YACX3vB,QAAQ,EAAE;cAAE,GAAGsY,KAAK,CAACtY;YAAS,CAAC;YAC/BqF,MAAM,EAAEiT,KAAK,CAACjT;UAClB,CAAC,CAAC;UACF,IAAIiT,KAAK,CAACjT,MAAM,KAAK,QAAQ,IAAIiT,KAAK,CAAChT,YAAY,EAAE;YACjD,MAAMD,MAAM,GAAG0pB,iBAAiB,CAACzW,KAAK,EAAE3Z,IAAI,EAAE2Z,KAAK,CAACzY,MAAM,IAAIJ,UAAU,CAAC;YACzE,IAAI2tB,WAAW,EAAE;cACbA,WAAW,GAAG,CACV,CAACtmB,IAAI,CAACF,GAAG,CAACvB,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE+nB,WAAW,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAEtmB,IAAI,CAACF,GAAG,CAACvB,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE+nB,WAAW,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EACtF,CAACtmB,IAAI,CAACD,GAAG,CAACxB,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE+nB,WAAW,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAEtmB,IAAI,CAACD,GAAG,CAACxB,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE+nB,WAAW,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CACzF;YACL,CAAC,MACI;cACDA,WAAW,GAAG/nB,MAAM;YACxB;UACJ;QACJ;MACJ;MACA8pB,aAAa,GAAGvjB,KAAK,EAAE;QAAE,GAAG2jB;MAAW,CAAC,CAAC;IAC7C,CAAC,CAAC,CACGhQ,EAAE,CAAC,MAAM,EAAG3T,KAAK,IAAK;MACvB,MAAM;QAAEC,SAAS;QAAE7C,QAAQ;QAAEE,UAAU;QAAEzJ,UAAU,EAAEmwB;MAAgB,CAAC,GAAG9S,aAAa,CAAC,CAAC;MACxF,MAAMmQ,eAAe,GAAGthB,kBAAkB,CAACC,KAAK,CAACwT,WAAW,EAAE;QAC1DvT,SAAS;QACT7C,QAAQ;QACRE,UAAU;QACV4C;MACJ,CAAC,CAAC;MACF,MAAM+jB,YAAY,GAAG,EAAE;MACvB,IAAI,CAAClxB,IAAI,EAAE;QACP;MACJ;MACA,MAAM;QAAE5C,CAAC,EAAE+zB,KAAK;QAAE9zB,CAAC,EAAE+zB,KAAK;QAAErwB,KAAK,EAAEgsB,SAAS;QAAE/rB,MAAM,EAAEgsB;MAAW,CAAC,GAAG4D,UAAU;MAC/E,MAAMS,MAAM,GAAG,CAAC,CAAC;MACjB,MAAMvwB,UAAU,GAAGd,IAAI,CAACkB,MAAM,IAAI+vB,eAAe;MACjD,MAAM;QAAElwB,KAAK;QAAEC,MAAM;QAAE5D,CAAC;QAAEC;MAAE,CAAC,GAAG8wB,wBAAwB,CAACC,WAAW,EAAEC,gBAAgB,EAAEC,eAAe,EAAEC,UAAU,EAAEC,eAAe,EAAE1tB,UAAU,EAAE+vB,YAAY,EAAEpC,WAAW,CAAC;MAC5K,MAAM6C,aAAa,GAAGvwB,KAAK,KAAKgsB,SAAS;MACzC,MAAMwE,cAAc,GAAGvwB,MAAM,KAAKgsB,UAAU;MAC5C,MAAMwE,YAAY,GAAGp0B,CAAC,KAAK+zB,KAAK,IAAIG,aAAa;MACjD,MAAMG,YAAY,GAAGp0B,CAAC,KAAK+zB,KAAK,IAAIG,cAAc;MAClD,IAAI,CAACC,YAAY,IAAI,CAACC,YAAY,IAAI,CAACH,aAAa,IAAI,CAACC,cAAc,EAAE;QACrE;MACJ;MACA,IAAIC,YAAY,IAAIC,YAAY,IAAI3wB,UAAU,CAAC,CAAC,CAAC,KAAK,CAAC,IAAIA,UAAU,CAAC,CAAC,CAAC,KAAK,CAAC,EAAE;QAC5EuwB,MAAM,CAACj0B,CAAC,GAAGo0B,YAAY,GAAGp0B,CAAC,GAAGwzB,UAAU,CAACxzB,CAAC;QAC1Ci0B,MAAM,CAACh0B,CAAC,GAAGo0B,YAAY,GAAGp0B,CAAC,GAAGuzB,UAAU,CAACvzB,CAAC;QAC1CuzB,UAAU,CAACxzB,CAAC,GAAGi0B,MAAM,CAACj0B,CAAC;QACvBwzB,UAAU,CAACvzB,CAAC,GAAGg0B,MAAM,CAACh0B,CAAC;QACvB;AAChB;AACA;AACA;QACgB,IAAI2b,UAAU,CAACvZ,MAAM,GAAG,CAAC,EAAE;UACvB,MAAMqa,OAAO,GAAG1c,CAAC,GAAG+zB,KAAK;UACzB,MAAMpX,OAAO,GAAG1c,CAAC,GAAG+zB,KAAK;UACzB,KAAK,MAAMjY,SAAS,IAAIH,UAAU,EAAE;YAChCG,SAAS,CAAC9X,QAAQ,GAAG;cACjBjE,CAAC,EAAE+b,SAAS,CAAC9X,QAAQ,CAACjE,CAAC,GAAG0c,OAAO,GAAGhZ,UAAU,CAAC,CAAC,CAAC,IAAIC,KAAK,GAAGgsB,SAAS,CAAC;cACvE1vB,CAAC,EAAE8b,SAAS,CAAC9X,QAAQ,CAAChE,CAAC,GAAG0c,OAAO,GAAGjZ,UAAU,CAAC,CAAC,CAAC,IAAIE,MAAM,GAAGgsB,UAAU;YAC5E,CAAC;YACDkE,YAAY,CAAC1xB,IAAI,CAAC2Z,SAAS,CAAC;UAChC;QACJ;MACJ;MACA,IAAImY,aAAa,IAAIC,cAAc,EAAE;QACjCF,MAAM,CAACtwB,KAAK,GACRuwB,aAAa,KAAK,CAACf,eAAe,IAAIA,eAAe,KAAK,YAAY,CAAC,GAAGxvB,KAAK,GAAG6vB,UAAU,CAAC7vB,KAAK;QACtGswB,MAAM,CAACrwB,MAAM,GACTuwB,cAAc,KAAK,CAAChB,eAAe,IAAIA,eAAe,KAAK,UAAU,CAAC,GAAGvvB,MAAM,GAAG4vB,UAAU,CAAC5vB,MAAM;QACvG4vB,UAAU,CAAC7vB,KAAK,GAAGswB,MAAM,CAACtwB,KAAK;QAC/B6vB,UAAU,CAAC5vB,MAAM,GAAGqwB,MAAM,CAACrwB,MAAM;MACrC;MACA;MACA,IAAIqF,UAAU,IAAIrG,IAAI,CAAC2G,YAAY,EAAE;QACjC,MAAM+qB,MAAM,GAAG5wB,UAAU,CAAC,CAAC,CAAC,IAAIuwB,MAAM,CAACtwB,KAAK,IAAI,CAAC,CAAC;QAClD,IAAIswB,MAAM,CAACj0B,CAAC,IAAIi0B,MAAM,CAACj0B,CAAC,GAAGs0B,MAAM,EAAE;UAC/Bd,UAAU,CAACxzB,CAAC,GAAGs0B,MAAM;UACrBtD,WAAW,CAAChxB,CAAC,GAAGgxB,WAAW,CAAChxB,CAAC,IAAIi0B,MAAM,CAACj0B,CAAC,GAAGs0B,MAAM,CAAC;QACvD;QACA,MAAMC,MAAM,GAAG7wB,UAAU,CAAC,CAAC,CAAC,IAAIuwB,MAAM,CAACrwB,MAAM,IAAI,CAAC,CAAC;QACnD,IAAIqwB,MAAM,CAACh0B,CAAC,IAAIg0B,MAAM,CAACh0B,CAAC,GAAGs0B,MAAM,EAAE;UAC/Bf,UAAU,CAACvzB,CAAC,GAAGs0B,MAAM;UACrBvD,WAAW,CAAC/wB,CAAC,GAAG+wB,WAAW,CAAC/wB,CAAC,IAAIg0B,MAAM,CAACh0B,CAAC,GAAGs0B,MAAM,CAAC;QACvD;MACJ;MACA,MAAMx0B,SAAS,GAAG2vB,kBAAkB,CAAC;QACjC/rB,KAAK,EAAE6vB,UAAU,CAAC7vB,KAAK;QACvBgsB,SAAS;QACT/rB,MAAM,EAAE4vB,UAAU,CAAC5vB,MAAM;QACzBgsB,UAAU;QACVC,QAAQ,EAAEoB,gBAAgB,CAACpB,QAAQ;QACnCC,QAAQ,EAAEmB,gBAAgB,CAACnB;MAC/B,CAAC,CAAC;MACF,MAAM0E,UAAU,GAAG;QAAE,GAAGhB,UAAU;QAAEzzB;MAAU,CAAC;MAC/C,MAAM00B,UAAU,GAAGlB,YAAY,GAAG1jB,KAAK,EAAE2kB,UAAU,CAAC;MACpD,IAAIC,UAAU,KAAK,KAAK,EAAE;QACtB;MACJ;MACApB,QAAQ,GAAGxjB,KAAK,EAAE2kB,UAAU,CAAC;MAC7BtB,QAAQ,CAACe,MAAM,EAAEH,YAAY,CAAC;IAClC,CAAC,CAAC,CACGtQ,EAAE,CAAC,KAAK,EAAG3T,KAAK,IAAK;MACtByjB,WAAW,GAAGzjB,KAAK,EAAE;QAAE,GAAG2jB;MAAW,CAAC,CAAC;MACvClJ,KAAK,GAAG;QAAE,GAAGkJ;MAAW,CAAC,CAAC;IAC9B,CAAC,CAAC;IACFtL,SAAS,CAACpE,IAAI,CAAC4P,WAAW,CAAC;EAC/B;EACA,SAAS3P,OAAOA,CAAA,EAAG;IACfmE,SAAS,CAAC1E,EAAE,CAAC,OAAO,EAAE,IAAI,CAAC;EAC/B;EACA,OAAO;IACH5F,MAAM;IACNmG;EACJ,CAAC;AACL;AAEA,SAAS/iB,kBAAkB,EAAEd,cAAc,EAAEe,UAAU,EAAEd,eAAe,EAAEe,QAAQ,EAAEquB,oBAAoB,EAAEnvB,aAAa,EAAEygB,MAAM,EAAEkH,QAAQ,EAAEC,SAAS,EAAE+F,SAAS,EAAEkF,SAAS,EAAEzD,2BAA2B,EAAEC,yBAAyB,EAAE5a,OAAO,EAAEsG,cAAc,EAAE3Z,sBAAsB,EAAE2N,YAAY,EAAE3J,SAAS,EAAEgG,WAAW,EAAE5C,qBAAqB,EAAE+B,KAAK,EAAEhB,aAAa,EAAEsB,qBAAqB,EAAEmO,eAAe,EAAEvZ,sBAAsB,EAAEiN,OAAO,EAAElN,oBAAoB,EAAE5B,aAAa,EAAEkR,wBAAwB,EAAEpH,WAAW,EAAEqK,mBAAmB,EAAEkB,aAAa,EAAE/N,gBAAgB,EAAE2G,gBAAgB,EAAE7E,iBAAiB,EAAE9E,mBAAmB,EAAE8N,aAAa,EAAEsD,aAAa,EAAEyE,eAAe,EAAEvO,mBAAmB,EAAEiK,qBAAqB,EAAE7D,gBAAgB,EAAE0B,eAAe,EAAEgH,iBAAiB,EAAEnI,iBAAiB,EAAEhN,WAAW,EAAEkC,sBAAsB,EAAEqT,WAAW,EAAEjV,iBAAiB,EAAEJ,yBAAyB,EAAEsW,uBAAuB,EAAE7V,cAAc,EAAEwB,cAAc,EAAE/C,WAAW,EAAEgE,kBAAkB,EAAEiJ,kBAAkB,EAAEiI,iBAAiB,EAAEtC,eAAe,EAAEhN,oBAAoB,EAAExG,sBAAsB,EAAEoa,kBAAkB,EAAE3c,cAAc,EAAEa,iBAAiB,EAAEqJ,kBAAkB,EAAEnH,UAAU,EAAE+R,aAAa,EAAE1D,cAAc,EAAElO,kBAAkB,EAAEmM,OAAO,EAAEsC,YAAY,EAAE1O,UAAU,EAAEkK,SAAS,EAAEF,YAAY,EAAEiD,oBAAoB,EAAET,iBAAiB,EAAE9J,SAAS,EAAEyB,UAAU,EAAEzF,gBAAgB,EAAE+c,KAAK,EAAEhY,oBAAoB,EAAE8O,aAAa,EAAEhJ,SAAS,EAAEoB,oBAAoB,EAAEgS,eAAe,EAAEpS,YAAY,EAAE6N,uBAAuB,EAAEkE,sBAAsB,EAAE9B,mBAAmB,EAAE5N,aAAa","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}